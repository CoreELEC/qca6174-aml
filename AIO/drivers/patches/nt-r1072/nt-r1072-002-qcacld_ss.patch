diff --git a/CORE/CLD_TXRX/TLSHIM/tl_shim.c b/CORE/CLD_TXRX/TLSHIM/tl_shim.c
index 9bc1e5b..73a9c52 100644
--- a/CORE/CLD_TXRX/TLSHIM/tl_shim.c
+++ b/CORE/CLD_TXRX/TLSHIM/tl_shim.c
@@ -1225,6 +1225,10 @@ void WLANTL_UnRegisterVdev(void *vos_ctx, u_int8_t vdev_id)
 #endif /* QCA_LL_TX_FLOW_CT */
 }
 
+#ifdef CONFIG_CONTX_USB_DEBUG
+extern int txkeeprun;
+#endif
+
 /**
  * tlshim_peer_validity() - determines whether peer is valid or not
  * @vos_ctx: vos context
@@ -1248,11 +1252,20 @@ void *tlshim_peer_validity(void *vos_ctx, uint8_t sta_id)
 		return NULL;
 	}
 
+#ifdef CONFIG_CONTX_USB_DEBUG
+	if (!txkeeprun) {
+		if (!tl_shim->sta_info[sta_id].registered) {
+			TLSHIM_LOGW("Staion is not yet registered for data service");
+			return NULL;
+		}
+	}
+#else
 	if (!tl_shim->sta_info[sta_id].registered) {
 		TLSHIM_LOGW("Staion is not yet registered for data service");
 		return NULL;
 	}
 
+#endif
 	peer = ol_txrx_peer_find_by_local_id(
 			((pVosContextType) vos_ctx)->pdev_txrx_ctx,
 			sta_id);
diff --git a/CORE/CLD_TXRX/TXRX/ol_tx_classify.c b/CORE/CLD_TXRX/TXRX/ol_tx_classify.c
index 7ae70b9..6713426 100644
--- a/CORE/CLD_TXRX/TXRX/ol_tx_classify.c
+++ b/CORE/CLD_TXRX/TXRX/ol_tx_classify.c
@@ -355,6 +355,9 @@ ol_tx_classify(
     if ((IEEE80211_IS_MULTICAST(dest_addr))
             || (vdev->opmode == wlan_op_mode_ocb)) {
         txq = &vdev->txqs[OL_TX_VDEV_MCAST_BCAST];
+        if (txq->flag == ol_tx_queue_paused) {
+            return NULL;
+        }
         tx_msdu_info->htt.info.ext_tid = HTT_TX_EXT_TID_NON_QOS_MCAST_BCAST;
         if (vdev->opmode == wlan_op_mode_sta) {
             /*
@@ -600,6 +603,9 @@ ol_tx_classify_mgmt(
          * STA: probe requests can be either broadcast or unicast
          */
         txq = &vdev->txqs[OL_TX_VDEV_DEFAULT_MGMT];
+        if (txq->flag == ol_tx_queue_paused) {
+            return NULL;
+        }
         tx_msdu_info->htt.info.peer_id = HTT_INVALID_PEER_ID;
         tx_msdu_info->peer = NULL;
         tx_msdu_info->htt.info.is_unicast = 0;
@@ -646,6 +652,9 @@ ol_tx_classify_mgmt(
         tx_msdu_info->peer = peer;
         if (!peer) {
             txq = &vdev->txqs[OL_TX_VDEV_DEFAULT_MGMT];
+            if (txq->flag == ol_tx_queue_paused) {
+                return NULL;
+            }
             tx_msdu_info->htt.info.peer_id = HTT_INVALID_PEER_ID;
         } else {
             txq = &peer->txqs[HTT_TX_EXT_TID_MGMT];
diff --git a/CORE/CLD_TXRX/TXRX/ol_tx_queue.c b/CORE/CLD_TXRX/TXRX/ol_tx_queue.c
index 23bc63c..1d88906 100644
--- a/CORE/CLD_TXRX/TXRX/ol_tx_queue.c
+++ b/CORE/CLD_TXRX/TXRX/ol_tx_queue.c
@@ -218,6 +218,11 @@ ol_tx_queue_discard(
     }
 }
 
+#if defined(CONFIG_CONTX_USB_DEBUG) && defined(DIRECT_AUDIO_SUPPORT)
+extern int txkeeprun;
+extern int txkeepruntoofastseriously;
+#endif
+
 void
 ol_tx_enqueue(
     struct ol_txrx_pdev_t *pdev,
@@ -240,6 +245,16 @@ ol_tx_enqueue(
      */
 #if defined(CONFIG_PER_VDEV_TX_DESC_POOL)
     vdev = tx_desc->vdev;
+#if defined(CONFIG_CONTX_USB_DEBUG) && defined(DIRECT_AUDIO_SUPPORT)
+    if (txkeeprun &&
+		(adf_os_atomic_read(&vdev->tx_desc_count) >
+          ((ol_tx_desc_pool_size_hl(pdev->ctrl_pdev) >> 1)
+		- TXRX_HL_TX_FLOW_CTRL_MGMT_RESERVED)
+		- OL_TX_DESC_POOL_SIZE_MIN_HL/2)){
+			txkeepruntoofastseriously = 1;
+			//pr_err("contx too at ol, slow down\n");
+    }
+#endif
     if (adf_os_atomic_read(&vdev->tx_desc_count) >
           ((ol_tx_desc_pool_size_hl(pdev->ctrl_pdev) >> 1)
            - TXRX_HL_TX_FLOW_CTRL_MGMT_RESERVED)) {
@@ -513,6 +528,41 @@ ol_txrx_throttle_pause(ol_txrx_pdev_handle pdev)
     ol_txrx_pdev_pause(pdev, OL_TXQ_PAUSE_REASON_THROTTLE);
 }
 
+#if defined(CONFIG_HL_SUPPORT)
+void
+ol_txrx_vdev_pause_txq(ol_txrx_vdev_handle vdev)
+{
+    struct ol_tx_frms_queue_t *txq;
+    int i;
+
+    for (i = 0; i < OL_TX_VDEV_NUM_QUEUES; i++) {
+        txq = &vdev->txqs[i];
+        if (txq->paused_count.total++ == 0) {
+            txq->flag = ol_tx_queue_paused;
+        }
+    }
+}
+
+void
+ol_txrx_vdev_unpause_txq(ol_txrx_vdev_handle vdev)
+{
+    struct ol_tx_frms_queue_t *txq;
+    int i;
+
+    for (i = 0; i < OL_TX_VDEV_NUM_QUEUES; i++) {
+        txq = &vdev->txqs[i];
+        if (--txq->paused_count.total == 0) {
+            if (txq->frms != 0) {
+                txq->flag = ol_tx_queue_active;
+            } else {
+                txq->flag = ol_tx_queue_empty;
+            }
+        }
+    }
+}
+#endif
+
+
 void
 ol_txrx_throttle_unpause(ol_txrx_pdev_handle pdev)
 {
@@ -1048,6 +1098,8 @@ ol_txrx_vdev_pause(ol_txrx_vdev_handle vdev, u_int32_t reason)
                 ol_txrx_peer_pause_base(pdev, peer);
             }
         }
+        if (reason == 0)
+            ol_txrx_vdev_pause_txq(vdev);
         adf_os_spin_unlock_bh(&pdev->tx_queue_spinlock);
         adf_os_spin_unlock_bh(&pdev->peer_ref_mutex);
 #endif /* defined(CONFIG_HL_SUPPORT) */
@@ -1079,7 +1131,7 @@ ol_txrx_vdev_unpause(ol_txrx_vdev_handle vdev, u_int32_t reason)
         /* take peer_ref_mutex before accessing peer_list */
         adf_os_spin_lock_bh(&pdev->peer_ref_mutex);
         adf_os_spin_lock_bh(&pdev->tx_queue_spinlock);
-        if (vdev->hl_paused_reason & reason) {
+        if ((vdev->hl_paused_reason & reason) || (reason == 0)) {
             vdev->hl_paused_reason &= ~reason;
 
             TAILQ_FOREACH(peer, &vdev->peer_list, peer_list_elem) {
@@ -1089,6 +1141,8 @@ ol_txrx_vdev_unpause(ol_txrx_vdev_handle vdev, u_int32_t reason)
                 }
             }
         }
+        if (reason == 0)
+            ol_txrx_vdev_unpause_txq(vdev);
         adf_os_spin_unlock_bh(&pdev->tx_queue_spinlock);
         adf_os_spin_unlock_bh(&pdev->peer_ref_mutex);
 #endif /* defined(CONFIG_HL_SUPPORT) */
diff --git a/CORE/CLD_TXRX/TXRX/ol_tx_sched.c b/CORE/CLD_TXRX/TXRX/ol_tx_sched.c
index 567729d..62ae3f9 100644
--- a/CORE/CLD_TXRX/TXRX/ol_tx_sched.c
+++ b/CORE/CLD_TXRX/TXRX/ol_tx_sched.c
@@ -717,6 +717,12 @@ ol_tx_sched_wrr_adv_credit_sanity_check(struct ol_txrx_pdev_t *pdev, u_int32_t c
  * The scheduler sync spinlock has been acquired outside this function,
  * so there is no need to worry about mutex within this function.
  */
+
+#ifdef CONFIG_CONTX_USB_DEBUG
+extern int txkeeprun;
+extern int txkeepruntoofast;
+#endif
+
 static int
 ol_tx_sched_select_batch_wrr_adv(
     struct ol_txrx_pdev_t *pdev,
@@ -772,6 +778,11 @@ ol_tx_sched_select_batch_wrr_adv(
          * service this category after all).
          */
         category->state.wrr_count = category->state.wrr_count - 1;
+#ifdef CONFIG_CONTX_USB_DEBUG
+        if (txkeeprun && category->state.frms > 500) {
+                txkeepruntoofast = 1;
+        }
+#endif
         return 0;
     }
     /* enough credit is available - go ahead and send some frames */
@@ -846,9 +857,14 @@ ol_tx_sched_select_batch_wrr_adv(
         TX_SCHED_DEBUG_PRINT("Leave %s\n", __func__);
     } else {
         used_credits = 0;
+#ifdef CONFIG_CONTX_USB_DEBUG
+        if (!txkeeprun)
+            TX_SCHED_DEBUG_PRINT("ol_tx_sched_select_batch_wrr_adv: error, no TXQ can be popped.");
+#else
         /* TODO: find its reason */
         VOS_TRACE(VOS_MODULE_ID_TXRX, VOS_TRACE_LEVEL_ERROR,
              "ol_tx_sched_select_batch_wrr_adv: error, no TXQ can be popped.");
+#endif
     }
     return used_credits;
 }
diff --git a/CORE/CLD_TXRX/TXRX/ol_txrx.c b/CORE/CLD_TXRX/TXRX/ol_txrx.c
index 76ba631..7a0009a 100644
--- a/CORE/CLD_TXRX/TXRX/ol_txrx.c
+++ b/CORE/CLD_TXRX/TXRX/ol_txrx.c
@@ -1919,6 +1919,21 @@ ol_txrx_get_tx_pending(ol_txrx_pdev_handle pdev_handle)
     return (total - pdev->tx_desc.num_free);
 }
 
+#if defined(CONFIG_HL_SUPPORT)
+int
+ol_txrx_get_tx_pending_hl(ol_txrx_pdev_handle pdev_handle)
+{
+    struct ol_txrx_pdev_t *pdev = (ol_txrx_pdev_handle)pdev_handle;
+    int total;
+
+    total = ol_tx_desc_pool_size_hl(pdev->ctrl_pdev);
+
+    return (total - pdev->tx_desc.num_free);
+}
+#endif
+
+
+
 /*
  * ol_txrx_get_queue_status() - get vdev tx ll queues status
  * pdev_handle: pdev handle
diff --git a/CORE/HDD/inc/qc_sap_ioctl.h b/CORE/HDD/inc/qc_sap_ioctl.h
index 1e52ac9..4eb930b 100644
--- a/CORE/HDD/inc/qc_sap_ioctl.h
+++ b/CORE/HDD/inc/qc_sap_ioctl.h
@@ -268,6 +268,9 @@ enum {
     QCASAP_PARAM_RX_STBC,
     QCASAP_SET_RADAR_DBG,
     QCSAP_PARAM_CHAN_WIDTH,
+    QCSAP_DBGLOG_FWLOG_FILE_ENABLE,
+    QCSAP_DBGLOG_FWLOG_FILE_MAX_SIZE,
+    QCSAP_DIRECT_AUDIO_TEST,
 };
 
 int iw_get_channel_list(struct net_device *dev,
diff --git a/CORE/HDD/inc/wlan_hdd_cfg80211.h b/CORE/HDD/inc/wlan_hdd_cfg80211.h
index 6fc13ed..df60f0e 100644
--- a/CORE/HDD/inc/wlan_hdd_cfg80211.h
+++ b/CORE/HDD/inc/wlan_hdd_cfg80211.h
@@ -2017,6 +2017,7 @@ void wlan_hdd_testmode_rx_event(void *buf, size_t buf_len);
 void hdd_suspend_wlan(void (*callback)(void *callbackContext, boolean suspended),
                       void *callbackContext);
 void hdd_resume_wlan(void);
+int real_wlan_hdd_cfg80211_resume_wlan(void);
 
 #if defined(FEATURE_WLAN_CH_AVOID) || defined(FEATURE_WLAN_FORCE_SAP_SCC)
 int wlan_hdd_send_avoid_freq_event(hdd_context_t *pHddCtx,
diff --git a/CORE/HDD/inc/wlan_hdd_direct_audio.h b/CORE/HDD/inc/wlan_hdd_direct_audio.h
new file mode 100644
index 0000000..a2ea049
--- /dev/null
+++ b/CORE/HDD/inc/wlan_hdd_direct_audio.h
@@ -0,0 +1,161 @@
+#ifdef DIRECT_AUDIO_SUPPORT
+#ifndef SDA_H
+#define SDA_H
+
+/* direct audio prototype */
+
+typedef struct SDA_Descriptor
+{
+	unsigned char m_ReadyToCopy;
+	unsigned int m_PayloadSize;
+	unsigned int m_TimeStamp;
+}__attribute__((packed)) SDA_Descriptor_t;
+
+
+typedef struct SDA_HeadRoom
+{
+	unsigned char m_DestAddress[6];
+	unsigned char m_SourceAddress[6];
+	unsigned short m_PacketType;
+}__attribute__((packed)) SDA_HeadRoom_t;
+
+
+typedef struct
+{
+	SDA_Descriptor_t   m_Descriptor;
+	unsigned char m_Dummy[50 - sizeof(struct SDA_HeadRoom)];
+	SDA_HeadRoom_t  m_Headroom;
+}__attribute__((packed)) SDA_Header_t;
+
+
+
+/**
+ * @brief Retrieve the time stamp value from the p2p0 or wlan0 interface
+ * @remarks
+ * @param vif_id : get time stamp from wlan0/p2p0(0/1)interface
+ * @return time stamp value (64bits)
+ * @see
+ */
+unsigned long long SDA_getTsf (unsigned char vif_id);
+
+
+
+
+/**
+ * @brief Synchronize p2p0s time stamp value with wlan0s
+ * @remarks
+ * @param none
+ * @return 0 : success, - 1 : fail
+ * @see
+ */
+int SDA_syncTsf (void);
+
+
+
+/**
+ * @brief tsf wifi module
+ * @remarks
+ * @param pTsf : tsf
+ * @return none
+ * @see
+ */
+void SDA_GetTSF(unsigned int *pTsf);
+
+
+
+
+/**
+ * @brief send the buffer info to wifi module for tx.
+ * @remarks
+ * @param BufferId is the mazimum 5.
+ * @param pBufferTotal : buffer address
+ * @param BufferTotalSize : buffer size
+ * @param BufferUnitSize : each unit size (descriptor + headroom + audio data size)
+ * @param HeadroomSize : head room size
+ * @return none
+ * @see
+ */
+void SDA_setSharedMemory4Send(unsigned int BufferId, unsigned char *pBufferTotal, unsigned int BufferTotalSize, unsigned int BufferUnitSize, unsigned int HeadroomSize);
+
+
+
+
+
+/**
+ * @brief send the buffer info to wifi module for rx.
+ * @remarks
+ * @param pBufferTotal : buffer address
+ * @param BufferTotalSize : buffer size
+ * @param BufferUnitSize : each unit size (descriptor + headroom + audio data size)
+ * @param HeadroomSize : head room size
+ * @return none
+ * @see
+ */
+void SDA_setSharedMemory4Recv(unsigned char *pBufferTotal, unsigned int BufferTotalSize, unsigned int BufferUnitSize, unsigned int HeadroomSize);
+
+
+
+
+
+
+/*
+ * @send the brief data data to wifi module (dsp --> wifi module)
+ * @remarks
+ * @param on BufferId direct audio system, the maximum of audio input buffer is 5. bufferÀÇ idÀÓ.
+ * @param pBuffer : buffer address
+ * @param BufferSize : buffer size
+ * @return none
+ * @see
+ */
+void SDA_function4Send(unsigned int BufferId, unsigned char *pBuffer, unsigned int BufferSize);
+
+
+
+
+/**
+ * @brief after sending data on wifi module, call the callback(ack) (wifi module --> dsp)
+ * @remarks
+ * @param on BufferId direct audio system, the maximum of audio input buffer is 5.
+ * @param pBuffer : buffer address
+ * @param BufferSize : buffer size
+ * @return none
+ * @see
+ */
+typedef void (*SDA_SendDoneCallBack)(unsigned int BufferId, unsigned char *pBuffer, unsigned int BufferSize);
+
+void SDA_registerCallback4SendDone(SDA_SendDoneCallBack pCallback);
+
+
+
+
+
+
+
+/**
+ * @brief on wifi module, send the receiving data to soc (wifi module --> dsp)
+ * @remarks
+ * @param pBuffer : buffer address
+ * @param BufferSize : buffer size
+ * @return none
+ * @see
+ */
+typedef void (*SDA_RecvCallBack)(unsigned char *pBuffer, unsigned int BufferSize);
+
+void SDA_registerCallback4Recv(SDA_RecvCallBack pCallback);
+
+
+
+
+
+/**
+ * @brief after finishing to received data on soc, notifying to wifi module(ack)
+ * @remarks
+ * @param pBuffer : buffer address
+ * @param BufferSize : buffer size
+ * @return none
+ * @see
+ */
+void SDA_function4RecvDone(unsigned char *pBuffer, unsigned int BufferSize);
+
+#endif // SDA_H
+#endif //DIRECT_AUDIO_SUPPORT
diff --git a/CORE/HDD/inc/wlan_hdd_main.h b/CORE/HDD/inc/wlan_hdd_main.h
index e5cdec4..9b5b0f1 100644
--- a/CORE/HDD/inc/wlan_hdd_main.h
+++ b/CORE/HDD/inc/wlan_hdd_main.h
@@ -645,6 +645,9 @@ typedef struct hdd_remain_on_chan_ctx
   vos_timer_t hdd_remain_on_chan_timer;
   action_pkt_buffer_t action_pkt_buff;
   v_BOOL_t hdd_remain_on_chan_cancel_in_progress;
+#ifdef CONFIG_CUST_PLATFORM
+  hdd_adapter_t *pAdapter;
+#endif
 }hdd_remain_on_chan_ctx_t;
 
 /* RoC Request entry */
@@ -1209,6 +1212,12 @@ struct hdd_adapter_s
     /* Time stamp for start RoC request */
     v_TIME_t startRocTs;
 
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+#ifdef CONFIG_CUST_PLATFORM
+    struct work_struct ext_wow_work;
+#endif
+#endif
+
     /* State for synchronous OCB requests to WMI */
     struct sir_ocb_set_config_response ocb_set_config_resp;
     struct sir_ocb_get_tsf_timer_response ocb_get_tsf_timer_resp;
@@ -1356,6 +1365,10 @@ typedef struct
     v_U8_t dl_loglevel;
     v_U8_t index;
     v_U32_t dl_mod_loglevel[MAX_MOD_LOGLEVEL];
+#ifdef CONFIG_WLAN_FWLOG_FILE
+    v_U8_t dl_fwlog_file;
+    v_U32_t dl_fwlog_file_max_size;
+#endif
 
 }fw_log_info;
 
@@ -1752,6 +1765,12 @@ struct hdd_context_s
     v_BOOL_t is_extwow_app_type2_param_set;
     v_BOOL_t ext_wow_should_suspend;
     struct completion ready_to_extwow;
+    tSirAppType1Params app_type1_params;
+    tSirAppType2Params app_type2_params;
+#ifdef CONFIG_CUST_PLATFORM
+    v_BOOL_t ext_wow_enable;
+#endif
+   struct mutex ext_wow_lock;
 #endif
 
     /* Time since boot up to extscan start (in micro seconds) */
@@ -2239,4 +2258,10 @@ int hdd_reassoc(hdd_adapter_t *pAdapter, const tANI_U8 *bssid,
 void hdd_sap_restart_handle(struct work_struct *work);
 
 void hdd_set_rps_cpu_mask(hdd_context_t *hdd_ctx);
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+#ifdef CONFIG_CUST_PLATFORM
+int wlan_hdd_enable_swol(hdd_adapter_t *pAdapter, boolean enable);
+#endif
+#endif
+
 #endif    // end #if !defined( WLAN_HDD_MAIN_H )
diff --git a/CORE/HDD/src/wlan_hdd_assoc.c b/CORE/HDD/src/wlan_hdd_assoc.c
index d71149c..54113f1 100644
--- a/CORE/HDD/src/wlan_hdd_assoc.c
+++ b/CORE/HDD/src/wlan_hdd_assoc.c
@@ -1071,6 +1071,15 @@ static eHalStatus hdd_DisConnectHandler( hdd_adapter_t *pAdapter, tCsrRoamInfo *
             }
 #endif
 
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+#ifdef CONFIG_CUST_PLATFORM
+            if (pAdapter->device_mode == WLAN_HDD_INFRA_STATION)
+            {
+                wlan_hdd_enable_swol(pAdapter, FALSE);
+            }
+#endif
+#endif
+
             //If the Device Mode is Station
             // and the P2P Client is Connected
             //Enable BMPS
@@ -1933,6 +1942,14 @@ static eHalStatus hdd_AssociationCompletionHandler( hdd_adapter_t *pAdapter, tCs
                                        pFTAssocRsp, assocRsplen,
                                        WLAN_STATUS_SUCCESS,
                                        GFP_KERNEL);
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+#ifdef CONFIG_CUST_PLATFORM
+                    if (pAdapter->device_mode == WLAN_HDD_INFRA_STATION)
+                    {
+                        wlan_hdd_enable_swol(pAdapter, TRUE);
+                    }
+#endif
+#endif
                 }
             }
             else
@@ -1968,6 +1985,15 @@ static eHalStatus hdd_AssociationCompletionHandler( hdd_adapter_t *pAdapter, tCs
                                 rspRsnIe, rspRsnLength,
                                 WLAN_STATUS_SUCCESS,
                                 GFP_KERNEL);
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+#ifdef CONFIG_CUST_PLATFORM
+                       if (pAdapter->device_mode == WLAN_HDD_INFRA_STATION)
+                       {
+                           wlan_hdd_enable_swol(pAdapter, TRUE);
+                       }
+#endif
+#endif
+
                     }
                 }
             }
diff --git a/CORE/HDD/src/wlan_hdd_cfg.c b/CORE/HDD/src/wlan_hdd_cfg.c
index 3c1e918..c2caf01 100644
--- a/CORE/HDD/src/wlan_hdd_cfg.c
+++ b/CORE/HDD/src/wlan_hdd_cfg.c
@@ -5677,6 +5677,12 @@ VOS_STATUS hdd_update_mac_config(hdd_context_t *pHddCtx)
    VOS_STATUS vos_status = VOS_STATUS_SUCCESS;
 
    memset(macTable, 0, sizeof(macTable));
+
+#ifdef CONFIG_CUST_PLATFORM
+//There is no such file existing in CUST_PLATFORM, return directly to save time
+   return VOS_STATUS_E_FAILURE;
+#endif
+
    status = request_firmware(&fw, WLAN_MAC_FILE, pHddCtx->parent_dev);
 
    if (status)
diff --git a/CORE/HDD/src/wlan_hdd_cfg80211.c b/CORE/HDD/src/wlan_hdd_cfg80211.c
index 0e7794f..08c41c3 100644
--- a/CORE/HDD/src/wlan_hdd_cfg80211.c
+++ b/CORE/HDD/src/wlan_hdd_cfg80211.c
@@ -17375,6 +17375,12 @@ int __wlan_hdd_cfg80211_scan( struct wiphy *wiphy,
         return -EBUSY;
     }
 
+    if (TRUE == pHddCtx->hdd_wlan_suspended)
+    {
+        hddLog(VOS_TRACE_LEVEL_ERROR, "%s: wlan suspend is TRUE", __func__);
+        return -EBUSY;
+    }
+
     //Don't Allow Scan and return busy if Remain On
     //Channel and action frame is pending
     //Otherwise Cancel Remain On Channel and allow Scan
@@ -20676,8 +20682,13 @@ static int __wlan_hdd_cfg80211_get_station(struct wiphy *wiphy,
     }
 
     if (rssi_stats_valid) {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 0, 0))
         sinfo->filled |= STATION_INFO_CHAIN_SIGNAL_AVG;
         sinfo->filled |= STATION_INFO_SIGNAL_AVG;
+#else
+        sinfo->filled |= BIT(NL80211_STA_INFO_CHAIN_SIGNAL_AVG);
+        sinfo->filled |= BIT(NL80211_STA_INFO_CHAIN_SIGNAL);
+#endif
     }
 #endif
 
@@ -23726,10 +23737,22 @@ void wlan_hdd_cfg80211_ready_to_suspend(void *callbackContext, boolean suspended
 
 int wlan_hdd_cfg80211_resume_wlan(struct wiphy *wiphy)
 {
+    printk("wlan:%s %d do nothing\n", __func__, __LINE__);
+
+    return 0;
+}
+
+int real_wlan_hdd_cfg80211_resume_wlan(void)
+{
     int ret;
+    VosContextType *pVosContext;
+    hdd_context_t* pHddCtx;
+
+    pVosContext = vos_get_global_context(VOS_MODULE_ID_SYS, NULL);
+    pHddCtx = ((VosContextType*)(pVosContext))->pHDDContext;
 
     vos_ssr_protect(__func__);
-    ret = __wlan_hdd_cfg80211_resume_wlan(wiphy);
+    ret = __wlan_hdd_cfg80211_resume_wlan(pHddCtx->wiphy);
     vos_ssr_unprotect(__func__);
 
     return ret;
@@ -23802,6 +23825,7 @@ int __wlan_hdd_cfg80211_suspend_wlan(struct wiphy *wiphy,
     }
 
     /* Stop ongoing scan on each interface */
+    printk(KERN_ERR "cfg80211 suspend wlan\n");
     status =  hdd_get_front_adapter ( pHddCtx, &pAdapterNode );
     while ( NULL != pAdapterNode && VOS_STATUS_SUCCESS == status )
     {
@@ -23816,6 +23840,7 @@ int __wlan_hdd_cfg80211_suspend_wlan(struct wiphy *wiphy,
         if (pScanInfo->mScanPending && pAdapter->request)
         {
            INIT_COMPLETION(pScanInfo->abortscan_event_var);
+           printk(KERN_ERR "cfg80211 abort wlanscan\n");
            hdd_abort_mac_scan(pHddCtx, pAdapter->sessionId,
                               eCSR_SCAN_ABORT_DEFAULT);
 
diff --git a/CORE/HDD/src/wlan_hdd_direct_audio.c b/CORE/HDD/src/wlan_hdd_direct_audio.c
new file mode 100644
index 0000000..69c3636
--- /dev/null
+++ b/CORE/HDD/src/wlan_hdd_direct_audio.c
@@ -0,0 +1,828 @@
+#include <linux/etherdevice.h>
+#include <linux/firmware.h>
+#include <net/addrconf.h>
+#include <linux/wireless.h>
+#include <net/cfg80211.h>
+#include <linux/inetdevice.h>
+#include <net/addrconf.h>
+#include <wcnss_api.h>
+#include <wlan_hdd_tx_rx.h>
+#include <wlan_hdd_includes.h>
+#include <wlan_hdd_softap_tx_rx.h>
+#include <wniApi.h>
+#include <vos_api.h>
+#include <vos_sched.h>
+#include <wlan_nlink_srv.h>
+#include <wlan_btc_svc.h>
+#include <wlan_hdd_cfg.h>
+#include <wlan_ptt_sock_svc.h>
+#include <dbglog_host.h>
+#include <wlan_logging_sock_svc.h>
+#include <wlan_hdd_wowl.h>
+#include <wlan_hdd_misc.h>
+#include <wlan_hdd_wext.h>
+#include "wlan_hdd_trace.h"
+#include "vos_types.h"
+#include "vos_trace.h"
+#include <wlan_hdd_direct_audio.h>
+#include <wma_api.h>
+#include "ol_if_athvar.h"
+#include "hif.h"
+#if defined(HIF_PCI)
+#include "if_pci.h"
+#elif defined(HIF_USB)
+#include "if_usb.h"
+#elif defined(HIF_SDIO)
+#include "if_ath_sdio.h"
+#endif
+
+
+#ifdef DIRECT_AUDIO_SUPPORT
+#define SDA_DEBUG	1
+#define TSFDATASIZE	4
+
+#define DIRECT_AUDIO_LLC_TYPE 0x43FF
+#if SDA_DEBUG
+#define MAX_BUF_SIZE 1500 // bytes
+#define MAX_SHARE_MEM_ITEM	32
+#endif
+#define MAX_TX_POOL_ID 5
+
+
+
+/*
+ * For the Samsung USB_BUS continue TX/RX pressure test.
+ * Host sends packets to FW, and FW checks each packet's
+ * sequence number with the new coming one whether there is
+ * sequence number error, or some other errors.
+ * The sequence number, error count, total packes are all recorded in Fixed Addresses.
+ * For the Fixed Addresses, we choose the "(TOP_STACK) + 16".
+ * This feature only will be needed at SS pressure test stage,
+ * otherwise it will be DISABLE.
+*/
+#ifdef CONFIG_CONTX_USB_DEBUG
+#define CONTX_USB_ADDR_USE_STACK    (0x40aa88 + 16)
+A_UINT32 audio_debug_seq_addr = (CONTX_USB_ADDR_USE_STACK + 0);
+A_UINT32 seq_error_addr       = (CONTX_USB_ADDR_USE_STACK + 4);
+A_UINT32 content_error_addr   = (CONTX_USB_ADDR_USE_STACK + 8);
+A_UINT32 totalcount_addr      = (CONTX_USB_ADDR_USE_STACK + 12);
+#endif
+
+
+
+struct Direct_Audio_Context {
+	u32		last_tx_process_time;
+	u32		max_tx_process_time;
+	u32		last_rx_process_time;
+	u32		max_rx_process_time;
+	hdd_context_t *pHddCtx;
+	u8		vif_id;
+};
+
+static struct Direct_Audio_Context	DA_context;
+SDA_SendDoneCallBack SDA_TX_DONE_CB = NULL;
+SDA_RecvCallBack SDA_RX_READY_CB = NULL;
+
+struct Direct_Audio_Setting_str {
+    u8  *pAddr;
+	u32 sizeTotal;
+	u32 lenUnit;
+	u32 lenHeadroom;
+	u8  *current_pAddr;
+}__packed;
+
+static struct Direct_Audio_Setting_str global_TX_DA_Setting[MAX_TX_POOL_ID];
+static struct Direct_Audio_Setting_str global_RX_DA_Setting;
+
+#define TX_DA_INIT_ADDR(id)   global_TX_DA_Setting[id].pAddr
+#define TX_DA_ADDR(id)        global_TX_DA_Setting[id].current_pAddr
+#define TX_DA_POOL_SIZE(id)   global_TX_DA_Setting[id].sizeTotal
+#define TX_DA_UNIT_LEN(id)    global_TX_DA_Setting[id].lenUnit
+#define TX_DA_HEAD_ROOM(id)   global_TX_DA_Setting[id].lenHeadroom
+
+static void Direct_Audio_Tx_Setting(u32 BufferId,
+                                    u8 *pAddr,
+                                    u32 sizeTotal,
+                                    u16 lenUnit,
+                                    u16 lenHeadroom)
+{
+	if(BufferId >= MAX_TX_POOL_ID)
+	{
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+			"%s: BufferId %d excess MAX_TX_POOL_ID %d\n",
+                          __func__,
+                          BufferId,
+                          MAX_TX_POOL_ID);
+		return;
+	}
+	TX_DA_INIT_ADDR(BufferId) = pAddr;
+	TX_DA_ADDR(BufferId) = pAddr;
+	TX_DA_POOL_SIZE(BufferId) = sizeTotal;
+	TX_DA_UNIT_LEN(BufferId) = lenUnit;
+	TX_DA_HEAD_ROOM(BufferId) = lenHeadroom;
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+		"%s[%d]BufferId=%d,pAddr=0%p,sizeTotal=%d,lenUnit=%d,lenHeadroom=%d\r\n",
+	        __func__, __LINE__, BufferId, pAddr, sizeTotal, lenUnit, lenHeadroom);
+}
+
+#define RX_DA_INIT_ADDR   global_RX_DA_Setting.pAddr
+#define RX_DA_ADDR        global_RX_DA_Setting.current_pAddr
+#define RX_DA_POOL_SIZE   global_RX_DA_Setting.sizeTotal
+#define RX_DA_UNIT_LEN    global_RX_DA_Setting.lenUnit
+#define RX_DA_HEAD_ROOM   global_RX_DA_Setting.lenHeadroom
+
+static void Direct_Audio_Rx_Setting(u8 *pAddr, u32 sizeTotal, u32 lenUnit, u32 lenHeadroom)
+{
+	RX_DA_INIT_ADDR = pAddr;
+	RX_DA_ADDR = pAddr;
+	RX_DA_POOL_SIZE = sizeTotal;
+	RX_DA_UNIT_LEN = lenUnit;
+	RX_DA_HEAD_ROOM = lenHeadroom;
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+		"%s[%d] pAddr=0%p,sizeTotal=%d,lenUnit=%d,lenHeadroom=%d\r\n",
+	    __func__, __LINE__, pAddr, sizeTotal, lenUnit, lenHeadroom);
+}
+
+//SDA_SendDoneCallBack  SDA_TX_DONE_CB = NULL;
+#define SDA_BUF_READY(_desc)      	!!_desc->m_ReadyToCopy
+#define TX_SDA_INIT_ADDR			orig_data_p
+#define TX_SDA_ADDR 				descp_p
+#define TX_SDA_POOL_SIZE			BufferSize
+#define TX_SDA_UNIT_LEN(id)				TX_DA_UNIT_LEN(id)
+#define CLR_SDA_BUF_READY(_desc)  	_desc->m_ReadyToCopy = 0
+#define SET_SDA_BUF_READY(_desc)  	_desc->m_ReadyToCopy = 1
+static void SDA_Tx_fun( struct net_device *dev, u32 BufferId, u8 *pBuffer, u32 BufferSize)
+{
+	u8 *orig_data_p = pBuffer;
+	u8 *data_p = pBuffer;
+	u8 *descp_p = pBuffer;
+	struct SDA_Descriptor *tx_desc = (struct SDA_Descriptor *) data_p;
+	hdd_adapter_t * vif;
+	int status = 0;
+	vif = hdd_get_adapter_by_vdev(DA_context.pHddCtx, DA_context.vif_id);
+	if(!vif)
+		return;
+
+	if(BufferId >= MAX_TX_POOL_ID)
+	{
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_WARN,
+			"%s: BufferId excess %d\n", __func__, MAX_TX_POOL_ID);
+		goto tx_fail;
+	}
+	if (!data_p || !SDA_BUF_READY(tx_desc)) {
+		//Should not into here
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_WARN,
+			"%s: descriptor show not ready\n", __func__);
+		goto tx_fail;
+	}
+	/*Check descriptor*/
+	do {
+		struct sk_buff *skb;
+		int send_len = 0;
+		struct ethhdr *eth_hdr;
+		int alloc_size = 0;
+
+		/* point to RAW_Data
+		* Assume offset include Descriptor & Headroom
+		*/
+		data_p += sizeof(SDA_Header_t);
+		/*Create skb, copy data, fill skb header*/
+		alloc_size = tx_desc->m_PayloadSize+sizeof(struct ethhdr);
+		skb = adf_nbuf_alloc(NULL, alloc_size, 0, sizeof(u_int32_t), 0);
+		if (skb == NULL) {
+			//should not happened
+			VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+				"%s: Allocate skb failed\n", __func__);
+			break;
+		}
+
+		skb_put(skb, alloc_size);
+		memset(skb->data, 0, alloc_size);
+		//Copy data from share buf to skb
+		memcpy(skb->data, data_p-sizeof(struct ethhdr),
+                       tx_desc->m_PayloadSize+sizeof(struct ethhdr));
+		send_len += tx_desc->m_PayloadSize+sizeof(struct ethhdr);
+
+		eth_hdr = (struct ethhdr *)(skb->data);
+
+		//copy mac address as source address
+		memcpy(eth_hdr->h_source,vif->dev->dev_addr,6);
+#if 0 //dest mac is filled by upper layer like virutal sound card
+		if (vif->device_mode == WLAN_HDD_INFRA_STATION || vif->device_mode == WLAN_HDD_P2P_CLIENT)
+		{
+			hdd_station_ctx_t *pHddStaCtx = WLAN_HDD_GET_STATION_CTX_PTR(vif);
+			memcpy(eth_hdr->h_dest, pHddStaCtx->conn_info.bssId, 6);
+		}
+		else
+		{
+			u8 broadcastpeer[6] = {0xff,0xff,0xff,0xff,0xff,0xff};
+			memcpy(eth_hdr->h_dest, broadcastpeer, 6);
+		}
+#endif
+		skb->protocol = ntohs(eth_hdr->h_proto);
+		skb->dev = dev;
+		skb->priority = SME_QOS_WMM_UP_VI;
+		skb->queue_mapping = hddLinuxUpToAcMap[skb->priority];
+
+		/*Adjust the length of data before send*/
+		skb_trim(skb, send_len);
+		//Call normal tx path
+		if (vif->device_mode == WLAN_HDD_INFRA_STATION ||
+                    vif->device_mode == WLAN_HDD_P2P_CLIENT)
+			status = hdd_hard_start_xmit(skb, dev);
+		else if (vif->device_mode == WLAN_HDD_SOFTAP ||
+                         vif->device_mode == WLAN_HDD_P2P_GO)
+			status = hdd_softap_hard_start_xmit(skb, dev);
+		else
+			status = hdd_softap_hard_start_xmit(skb, dev);
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_LOW,
+			"%s[%d]BufferId=%d,audio len = %d,status = %d by %d\n",
+		        __func__, __LINE__, BufferId,
+                          tx_desc->m_PayloadSize,
+                          status,
+                          (vif->device_mode));
+		//Clear share buffer Ready flag
+		CLR_SDA_BUF_READY(tx_desc);
+		//To-do: call SS complete routine
+
+		//Next frame & check if need retrun pAddr of DA Share buff
+		if(((TX_SDA_ADDR - TX_SDA_INIT_ADDR)+TX_SDA_UNIT_LEN(BufferId)) >= TX_SDA_POOL_SIZE)
+                {
+			/*Return to Init buf addr*/
+			TX_SDA_ADDR = TX_SDA_INIT_ADDR;
+		} else {
+			/*Go to Next buf*/
+			TX_SDA_ADDR += TX_SDA_UNIT_LEN(BufferId);
+		}
+		data_p = TX_SDA_ADDR;
+		tx_desc = (struct SDA_Descriptor *) data_p;
+	} while(SDA_BUF_READY(tx_desc));//Check if having next
+tx_fail:
+	if (SDA_TX_DONE_CB)
+		SDA_TX_DONE_CB(BufferId,pBuffer,BufferSize);
+}
+
+/*Assume The RX Already to be Packet Mode*/
+void SDA_Rx_fun( struct net_device *dev, struct sk_buff *skb)
+{
+#if (!defined FILE_DEBUG) && (!defined UDPDBG) //call real DA engine
+    u32 tsf_ie=0, tsf_data=0;
+    u8 *data_p = RX_DA_ADDR;
+    struct SDA_Descriptor *rx_desc = (struct SDA_Descriptor *) data_p;
+
+    if (skb == NULL) {
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
+			"%s: input buf should not be NULL\n", __func__);
+		return;
+	}
+#define TSF_IE 0x1234fedc
+	tsf_ie = le32_to_cpu(*((u32 *)(skb->data + skb->len - 2*sizeof(u32))));
+	if (tsf_ie == TSF_IE) {
+		skb_trim(skb, (skb->len - 2*sizeof(u32)));
+
+		tsf_data = le32_to_cpu(*((u32 *)(skb->data + skb->len + sizeof(u32))));
+		//printk("~~current-tsf (%x) \n",tsf_data);
+	}
+
+	if (!data_p) {
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+			"%s: DSP dose not register rx pool\n", __func__);
+		dev_kfree_skb(skb);
+		return;
+	}
+
+	if(SDA_BUF_READY(rx_desc)) {
+	   //the share buf not available. DO NOT PUT PRINT LOG HERE.
+	   goto rx_fail;
+	}
+
+	//Fill derscriptort
+	rx_desc->m_PayloadSize = skb->len;//no ethernet header included and remove TSF_IE
+	rx_desc->m_TimeStamp = 0 ;
+
+	if (skb->len > (RX_DA_UNIT_LEN-sizeof(struct SDA_Descriptor)-RX_DA_HEAD_ROOM)) {
+	    //Should not happen
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+			"%s: Not having enough room for RX DATA\n", __func__);
+		skb->len = RX_DA_UNIT_LEN-sizeof(struct SDA_Descriptor)-RX_DA_HEAD_ROOM;
+	}
+	//copy to share buf & Skip the length of "struct ethhdr"
+	memcpy((data_p + sizeof(struct SDA_Descriptor) + RX_DA_HEAD_ROOM) - sizeof(struct ethhdr),
+		skb->data -sizeof(struct ethhdr),
+		skb->len + sizeof(struct ethhdr));
+
+	// Set rx timestamp
+	memcpy(data_p + sizeof(struct SDA_Descriptor) + RX_DA_HEAD_ROOM +sizeof(u32),
+			&tsf_data, sizeof(u32));
+
+	//To-do: :Call SS Direct Audio RX routine
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+		"%s[%d]audio len=%d\n\r",__func__,__LINE__,rx_desc->m_PayloadSize);
+
+	SET_SDA_BUF_READY(rx_desc);
+	if (SDA_RX_READY_CB)
+		SDA_RX_READY_CB((u8*)rx_desc,RX_DA_UNIT_LEN);
+
+	//Next DA Share buff
+	if(((RX_DA_ADDR - RX_DA_INIT_ADDR)+RX_DA_UNIT_LEN) >= RX_DA_POOL_SIZE ) {
+	    /*Return to Init buf addr*/
+	    RX_DA_ADDR = RX_DA_INIT_ADDR;
+	} else {
+	    /*Go to Next buf*/
+	    RX_DA_ADDR += RX_DA_UNIT_LEN;
+	}
+rx_fail:
+	dev_kfree_skb(skb);
+#endif
+}
+
+#ifdef CONFIG_CONTX_USB_DEBUG
+extern struct timer_list da_timer;
+extern int txkeeprun;
+#endif /* CONFIG_CONTX_USB_DEBUG */
+
+void SDA_function4Send(unsigned int BufferId, unsigned char *pBuffer, unsigned int BufferSize)
+{
+	hdd_adapter_t * vif;
+	hdd_station_ctx_t *pHddStaCtx;
+	hdd_ap_ctx_t *pAPCtx;
+
+	u32	entry_time;
+	if (DA_context.pHddCtx == NULL) {
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_WARN,
+			"%s: DA_context.ar should not be NULL\n", __func__);
+		return;
+	}
+
+	vif = hdd_get_adapter_by_vdev(DA_context.pHddCtx, DA_context.vif_id);
+	if (!vif) {
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_WARN,
+			"%s: Failed to find vif for DA, DA_context.ar=%p, DA_context.vif_id=%d\n"
+			, __func__,
+			DA_context.pHddCtx,
+			DA_context.vif_id);
+		return;
+	}
+	if (vif->device_mode == WLAN_HDD_INFRA_STATION || vif->device_mode == WLAN_HDD_P2P_CLIENT) {
+		pHddStaCtx = WLAN_HDD_GET_STATION_CTX_PTR(vif);
+#ifdef CONFIG_CONTX_USB_DEBUG
+		if (!pHddStaCtx || (!hdd_connIsConnected(pHddStaCtx) && !txkeeprun)) {
+			VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+				"%s: STA %p is not connected\n", __func__, pHddStaCtx);
+			return;
+		}
+#else
+		if (!pHddStaCtx || !hdd_connIsConnected(pHddStaCtx)) {
+			VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+				"%s: STA %p is not connected\n", __func__, pHddStaCtx);
+			return;
+		}
+#endif
+	}
+	if (vif->device_mode == WLAN_HDD_SOFTAP || vif->device_mode == WLAN_HDD_P2P_GO) {
+		pAPCtx = WLAN_HDD_GET_AP_CTX_PTR(vif);
+	}
+	entry_time = jiffies;
+	SDA_Tx_fun(vif->dev,BufferId,pBuffer,BufferSize);
+	DA_context.last_tx_process_time = jiffies - entry_time;
+
+	if (DA_context.max_tx_process_time < DA_context.last_tx_process_time)
+		DA_context.max_tx_process_time = DA_context.last_tx_process_time;
+}
+EXPORT_SYMBOL(SDA_function4Send);
+
+void SDA_function4RecvDone(unsigned char *pBuffer, unsigned int BufferSize)
+{
+	//what should we do in this API
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+		"%s[%d]pBuffer=0x%p,BufferSize=%d\n\r",__func__,__LINE__,pBuffer,BufferSize);
+}
+EXPORT_SYMBOL(SDA_function4RecvDone);
+
+void SDA_setSharedMemory4Send(unsigned int BufferId,
+                                  unsigned char *pBufferTotal,
+                                  unsigned int BufferTotalSize,
+                                  unsigned int BufferUnitSize,
+                                  unsigned int HeadroomSize)
+{
+	Direct_Audio_Tx_Setting(BufferId,
+                                pBufferTotal,
+                                BufferTotalSize,
+                                BufferUnitSize,
+                                HeadroomSize);
+}
+EXPORT_SYMBOL(SDA_setSharedMemory4Send);
+
+void SDA_setSharedMemory4Recv(unsigned char *pBufferTotal,
+                                  unsigned int BufferTotalSize,
+                                  unsigned int BufferUnitSize,
+                                  unsigned int HeadroomSize)
+{
+	Direct_Audio_Rx_Setting(pBufferTotal,
+                                BufferTotalSize,
+                                BufferUnitSize,
+                                HeadroomSize);
+}
+EXPORT_SYMBOL(SDA_setSharedMemory4Recv);
+
+//Register callback which CLD notify DSP that CLD has received the audio packet
+void SDA_registerCallback4Recv(SDA_RecvCallBack pCallback)
+{
+	SDA_RX_READY_CB = pCallback;
+}
+EXPORT_SYMBOL(SDA_registerCallback4Recv);
+
+//Register callback which Mck notify DSP that Mck has sent the audio packet
+void SDA_registerCallback4SendDone(SDA_SendDoneCallBack pCallback)
+{
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+		"%s[%d]\n\r",__func__,__LINE__);
+	SDA_TX_DONE_CB = pCallback;
+}
+EXPORT_SYMBOL(SDA_registerCallback4SendDone);
+
+void Direct_Audio_debug_dump(void)
+{
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,"DA_context.pHddCtx = 0x%x\n\r",(int)DA_context.pHddCtx);
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,"DA_context.last_tx_process_time = %u\n\r",DA_context.last_tx_process_time);
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,"DA_context.max_tx_process_time = %u\n\r",DA_context.max_tx_process_time);
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,"DA_context.last_rx_process_time = %u\n\r",DA_context.last_rx_process_time);
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,"DA_context.max_rx_process_time = %u\n\r",DA_context.max_rx_process_time);
+}
+
+void Direct_Audio_init(hdd_context_t *pHddCtx)
+{
+	int i;
+	hdd_adapter_t * vif;
+
+	memset(&global_RX_DA_Setting, 0x0, sizeof(global_RX_DA_Setting));
+	for (i = 0; i < MAX_TX_POOL_ID; i++)
+	    memset(&global_TX_DA_Setting[i], 0x0, sizeof(global_TX_DA_Setting[0]));
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,"%s[%d]\n\r",__func__,__LINE__);
+
+	memset(&DA_context,0x00,sizeof(DA_context));
+	DA_context.pHddCtx = pHddCtx;
+	DA_context.vif_id = 1;//use p2p0 as default
+
+	vif = hdd_get_adapter_by_vdev(DA_context.pHddCtx, DA_context.vif_id);
+	if(!vif) {
+		printk("direct audio init failed.\n");
+	        return;
+	}
+
+	process_wma_set_command( (int)vif->sessionId,
+                                       (int)WMI_PDEV_PARAM_AUDIO_OVER_WLAN_LATENCY,
+                                       50,
+                                       PDEV_CMD);
+	process_wma_set_command( (int)vif->sessionId,
+                                       (int)WMI_PDEV_PARAM_AUDIO_OVER_WLAN_ENABLE,
+                                       1,
+                                       PDEV_CMD);
+}
+
+void Direct_Audio_deinit(hdd_context_t *pHddCtx)
+{
+	hdd_adapter_t * vif;
+
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,"%s[%d]\n\r",__func__,__LINE__);
+#ifdef CONFIG_CONTX_USB_DEBUG
+	if (txkeeprun == 1) {
+		txkeeprun = 0;
+		msleep(500);
+	}
+#endif /* CONFIG_CONTX_USB_DEBUG */
+
+	vif = hdd_get_adapter_by_vdev(DA_context.pHddCtx, DA_context.vif_id);
+	if(!vif) {
+		printk("direct audio deinit failed.\n");
+	        return;
+	}
+
+	process_wma_set_command(vif->sessionId,
+                                       (int)WMI_PDEV_PARAM_AUDIO_OVER_WLAN_ENABLE,
+                                       0,
+                                       PDEV_CMD);
+}
+
+#if defined(HIF_USB)
+
+#define TSF_TO_TU(_h,_l)    ((((u64)(_h)) << 32) | ((u64)(_l)))
+#define REG_TSF_L 0x1054
+#define REG_TSF_H 0x1058
+#define REG_TSF2_L 0x10d4
+#define REG_TSF2_H 0x10d8
+
+
+void SDA_GetTSF(unsigned int *pTsf)
+{
+	*((u64 *)pTsf) = SDA_getTsf(0);
+}
+EXPORT_SYMBOL(SDA_GetTSF);
+
+unsigned long long SDA_getTsf (unsigned char vif_id)
+{
+	A_UINT32 datah = 0, datal = 0;
+	struct hif_usb_softc *sc;
+	struct ol_softc *pOlsc;
+	VosContextType *pHIFContext = NULL;
+	v_CONTEXT_t pVosContext = NULL;
+
+	if (DA_context.pHddCtx == NULL) {
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
+			"%s: DA_context.ar should not be NULL\n", __func__);
+		return 0;
+	}
+
+	pVosContext = DA_context.pHddCtx->pvosContext;
+	pHIFContext = ((VosContextType*)pVosContext)->pHIFContext;
+	pOlsc = (struct ol_softc *)pHIFContext;
+	sc = pOlsc->hif_sc;
+
+	if (vif_id) {
+		HIFDiagReadAccess(sc->hif_device, REG_TSF2_H, &datah);
+		HIFDiagReadAccess(sc->hif_device, REG_TSF2_L, &datal);
+	} else {
+		HIFDiagReadAccess(sc->hif_device, REG_TSF_H, &datah);
+		HIFDiagReadAccess(sc->hif_device, REG_TSF_L, &datal);
+	}
+	return TSF_TO_TU(datah, datal);
+}
+EXPORT_SYMBOL(SDA_getTsf);
+
+int SDA_syncTsf (void)
+{
+	A_UINT32 datah = 0, datal = 0;
+	struct hif_usb_softc *sc;
+	struct ol_softc *pOlsc;
+	VosContextType *pHIFContext = NULL;
+	v_CONTEXT_t pVosContext = NULL;
+
+	if (DA_context.pHddCtx == NULL) {
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
+			"%s: DA_context.ar should not be NULL\n", __func__);
+		return 0;
+	}
+
+	pVosContext = DA_context.pHddCtx->pvosContext;
+	pHIFContext = ((VosContextType*)pVosContext)->pHIFContext;
+	pOlsc = (struct ol_softc *)pHIFContext;
+	sc = pOlsc->hif_sc;
+
+	HIFDiagReadAccess(sc->hif_device, REG_TSF_L, &datal);
+	HIFDiagReadAccess(sc->hif_device, REG_TSF_H, &datah);
+
+	HIFDiagWriteAccess(sc->hif_device, REG_TSF2_L, datal);
+	HIFDiagWriteAccess(sc->hif_device, REG_TSF2_H, datah);
+
+	return 0;
+}
+EXPORT_SYMBOL(SDA_syncTsf);
+
+#endif /*HIF_USB*/
+
+#if SDA_DEBUG//debug use
+struct D_A_SHARE_MEM {
+    SDA_Header_t	desc;
+	u8				data[MAX_BUF_SIZE];
+};
+
+static void debug_tx_done_cb(unsigned int BufferId, unsigned char *pBuffer, unsigned int BufferSize)
+{
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+			"%s[%d]BufferId=%d,pBuffer=0x%p,BufferSize=%d\n\r",
+	        __func__, __LINE__, BufferId, pBuffer, BufferSize);
+}
+#ifdef CONFIG_CONTX_USB_DEBUG
+/* only works with 9378 USB v2.3 only work on with some firmwares */
+static u8 seq_for_contx=0;
+extern int txkeepcountmax;
+int SDA_CONTX_COUNT_RESET(void)
+{
+	struct hif_usb_softc *sc;
+	struct ol_softc *pOlsc;
+	VosContextType *pHIFContext = NULL;
+	v_CONTEXT_t pVosContext = NULL;
+
+	if (DA_context.pHddCtx == NULL) {
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
+			"%s: DA_context.ar should not be NULL\n", __func__);
+		return 0;
+	}
+
+	pVosContext = DA_context.pHddCtx->pvosContext;
+	pHIFContext = ((VosContextType*)pVosContext)->pHIFContext;
+	pOlsc = (struct ol_softc *)pHIFContext;
+	sc = pOlsc->hif_sc;
+
+	seq_for_contx = 0;
+	HIFDiagWriteAccess(sc->hif_device, audio_debug_seq_addr, 0);
+	HIFDiagWriteAccess(sc->hif_device, seq_error_addr, 0);
+	HIFDiagWriteAccess(sc->hif_device, content_error_addr, 0);
+	HIFDiagWriteAccess(sc->hif_device, totalcount_addr, 0);
+	msleep(5);  //wait for write to complete
+	return 0;
+}
+
+int SDA_CONTX_COUNT_RESULT(char * extra, A_UINT8 wait_loop)
+{
+	A_UINT32 seq_error_count = 0, content_err_count = 0, totalcount =0;
+	struct hif_usb_softc *sc;
+	struct ol_softc *pOlsc;
+	VosContextType *pHIFContext = NULL;
+	v_CONTEXT_t pVosContext = NULL;
+
+	if (DA_context.pHddCtx == NULL) {
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
+			"%s: DA_context.ar should not be NULL\n", __func__);
+		return 0;
+	}
+
+	pVosContext = DA_context.pHddCtx->pvosContext;
+	pHIFContext = ((VosContextType*)pVosContext)->pHIFContext;
+	pOlsc = (struct ol_softc *)pHIFContext;
+	sc = pOlsc->hif_sc;
+
+	HIFDiagReadAccess(sc->hif_device, totalcount_addr, &totalcount);
+
+	while (wait_loop-- && (totalcount != txkeepcountmax)) {
+		pr_err("[USB_CONTX]: bus slow wait %d time, (%d)\n",(10 - wait_loop), totalcount);
+		msleep(200);
+		HIFDiagReadAccess(sc->hif_device, totalcount_addr, &totalcount);
+	}
+
+	HIFDiagReadAccess(sc->hif_device, seq_error_addr, &seq_error_count);
+	HIFDiagReadAccess(sc->hif_device, content_error_addr, &content_err_count);
+
+	pr_err("[USB_CONTX]: total %d seq_err %d content_err %d\n", totalcount, seq_error_count, content_err_count);
+
+	if (extra)
+		snprintf(extra, WE_MAX_STR_LEN, "[USB_CONTX] total %d seq_err %d content_err %d\n", totalcount, seq_error_count, content_err_count);
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_VOS_MEM_PRE_ALLOC
+static u8 gtxdebugbuf[(sizeof(SDA_Header_t)+MAX_BUF_SIZE)*MAX_SHARE_MEM_ITEM];
+static u8 grxdebugbuf[sizeof(struct D_A_SHARE_MEM)*MAX_SHARE_MEM_ITEM];
+#endif
+int Direct_Audio_TX_debug(unsigned int usbdbgtxtime)
+{
+	u8	*buf;
+	u32 len,i,BufferSize;
+	u8	*ptr,*eth_ptr;
+	SDA_Descriptor_t *share_mem_ptr;
+	hdd_adapter_t * vif;
+
+	u8	test_peermac[6] = {0xff,0x03,0x7f,0x8b,0x18,0x93};
+	struct ethhdr *eth_hdr;
+	u8 sendcount = 1;
+
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
+		"%s[%d]Simulate TX behavior\n\r",__func__,__LINE__);
+	SDA_registerCallback4SendDone(debug_tx_done_cb);
+
+	len = (sizeof(SDA_Header_t)+MAX_BUF_SIZE)*MAX_SHARE_MEM_ITEM;
+#ifdef CONFIG_VOS_MEM_PRE_ALLOC
+	buf = (u8 *)gtxdebugbuf;
+#else
+	buf = kmalloc(len, GFP_ATOMIC);
+	if (!buf)
+		return -ENOMEM;
+#endif
+	SDA_setSharedMemory4Send(0, buf, len, sizeof(SDA_Header_t)+MAX_BUF_SIZE, 50);
+	ptr	= buf;
+#ifdef CONFIG_CONTX_USB_DEBUG
+	if (txkeeprun != 0) {
+		DA_context.vif_id = 1; //p2p0
+		sendcount = MAX_SHARE_MEM_ITEM;
+	} else {
+		DA_context.vif_id = 1; //p2p0
+		sendcount = 5;
+	}
+#endif /* CONFIG_CONTX_USB_DEBUG */
+	//construct tx share memory
+	vif = hdd_get_adapter_by_vdev(DA_context.pHddCtx, DA_context.vif_id);
+	if(!vif)
+		return -ENOMEM;
+
+
+
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+			"peer %pM mac %pM\n", test_peermac, vif->dev->dev_addr);
+
+	memset(buf,0x00,len);
+	share_mem_ptr = (SDA_Descriptor_t *)buf;
+	BufferSize = 0;
+#ifdef CONFIG_CONTX_USB_DEBUG
+	for (i=0; i < sendcount; i++) {
+		//fill descript
+		share_mem_ptr->m_ReadyToCopy = 1;
+		share_mem_ptr->m_PayloadSize = 1024;
+		share_mem_ptr->m_TimeStamp = 0;
+		//fill ethernet header
+		eth_ptr = ptr+sizeof(SDA_Header_t)-sizeof(struct ethhdr);
+		eth_hdr = (struct ethhdr *)eth_ptr;
+		memcpy(eth_hdr->h_dest,test_peermac,6);
+		memcpy(eth_hdr->h_source,vif->dev->dev_addr,6);
+		eth_hdr->h_proto = htons(DIRECT_AUDIO_LLC_TYPE);
+		if (usbdbgtxtime != 0 ) {
+			memset(ptr+sizeof(SDA_Header_t),0xa5,share_mem_ptr->m_PayloadSize);
+			memset(ptr+sizeof(SDA_Header_t),seq_for_contx,2+1); /* +2 for aligment in fw */
+			seq_for_contx++;
+		} else {
+			memset(ptr+sizeof(SDA_Header_t),0xa5,share_mem_ptr->m_PayloadSize);
+		}
+		BufferSize += sizeof(SDA_Header_t) + MAX_BUF_SIZE;
+		ptr = ptr + sizeof(SDA_Header_t) + MAX_BUF_SIZE;
+		share_mem_ptr = (SDA_Descriptor_t *)ptr;
+	}
+
+#else
+	for (i=0; i < sendcount; i++) {
+		//fill descript
+		share_mem_ptr->m_ReadyToCopy = 1;
+		share_mem_ptr->m_PayloadSize = 1024;
+		share_mem_ptr->m_TimeStamp = 0;
+		//fill ethernet header
+		eth_ptr = ptr+sizeof(SDA_Header_t)-sizeof(struct ethhdr);
+		eth_hdr = (struct ethhdr *)eth_ptr;
+		memcpy(eth_hdr->h_dest,test_peermac,6);
+		memcpy(eth_hdr->h_source,vif->dev->dev_addr,6);
+		eth_hdr->h_proto = htons(DIRECT_AUDIO_LLC_TYPE);
+		memset(ptr+sizeof(SDA_Header_t),0xa5,share_mem_ptr->m_PayloadSize);
+		BufferSize += sizeof(SDA_Header_t) + MAX_BUF_SIZE;
+		ptr = ptr + sizeof(SDA_Header_t) + MAX_BUF_SIZE;
+		share_mem_ptr = (SDA_Descriptor_t *)ptr;
+	}
+#endif /* CONFIG_CONTX_USB_DEBUG */
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+		"%s[%d]BufferId=%d,pBuffer=0x%p,BufferSize=%d\n\r",
+	    __func__, __LINE__, 0, buf, BufferSize);
+	//notify Direct Audio module to send packet
+	SDA_function4Send(0, buf, BufferSize);
+#ifndef CONFIG_VOS_MEM_PRE_ALLOC
+	kfree(buf);
+#endif
+#if defined(HIF_USB)
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
+		"%s[%d]Simulate TX finish, wlan tsf %llu, p2p tsf %llu\n",
+		__func__,__LINE__, SDA_getTsf(0), SDA_getTsf(1));
+#endif
+
+	return 0;
+}
+
+static void debug_rx_ready_cb(unsigned char *pBuffer, unsigned int BufferSize)
+{
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
+		"%s[%d]pBuffer=0x%p,BufferSize=%d\n\r",
+		__func__, __LINE__, pBuffer, BufferSize);
+}
+
+int Direct_Audio_RX_debug(void)
+{
+	u8	*buf;
+	u32 len;
+
+	if(RX_DA_INIT_ADDR) {
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_WARN,
+			"%s[%d]already rx debug\n\r",__func__,__LINE__);
+	}
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
+		"%s[%d]SimulateRX behavior\n\r",__func__,__LINE__);
+	len = sizeof(struct D_A_SHARE_MEM)*MAX_SHARE_MEM_ITEM;
+#ifdef CONFIG_VOS_MEM_PRE_ALLOC
+	buf = (u8 *)grxdebugbuf;
+#else
+	buf = kmalloc(len, GFP_ATOMIC);
+	if (!buf)
+		return -ENOMEM;
+#endif
+	//construct rx share memory
+	memset(buf,0x00,len);
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
+		"%s[%d]buf=0x%p\n\r", __func__, __LINE__, buf);
+	SDA_setSharedMemory4Recv(buf, len, sizeof(struct D_A_SHARE_MEM), 50);
+	//Direct_Audio_RxReady_Notify_cb_Reg(debug_rx_ready_cb);
+	SDA_registerCallback4Recv(debug_rx_ready_cb);
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
+		"%s[%d]Simulate RX finish\n\r",__func__,__LINE__);
+#ifndef CONFIG_VOS_MEM_PRE_ALLOC
+	kfree(buf);
+#endif
+	return 0;
+}
+#else
+int Direct_Audio_TX_debug(unsigned int usbdbgtxtime)
+{
+	return 0;
+}
+
+int Direct_Audio_RX_debug(void)
+{
+	return 0;
+}
+#endif //if SDA_DEBUG
+
+#endif //end DIRECT_AUDIO_SUPPORT
diff --git a/CORE/HDD/src/wlan_hdd_hostapd.c b/CORE/HDD/src/wlan_hdd_hostapd.c
index 62cb37d..5a4f67b 100644
--- a/CORE/HDD/src/wlan_hdd_hostapd.c
+++ b/CORE/HDD/src/wlan_hdd_hostapd.c
@@ -2819,6 +2819,11 @@ static VOS_STATUS hdd_print_acl(hdd_adapter_t *pHostapdAdapter)
     return VOS_STATUS_SUCCESS;
 }
 
+#ifdef DIRECT_AUDIO_SUPPORT
+extern int Direct_Audio_TX_debug(unsigned int usbdbgtxtime);
+extern int Direct_Audio_RX_debug(void);
+#endif
+
 int
 static __iw_softap_setparam(struct net_device *dev,
                             struct iw_request_info *info,
@@ -3067,6 +3072,24 @@ static __iw_softap_setparam(struct net_device *dev,
                                                set_value, DBG_CMD);
                   break;
              }
+#ifdef CONFIG_WLAN_FWLOG_FILE
+        case QCSAP_DBGLOG_FWLOG_FILE_ENABLE:
+             {
+                  hddLog(LOG1, "QCSAP_DBGLOG_FWLOG_FILE_ENABLE val %d", set_value);
+                  ret = process_wma_set_command((int)pHostapdAdapter->sessionId,
+                                               (int)WMI_DBGLOG_FWLOG_FILE_ENABLE,
+                                               set_value, DBG_CMD);
+                  break;
+             }
+        case QCSAP_DBGLOG_FWLOG_FILE_MAX_SIZE:
+             {
+                  hddLog(LOG1, "QCSAP_DBGLOG_FWLOG_FILE_MAX_SIZE val %d", set_value);
+                  ret = process_wma_set_command((int)pHostapdAdapter->sessionId,
+                                               (int)WMI_DBGLOG_FWLOG_FILE_MAX_SIZE,
+                                               set_value, DBG_CMD);
+                  break;
+             }
+#endif
          case QCSAP_PARAM_SET_MCC_CHANNEL_LATENCY:
              {
                   tVOS_CONCURRENCY_MODE concurrent_state = 0;
@@ -3524,6 +3547,21 @@ static __iw_softap_setparam(struct net_device *dev,
             ret = hdd_set_rx_stbc(pHostapdAdapter, set_value);
             break;
 
+#ifdef DIRECT_AUDIO_SUPPORT
+        case QCSAP_DIRECT_AUDIO_TEST:
+            {
+                hddLog(LOGW, "%s: SAP Direct_Audio Test %s\n",
+                                  __func__, set_value ? "TX" : "RX");
+                if (set_value) {
+                  ret = Direct_Audio_TX_debug(0);
+                }
+                else {
+                  ret = Direct_Audio_RX_debug();
+                }
+                break;
+            }
+#endif
+
         default:
             hddLog(LOGE, FL("Invalid setparam command %d value %d"),
                     sub_cmd, set_value);
diff --git a/CORE/HDD/src/wlan_hdd_main.c b/CORE/HDD/src/wlan_hdd_main.c
index 3650b56..ae62876 100644
--- a/CORE/HDD/src/wlan_hdd_main.c
+++ b/CORE/HDD/src/wlan_hdd_main.c
@@ -171,6 +171,11 @@ extern int hdd_hostapd_stop (struct net_device *dev);
 #define WLAN_TFC_IPAUC_TX_DESC_RESERVE   100
 #endif /* IPA_UC_OFFLOAD */
 
+#ifdef DIRECT_AUDIO_SUPPORT
+extern void Direct_Audio_init(hdd_context_t *pHddCtx);
+extern void Direct_Audio_deinit(hdd_context_t *pHddCtx);
+#endif
+
 /* the Android framework expects this param even though we don't use it */
 #define BUF_LEN 20
 static char fwpath_buffer[BUF_LEN];
@@ -3113,8 +3118,10 @@ static int hdd_enable_ext_wow(hdd_adapter_t *pAdapter,
           VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
               "%s: Received ready to ExtWoW. Going to suspend", __func__);
 
+#if defined(HIF_PCI)
           wlan_hdd_cfg80211_suspend_wlan(pHddCtx->wiphy, NULL);
           wlan_hif_pci_suspend();
+#endif
        }
     } else {
         VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
@@ -3136,12 +3143,11 @@ static int hdd_enable_ext_wow_parser(hdd_adapter_t *pAdapter, int vdev_id,
    if (0 != rc)
        return -EINVAL;
 
-   if (value < EXT_WOW_TYPE_APP_TYPE1 || value > EXT_WOW_TYPE_APP_TYPE1_2 ) {
-       hddLog(VOS_TRACE_LEVEL_ERROR, FL("Invalid type"));
-       return -EINVAL;
-   }
+   vos_mem_zero(&params, sizeof(params));
 
-   if (value == EXT_WOW_TYPE_APP_TYPE1 &&
+   if (value == EXT_WOW_DISABLED) {
+        params.type = value;
+   } else if (value == EXT_WOW_TYPE_APP_TYPE1 &&
         pHddCtx->is_extwow_app_type1_param_set)
         params.type = value;
    else if (value == EXT_WOW_TYPE_APP_TYPE2 &&
@@ -3189,11 +3195,13 @@ static int hdd_set_app_type1_parser(hdd_adapter_t *pAdapter,
     tHalHandle hHal = WLAN_HDD_GET_HAL_CTX(pAdapter);
     char id[20], password[20];
     tSirAppType1Params params;
-    int rc, i;
+    int ret;
 
-    rc = wlan_hdd_validate_context(pHddCtx);
-    if (0 != rc)
+    ret = wlan_hdd_validate_context(pHddCtx);
+    if (0 != ret) {
+       hddLog(VOS_TRACE_LEVEL_ERROR, FL("HDD context is not valid"));
        return -EINVAL;
+    }
 
     if (2 != sscanf(arg, "%8s %16s", id, password)) {
        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
@@ -3203,8 +3211,6 @@ static int hdd_set_app_type1_parser(hdd_adapter_t *pAdapter,
 
     memset(&params, 0, sizeof(tSirAppType1Params));
     params.vdev_id = pAdapter->sessionId;
-    for (i = 0; i < ETHER_ADDR_LEN; i++)
-        params.wakee_mac_addr[i] = pAdapter->macAddressCurrent.bytes[i];
 
     params.id_length = strlen(id);
     vos_mem_copy(params.identification_id, id, params.id_length);
@@ -3212,12 +3218,15 @@ static int hdd_set_app_type1_parser(hdd_adapter_t *pAdapter,
     vos_mem_copy(params.password, password, params.pass_length);
 
     VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
-        "%s: %d %pM %.8s %u %.16s %u",
-        __func__, params.vdev_id, params.wakee_mac_addr,
-        params.identification_id, params.id_length,
-        params.password, params.pass_length );
+        "%s: %d %.8s %u %.16s %u",
+        __func__, params.vdev_id, params.identification_id, params.id_length,
+        params.password, params.pass_length);
 
-    return hdd_set_app_type1_params(hHal, &params);
+    ret = hdd_set_app_type1_params(hHal, &params);
+    if (ret == 0) {
+        vos_mem_copy(&pHddCtx->app_type1_params, &params, sizeof(tSirAppType1Params));
+    }
+    return ret;
 }
 
 static int hdd_set_app_type2_params(tHalHandle hHal,
@@ -8002,6 +8011,9 @@ static int hdd_driver_ioctl(hdd_adapter_t *pAdapter, struct ifreq *ifr)
    return ret;
 }
 
+#ifdef CONFIG_CUST_PLATFORM
+int swol_ioctl(hdd_adapter_t *pAdapter, struct ifreq *ifr);
+#endif
 /**
  * __hdd_ioctl() - HDD ioctl handler
  * @dev: pointer to net_device structure
@@ -8056,6 +8068,13 @@ static int __hdd_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
       else
          ret = hdd_driver_ioctl(pAdapter, ifr);
       break;
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+#ifdef CONFIG_CUST_PLATFORM
+   case (SIOCDEVPRIVATE+10):
+         ret = swol_ioctl(pAdapter, ifr);
+      break;
+#endif
+#endif
    default:
       hddLog(VOS_TRACE_LEVEL_ERROR, "%s: unknown ioctl %d",
              __func__, cmd);
@@ -8067,6 +8086,227 @@ static int __hdd_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
    return ret;
 }
 
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+#ifdef CONFIG_CUST_PLATFORM
+static void wlan_hdd_swol_work_item(struct work_struct *work)
+{
+    hdd_adapter_t *pAdapter = container_of(work,
+                                           hdd_adapter_t,
+                                           ext_wow_work);
+    hdd_context_t *pHddCtx = WLAN_HDD_GET_CTX(pAdapter);
+    tHalHandle hHal = WLAN_HDD_GET_HAL_CTX(pAdapter);
+    struct net_device *dev = pAdapter->dev;
+    int ret = 0;
+
+    if (WLAN_HDD_ADAPTER_MAGIC != pAdapter->magic) {
+        hddLog(LOGE, FL("invalid magic"));
+        return;
+    }
+    ret = wlan_hdd_validate_context(pHddCtx);
+    if (0 != ret) {
+        hddLog(LOGE, FL("HDD context is not valid"));
+        return;
+    }
+
+    mutex_lock(&pHddCtx->ext_wow_lock);
+    if (pHddCtx->ext_wow_enable == TRUE) {
+        pHddCtx->app_type1_params.vdev_id = pAdapter->sessionId;
+        pHddCtx->app_type1_params.id_length = 6;
+        vos_mem_zero(pHddCtx->app_type1_params.identification_id, sizeof(pHddCtx->app_type1_params.identification_id));
+        vos_mem_copy(pHddCtx->app_type1_params.identification_id, "SECWOW", 6);
+        vos_mem_copy(pHddCtx->app_type1_params.swol_indoor_wakee, pAdapter->macAddressCurrent.bytes, 6);
+        ret = hdd_set_app_type1_params(hHal, &(pHddCtx->app_type1_params));
+        if (ret >= 0) {
+            pHddCtx->is_extwow_app_type1_param_set = TRUE;
+        }
+        ret = hdd_enable_ext_wow_parser(pAdapter,
+                                        pAdapter->sessionId, EXT_WOW_TYPE_APP_TYPE1);
+        mutex_unlock(&pHddCtx->ext_wow_lock);
+        if (ret == 0) {
+            ret = cfg80211_wowlan_set(pAdapter->dev, TRUE);
+            if (ret != 0) {
+                VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+                           "%s failed to set wowlan:%d\n", netdev_name(dev), ret);
+            }
+        } else {
+            VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+                           "%s failed to enable extwow\n", netdev_name(dev));
+        }
+    } else {
+        ret = hdd_enable_ext_wow_parser(pAdapter,
+                                        pAdapter->sessionId, EXT_WOW_DISABLED);
+        mutex_unlock(&pHddCtx->ext_wow_lock);
+        if (ret != 0) {
+            VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+                           "%s failed to enable extwow\n", netdev_name(dev));
+        } else {
+            ret = cfg80211_wowlan_set(pAdapter->dev, FALSE);
+            if (ret != 0) {
+                VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+                           "%s failed to set wowlan:%d\n", netdev_name(dev), ret);
+            }
+        }
+    }
+    mutex_lock(&pHddCtx->ext_wow_lock);
+    vos_mem_zero(&pHddCtx->app_type1_params, sizeof(pHddCtx->app_type1_params));
+    pHddCtx->is_extwow_app_type1_param_set = FALSE;
+    mutex_unlock(&pHddCtx->ext_wow_lock);
+}
+
+static int _wlan_hdd_enable_swol(hdd_adapter_t *pAdapter, boolean enable)
+{
+    hdd_context_t *pHddCtx = WLAN_HDD_GET_CTX(pAdapter);
+
+    pHddCtx->ext_wow_enable = enable;
+    schedule_work(&pAdapter->ext_wow_work);
+    return 0;
+}
+
+int wlan_hdd_enable_swol(hdd_adapter_t *pAdapter, boolean enable)
+{
+    hdd_context_t *pHddCtx = WLAN_HDD_GET_CTX(pAdapter);
+    int ret;
+
+    mutex_lock(&pHddCtx->ext_wow_lock);
+    ret = _wlan_hdd_enable_swol(pAdapter, enable);
+    mutex_unlock(&pHddCtx->ext_wow_lock);
+    return ret;
+}
+
+int swol_ioctl(hdd_adapter_t *pAdapter, struct ifreq *ifr)
+{
+    hdd_context_t *pHddCtx = WLAN_HDD_GET_CTX(pAdapter);
+    int ret = 0;
+    int i =0, j = 0;
+    struct ioctl_priv_params *data;
+    tSirExtWoWParams params;
+
+    data = kmalloc(sizeof(struct ioctl_priv_params), GFP_KERNEL);
+    if (!data)
+        return -ENOMEM;
+
+    if (copy_from_user(data, ifr->ifr_data, sizeof(struct ioctl_priv_params)))
+    {
+        kfree(data);
+        return -EFAULT;
+    }
+
+    mutex_lock(&pHddCtx->ext_wow_lock);
+    switch (data->cmd_id){
+    case IOCTL_PRIV_SWOW_START:
+        switch(data->params.swow_start.cmd) {
+        case 0:
+            ret = _wlan_hdd_enable_swol(pAdapter, TRUE);
+            break;
+        case 1:
+            // Outdoor, not available now.
+            break;
+        case 9:
+            // Stop
+            ret = _wlan_hdd_enable_swol(pAdapter, FALSE);
+            break;
+        default:
+            break;
+        }
+    break;
+    case IOCTL_PRIV_SWOW_WAKER_W:
+        {
+            struct waker *waker_w = &(data->params.swow_waker_w.write_waker);
+            int index = data->params.swow_waker_w.waker_id;
+            if(index > 7){
+                VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+                             "out of index[0~7] : %d\n", index);
+                ret = -EINVAL;
+                break;
+            }
+
+            for( i=0; i <6; i++)
+                pHddCtx->app_type1_params.swol_indoor_key_mac[index][i] = waker_w->key_mac[i];
+
+            pHddCtx->app_type1_params.swol_indoor_app_mask[index] = waker_w->app_mask;
+            pHddCtx->app_type1_params.swol_indoor_key_len[index] = waker_w->key_len;
+            vos_mem_set( pHddCtx->app_type1_params.swol_indoor_key[index], 0, 16);
+            if(waker_w->key_len > 16){
+                VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+                            "wrong key len\n");
+                ret = -EINVAL;
+                break;
+            }
+            if (waker_w->key_len) {
+                vos_mem_copy(pHddCtx->app_type1_params.swol_indoor_key[index], waker_w->key, waker_w->key_len);
+            }
+            pHddCtx->app_type1_params.pass_length = waker_w->key_len;
+            vos_mem_set(pHddCtx->app_type1_params.password, 0, 16);
+            if (waker_w->key_len) {
+                vos_mem_copy(pHddCtx->app_type1_params.password, waker_w->key, pHddCtx->app_type1_params.pass_length);
+            }
+        }
+    break;
+    case IOCTL_PRIV_SWOW_WAKER_R:
+    {
+        struct waker *waker_r;
+
+        for( j=0; j < 8; j++) {
+            waker_r = &(data->params.swow_waker_r.read_waker[j]);
+                for( i=0; i <6; i++)
+                    waker_r->key_mac[i] = pHddCtx->app_type1_params.swol_indoor_key_mac[j][i];
+                waker_r->app_mask = pHddCtx->app_type1_params.swol_indoor_app_mask[j];
+                waker_r->key_len = pHddCtx->app_type1_params.swol_indoor_key_len[j];
+                vos_mem_set(waker_r->key, 0, 16);
+                if (waker_r->key_len) {
+                    vos_mem_copy(waker_r->key, pHddCtx->app_type1_params.swol_indoor_key[j], waker_r->key_len);
+                }
+            }
+        }
+    break;
+    case IOCTL_PRIV_SWOW_EXCEPTION_W:
+        pHddCtx->app_type1_params.swol_indoor_exception = data->params.swow_exception.exception;
+        pHddCtx->app_type1_params.swol_indoor_exception_app = data->params.swow_exception.exception_app;
+    break;
+    case IOCTL_PRIV_SWOW_EXCEPTION_R:
+        data->params.swow_exception.exception = pHddCtx->app_type1_params.swol_indoor_exception;
+        data->params.swow_exception.exception_app = pHddCtx->app_type1_params.swol_indoor_exception_app;
+    break;
+    case IOCTL_PRIV_SWOW_PATTEN_W:
+        pHddCtx->app_type1_params.swol_indoor_pattern = data->params.swow_pattern.pattern;
+    break;
+    case IOCTL_PRIV_SWOW_PATTEN_R:
+        data->params.swow_pattern.pattern = pHddCtx->app_type1_params.swol_indoor_pattern;
+    break;
+    case IOCTL_PRIV_SWOW_FILTER_W:
+        pHddCtx->app_type1_params.swol_indoor_waker_check = data->params.swow_filter.waker_check;
+        pHddCtx->app_type1_params.swol_indoor_pw_check = data->params.swow_filter.pw_check;
+        if(pHddCtx->app_type1_params.swol_indoor_waker_check == 0 && pHddCtx->app_type1_params.swol_indoor_pw_check == 1)
+            pHddCtx->app_type1_params.swol_indoor_pw_check = 0;
+    break;
+    case IOCTL_PRIV_SWOW_FILTER_R:
+        data->params.swow_filter.waker_check = pHddCtx->app_type1_params.swol_indoor_waker_check;
+        data->params.swow_filter.pw_check = pHddCtx->app_type1_params.swol_indoor_pw_check;
+    break;
+    case IOCTL_PRIV_SWOW_PULSE_TEST:
+        memset(&params, 0, sizeof(params));
+        params.vdev_id = pAdapter->sessionId;
+        params.type = EXT_WOW_TYPE_APP_PULSETEST;
+        params.wakeup_pin_num = pHddCtx->cfg_ini->extWowApp1WakeupPinNumber |
+                      (pHddCtx->cfg_ini->extWowApp2WakeupPinNumber << 8);
+        params.swol_pulsetest_type = data->params.swow_pulse_test.type;
+        params.swol_pulsetest_application = data->params.swow_pulse_test.app;
+        ret = hdd_enable_ext_wow(pAdapter, &params);
+    break;
+    case IOCTL_PRIV_SWOW_ASSISTANT:
+        pHddCtx->app_type1_params.swol_assist_enable = data->params.swow_assist.enable;
+    break;
+    default:
+    break;
+    }
+
+    mutex_unlock(&pHddCtx->ext_wow_lock);
+    kfree(data);
+    return ret;
+}
+#endif
+#endif
+
 /**
  * hdd_ioctl() - Wrapper function to protect __hdd_ioctl() function from SSR
  * @dev: pointer to net_device structure
@@ -9421,6 +9661,10 @@ static void __hdd_uninit(struct net_device *dev)
 	if (dev != pAdapter->dev)
 		hddLog(LOGP, FL("Invalid device reference"));
 
+#ifdef DIRECT_AUDIO_SUPPORT
+	Direct_Audio_deinit(pAdapter->pHddCtx);
+#endif
+
 	hdd_deinit_adapter(pAdapter->pHddCtx, pAdapter, true);
 
 	/* After uninit our adapter structure will no longer be valid */
@@ -11267,6 +11511,11 @@ hdd_adapter_t* hdd_open_adapter( hdd_context_t *pHddCtx, tANI_U8 session_type,
      if (ret != 0)
         hddLog(LOGE, "FAILED TO SET RTSCTS Profile ret:%d", ret);
 
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+#ifdef CONFIG_CUST_PLATFORM
+    INIT_WORK(&pAdapter->ext_wow_work, wlan_hdd_swol_work_item);
+#endif
+#endif
 
    return pAdapter;
 
@@ -11433,6 +11682,12 @@ VOS_STATUS hdd_stop_adapter( hdd_context_t *pHddCtx, hdd_adapter_t *pAdapter,
 
    ENTER();
 
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+#ifdef CONFIG_CUST_PLATFORM
+   cancel_work_sync(&pAdapter->ext_wow_work);
+#endif
+#endif
+
    hddLog(LOG1, FL("Disabling queues"));
    wlan_hdd_netif_queue_control(pAdapter, WLAN_NETIF_TX_DISABLE_N_CARRIER,
                                     WLAN_CONTROL_PATH);
@@ -11794,6 +12049,14 @@ VOS_STATUS hdd_start_all_adapters( hdd_context_t *pHddCtx )
       switch(pAdapter->device_mode)
       {
          case WLAN_HDD_INFRA_STATION:
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+#ifdef CONFIG_CUST_PLATFORM
+            if (pAdapter->device_mode == WLAN_HDD_INFRA_STATION) {
+                wlan_hdd_enable_swol(pAdapter, FALSE);
+            }
+#endif
+#endif
+
          case WLAN_HDD_P2P_CLIENT:
          case WLAN_HDD_P2P_DEVICE:
 
@@ -14604,6 +14867,13 @@ int hdd_wlan_startup(struct device *dev, v_VOID_t *hif_sc)
 
    hdd_list_init( &pHddCtx->hddAdapters, MAX_NUMBER_OF_ADAPTERS );
 
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+#ifdef CONFIG_CUST_PLATFORM
+   pHddCtx->ext_wow_enable = FALSE;
+   mutex_init(&pHddCtx->ext_wow_lock);
+#endif
+#endif
+
 #ifdef FEATURE_WLAN_TDLS
    /* tdls_lock is initialized before an hdd_open_adapter ( which is
     * invoked by other instances also) to protect the concurrent
@@ -15612,6 +15882,9 @@ err_free_hdd_context:
    return -EIO;
 
 success:
+#ifdef DIRECT_AUDIO_SUPPORT
+	Direct_Audio_init(pHddCtx);
+#endif
    EXIT();
    return 0;
 }
@@ -15629,7 +15902,9 @@ success:
 int hdd_hif_register_driver(void)
 {
 	int ret;
+#if !defined(CONFIG_USB_PRELOAD)
 	unsigned long rc, timeout;
+#endif
 
 	init_completion(&wlan_comp.wlan_start_comp);
 	wlan_comp.status = 0;
@@ -15640,6 +15915,9 @@ int hdd_hif_register_driver(void)
 		hddLog(LOGE, FL("HIF registration failed"));
 		return ret;
 	}
+#if defined(CONFIG_USB_PRELOAD)
+	return 0;
+#else
 
 	timeout = msecs_to_jiffies(HDD_WLAN_START_WAIT_TIME);
 
@@ -15656,6 +15934,7 @@ int hdd_hif_register_driver(void)
 		       wlan_comp.status, rc);
 
 	return wlan_comp.status;
+#endif /* CONFIG_USB_PRELOAD */
 }
 
 /**---------------------------------------------------------------------------
@@ -15714,6 +15993,15 @@ static int hdd_driver_init( void)
    pr_info("%s: loading driver v%s\n", WLAN_MODULE_NAME,
            QWLAN_VERSIONSTR TIMER_MANAGER_STR MEMORY_DEBUG_STR);
 
+#ifdef CONFIG_VOS_MEM_PRE_ALLOC
+   status = vos_prealloc_init();
+   if (!VOS_IS_STATUS_SUCCESS(status))
+   {
+     hddLog(VOS_TRACE_LEVEL_FATAL,"%s: Failed to prealloc memory", __func__);
+     ret_status = -1;
+   }
+#endif /* CONFIG_VOS_MEM_PRE_ALLOC */
+
    do {
 
 #ifndef MODULE
@@ -15786,6 +16074,9 @@ static int hdd_driver_init( void)
 #ifdef TIMER_MANAGER
       vos_timer_exit();
 #endif
+#ifdef CONFIG_VOS_MEM_PRE_ALLOC
+      vos_prealloc_deinit();
+#endif
 #ifdef MEMORY_DEBUG
       vos_mem_exit();
 #endif
@@ -15910,6 +16201,9 @@ static void hdd_driver_exit(void)
 #ifdef TIMER_MANAGER
    vos_timer_exit();
 #endif
+#ifdef CONFIG_VOS_MEM_PRE_ALLOC
+   vos_prealloc_deinit();
+#endif /* CONFIG_VOS_MEM_PRE_ALLOC */
 #ifdef MEMORY_DEBUG
    vos_mem_exit();
 #endif
diff --git a/CORE/HDD/src/wlan_hdd_p2p.c b/CORE/HDD/src/wlan_hdd_p2p.c
index 1e81402..b3f0524 100644
--- a/CORE/HDD/src/wlan_hdd_p2p.c
+++ b/CORE/HDD/src/wlan_hdd_p2p.c
@@ -51,6 +51,7 @@
 #include "vos_types.h"
 #include "vos_trace.h"
 #include "vos_sched.h"
+#include <adf_os_time.h>
 
 //Ms to Micro Sec
 #define MS_TO_MUS(x)   ((x)*1000)
@@ -500,6 +501,34 @@ wait:
 
 void wlan_hdd_remain_on_chan_timeout(void *data)
 {
+#ifdef CONFIG_CUST_PLATFORM
+    hdd_remain_on_chan_ctx_t *pRemainChanCtx = (hdd_remain_on_chan_ctx_t *)data;
+    hdd_adapter_t *pAdapter = pRemainChanCtx->pAdapter;
+    hdd_cfg80211_state_t *cfgState;
+    hdd_context_t *pHddCtx;
+
+    if (((((unsigned int)pAdapter) & 0x6b6b0000) == 0x6b6b0000) ||
+        (pAdapter == NULL)) {
+        hddLog( LOGE,"%s: No Remain on channel is pending", __func__);
+        return;
+    }
+
+    pHddCtx = WLAN_HDD_GET_CTX(pAdapter);
+
+    cfgState = WLAN_HDD_GET_CFG_STATE_PTR( pAdapter );
+    mutex_lock(&cfgState->remain_on_chan_ctx_lock);
+    if (pRemainChanCtx->cookie != (uintptr_t)pRemainChanCtx) {
+        mutex_unlock(&cfgState->remain_on_chan_ctx_lock);
+        hddLog( LOGE,"%s: Remain on channel has been cancel", __func__);
+        return;
+    }
+    if ((FALSE == pRemainChanCtx->hdd_remain_on_chan_cancel_in_progress) &&
+        (cfgState->remain_on_chan_ctx != pRemainChanCtx)) {
+        hddLog( LOGE,"%s: old Remain on channelshould be canceled", __func__);
+        mutex_unlock(&cfgState->remain_on_chan_ctx_lock);
+        return;
+    }
+#else
     hdd_adapter_t *pAdapter = (hdd_adapter_t *)data;
     hdd_context_t *pHddCtx;
     hdd_remain_on_chan_ctx_t *pRemainChanCtx;
@@ -522,6 +551,7 @@ void wlan_hdd_remain_on_chan_timeout(void *data)
         hddLog( LOGE,"%s: No Remain on channel is pending", __func__);
         return;
     }
+#endif
 
     if ( TRUE == pRemainChanCtx->hdd_remain_on_chan_cancel_in_progress )
     {
@@ -576,24 +606,30 @@ static int wlan_hdd_execute_remain_on_channel(hdd_adapter_t *pAdapter,
     cfgState->remain_on_chan_ctx = pRemainChanCtx;
     cfgState->current_freq = pRemainChanCtx->chan.center_freq;
     pAdapter->is_roc_inprogress = TRUE;
-    mutex_unlock(&cfgState->remain_on_chan_ctx_lock);
 
     /* Initialize Remain on chan timer */
+#ifdef CONFIG_CUST_PLATFORM
+    vos_status = vos_timer_init(&pRemainChanCtx->hdd_remain_on_chan_timer,
+                                VOS_TIMER_TYPE_SW,
+                                wlan_hdd_remain_on_chan_timeout,
+                                pRemainChanCtx);
+#else
     vos_status = vos_timer_init(&pRemainChanCtx->hdd_remain_on_chan_timer,
                                 VOS_TIMER_TYPE_SW,
                                 wlan_hdd_remain_on_chan_timeout,
                                 pAdapter);
+#endif
     if (vos_status != VOS_STATUS_SUCCESS)
     {
          hddLog(VOS_TRACE_LEVEL_ERROR,
              FL("Not able to initialize remain_on_chan timer"));
-         mutex_lock(&cfgState->remain_on_chan_ctx_lock);
          cfgState->remain_on_chan_ctx = NULL;
          pAdapter->is_roc_inprogress = FALSE;
-         mutex_unlock(&cfgState->remain_on_chan_ctx_lock);
          vos_mem_free(pRemainChanCtx);
+         mutex_unlock(&cfgState->remain_on_chan_ctx_lock);
          return -EINVAL;
     }
+    mutex_unlock(&cfgState->remain_on_chan_ctx_lock);
 
     status =  hdd_get_front_adapter ( pHddCtx, &pAdapterNode );
     while ( NULL != pAdapterNode && VOS_STATUS_SUCCESS == status )
@@ -637,9 +673,9 @@ static int wlan_hdd_execute_remain_on_channel(hdd_adapter_t *pAdapter,
             mutex_lock(&cfgState->remain_on_chan_ctx_lock);
             cfgState->remain_on_chan_ctx = NULL;
             pAdapter->is_roc_inprogress = FALSE;
-            mutex_unlock(&cfgState->remain_on_chan_ctx_lock);
 	    vos_timer_destroy(&pRemainChanCtx->hdd_remain_on_chan_timer);
             vos_mem_free(pRemainChanCtx);
+            mutex_unlock(&cfgState->remain_on_chan_ctx_lock);
             vos_runtime_pm_allow_suspend(pHddCtx->runtime_context.roc);
             hdd_allow_suspend(WIFI_POWER_EVENT_WAKELOCK_ROC);
             return -EINVAL;
@@ -673,9 +709,9 @@ static int wlan_hdd_execute_remain_on_channel(hdd_adapter_t *pAdapter,
            mutex_lock(&cfgState->remain_on_chan_ctx_lock);
            cfgState->remain_on_chan_ctx = NULL;
            pAdapter->is_roc_inprogress = FALSE;
-           mutex_unlock(&cfgState->remain_on_chan_ctx_lock);
 	   vos_timer_destroy(&pRemainChanCtx->hdd_remain_on_chan_timer);
            vos_mem_free (pRemainChanCtx);
+           mutex_unlock(&cfgState->remain_on_chan_ctx_lock);
            vos_runtime_pm_allow_suspend(pHddCtx->runtime_context.roc);
            hdd_allow_suspend(WIFI_POWER_EVENT_WAKELOCK_ROC);
            return -EINVAL;
@@ -921,6 +957,9 @@ static int wlan_hdd_request_remain_on_channel( struct wiphy *wiphy,
     pRemainChanCtx->action_pkt_buff.frame_ptr = NULL;
     pRemainChanCtx->action_pkt_buff.frame_length = 0;
     pRemainChanCtx->hdd_remain_on_chan_cancel_in_progress = FALSE;
+#ifdef CONFIG_CUST_PLATFORM
+    pRemainChanCtx->pAdapter = pAdapter;
+#endif
 
     if (REMAIN_ON_CHANNEL_REQUEST == request_type) {
         sta_adapter = hdd_get_adapter(pHddCtx, WLAN_HDD_INFRA_STATION);
@@ -955,7 +994,6 @@ static int wlan_hdd_request_remain_on_channel( struct wiphy *wiphy,
                 return -EAGAIN;
             }
         }
-        return 0;
     } else {
         if (wlan_hdd_roc_request_enqueue(pAdapter, pRemainChanCtx)) {
             vos_mem_free(pRemainChanCtx);
@@ -975,7 +1013,12 @@ static int wlan_hdd_request_remain_on_channel( struct wiphy *wiphy,
     if (isBusy == VOS_FALSE && pAdapter->is_roc_inprogress == false) {
         hddLog(LOG1, FL("scheduling delayed work: no connection/roc active"));
         schedule_delayed_work(&pHddCtx->rocReqWork, 0);
+    } else {
+       /* when there are reuqest, we schedule one no mater how.
+          we drop the work during the execution if this is not needed */
+       schedule_delayed_work(&pHddCtx->rocReqWork, msecs_to_jiffies(2000));
     }
+
     EXIT();
     return 0;
 }
@@ -1413,14 +1456,17 @@ int __wlan_hdd_mgmt_tx(struct wiphy *wiphy, struct net_device *dev,
         if(actionFrmType >= MAX_P2P_ACTION_FRAME_TYPE)
         {
             hddLog(VOS_TRACE_LEVEL_ERROR,"[P2P] unknown[%d] ---> OTA to "
-                   MAC_ADDRESS_STR, actionFrmType,
-                   MAC_ADDR_ARRAY(&buf[WLAN_HDD_80211_FRM_DA_OFFSET]));
+                   MAC_ADDRESS_STR "at channel %d", actionFrmType,
+                   MAC_ADDR_ARRAY(&buf[WLAN_HDD_80211_FRM_DA_OFFSET]),
+                   ieee80211_frequency_to_channel(chan->center_freq));
         }
         else
         {
             hddLog(VOS_TRACE_LEVEL_ERROR,"[P2P] %s ---> OTA to "
-                   MAC_ADDRESS_STR, p2p_action_frame_type[actionFrmType],
-                   MAC_ADDR_ARRAY(&buf[WLAN_HDD_80211_FRM_DA_OFFSET]));
+                   MAC_ADDRESS_STR "at channel %d", p2p_action_frame_type[actionFrmType],
+                   MAC_ADDR_ARRAY(&buf[WLAN_HDD_80211_FRM_DA_OFFSET]),
+                   ieee80211_frequency_to_channel(chan->center_freq));
+
             if( (actionFrmType == WLAN_HDD_PROV_DIS_REQ) &&
                 (globalP2PConnectionStatus == P2P_NOT_ACTIVE) )
             {
@@ -2433,6 +2479,55 @@ int wlan_hdd_del_virtual_intf(struct wiphy *wiphy, struct net_device *dev)
 
     return ret;
 }
+#ifdef CONFIG_CUST_PLATFORM
+#define NegochktableSize 32
+typedef struct {
+    u32 timestamp;
+    u8 macFrom[6];
+    u16 negoreq_sn;
+} NegoReqchk, *pNegoReqchk;
+
+#define TimeDiff(x,y) (x) > (y) ? ((x)-(y)):(0xFFFFFFFF-(y)+(x)+1)
+NegoReqchk negoreqchktable[NegochktableSize];
+bool hdd_checkNegoReqFrameSN(u8 *macFrom, u16 negoreq_sn)
+{
+    int i = 0;
+    u32 oldesttime = 0xffffffff;
+    u32 oldestidx = 0;
+    u32 currenttime = adf_os_gettimestamp();
+    static int init_done = 0;
+    if (!init_done) {
+        memset(negoreqchktable,0, sizeof(negoreqchktable));
+        init_done = 1;
+    }
+    //search match peer through all table
+    for (i = 0 ; i < NegochktableSize ; i++) {
+        //let nego request pass only if SN is not equal or over 10 seconds
+        if (vos_mem_compare(&negoreqchktable[i].macFrom, macFrom, 6)) {
+            if ((negoreq_sn != negoreqchktable[i].negoreq_sn) ||
+               (TimeDiff(currenttime,negoreqchktable[i].timestamp)) > (10*1000*1000)) {
+                negoreqchktable[i].negoreq_sn = negoreq_sn;
+                negoreqchktable[i].timestamp = currenttime;
+                return TRUE;
+            }
+            else
+                return FALSE;
+        }
+    }
+
+    //pop the oldest one if no match peer in table
+    for (i = 0 ; i < NegochktableSize ; i++) {
+        if (negoreqchktable[i].timestamp < oldesttime) {
+            oldesttime = negoreqchktable[i].timestamp;
+            oldestidx = i;
+        }
+    }
+    memcpy( negoreqchktable[oldestidx].macFrom, macFrom, 6);
+    negoreqchktable[oldestidx].negoreq_sn = negoreq_sn;
+    negoreqchktable[oldestidx].timestamp = currenttime;
+    return TRUE;
+}
+#endif
 
 void __hdd_indicate_mgmt_frame(hdd_adapter_t *pAdapter,
                             tANI_U32 nFrameLength,
@@ -2547,19 +2642,30 @@ void __hdd_indicate_mgmt_frame(hdd_adapter_t *pAdapter,
                 u8 *macFrom = &pbFrames[WLAN_HDD_80211_FRM_DA_OFFSET+6];
                 actionFrmType = pbFrames[WLAN_HDD_PUBLIC_ACTION_FRAME_TYPE_OFFSET];
                 hddLog(LOG1, "Rx Action Frame %u", actionFrmType);
+#ifdef CONFIG_CUST_PLATFORM
+                if (nFrameLength > 23) {
+                     u16 mgmt_sn = (u16) ((pbFrames[23]<<8|pbFrames[22])>>4);
+
+                     if (actionFrmType == WLAN_HDD_GO_NEG_REQ &&
+                          hdd_checkNegoReqFrameSN(macFrom, mgmt_sn) == FALSE) {
+                             printk(KERN_ERR "same SN %d from Peer %pM, drop it\n", mgmt_sn, macFrom);
+                             return;
+                     }
+                }
+#endif
 #ifdef WLAN_FEATURE_P2P_DEBUG
                 if(actionFrmType >= MAX_P2P_ACTION_FRAME_TYPE)
                 {
                     hddLog(VOS_TRACE_LEVEL_ERROR,"[P2P] unknown[%d] <--- OTA"
-                           " from " MAC_ADDRESS_STR, actionFrmType,
-                           MAC_ADDR_ARRAY(macFrom));
+                           " from " MAC_ADDRESS_STR " at channel %d", actionFrmType,
+                           MAC_ADDR_ARRAY(macFrom), rxChan);
                 }
                 else
                 {
                     hddLog(VOS_TRACE_LEVEL_ERROR,"[P2P] %s <--- OTA"
-                           " from " MAC_ADDRESS_STR,
+                           " from " MAC_ADDRESS_STR "at channel %d",
                            p2p_action_frame_type[actionFrmType],
-                           MAC_ADDR_ARRAY(macFrom));
+                           MAC_ADDR_ARRAY(macFrom), rxChan);
                     if( (actionFrmType == WLAN_HDD_PROV_DIS_REQ) &&
                         (globalP2PConnectionStatus == P2P_NOT_ACTIVE) )
                     {
diff --git a/CORE/HDD/src/wlan_hdd_scan.c b/CORE/HDD/src/wlan_hdd_scan.c
index 83d8871..1ca4759 100644
--- a/CORE/HDD/src/wlan_hdd_scan.c
+++ b/CORE/HDD/src/wlan_hdd_scan.c
@@ -804,6 +804,11 @@ static int __iw_get_scan(struct net_device *dev,
    VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO, "%s: enter buffer length %d!!!",
        __func__, (wrqu->data.length)?wrqu->data.length:IW_SCAN_MAX_DATA);
 
+   if (NULL == extra) {
+       VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,"%s: NULL extra", __func__);
+       return -EINVAL;
+   }
+
    if (TRUE == pAdapter->scan_info.mScanPending)
    {
        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL, "%s:mScanPending is TRUE !!!",__func__);
diff --git a/CORE/HDD/src/wlan_hdd_softap_tx_rx.c b/CORE/HDD/src/wlan_hdd_softap_tx_rx.c
index e277a12..9a0cd1e 100644
--- a/CORE/HDD/src/wlan_hdd_softap_tx_rx.c
+++ b/CORE/HDD/src/wlan_hdd_softap_tx_rx.c
@@ -220,6 +220,11 @@ void hdd_softap_tx_resume_cb(void *adapter_context,
 }
 #endif /* QCA_LL_TX_FLOW_CT */
 
+#ifdef CONFIG_CONTX_USB_DEBUG
+extern int txkeeprun;
+extern int txkeepruntoofast;
+#endif
+
 /**============================================================================
   @brief hdd_softap_hard_start_xmit() - Function registered with the Linux OS
                                         for transmitting packets.
@@ -342,6 +347,12 @@ int __hdd_softap_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
                hddLog(LOG1, FL("Disabling queues"));
                wlan_hdd_netif_queue_control(pAdapter, WLAN_STOP_ALL_NETIF_QUEUE,
                            WLAN_DATA_FLOW_CONTROL);
+#ifdef CONFIG_CONTX_USB_DEBUG
+              if (txkeeprun) {
+	            	  txkeepruntoofast = 1;
+                  pr_err("contx too fast, slow down\n");
+              }
+#endif
                vos_timer_start(&pAdapter->tx_flow_control_timer,
                                WLAN_SAP_HDD_TX_FLOW_CONTROL_OS_Q_BLOCK_TIME);
                pAdapter->hdd_stats.hddTxRxStats.txflow_timer_cnt++;
@@ -776,6 +787,9 @@ VOS_STATUS hdd_softap_deinit_tx_rx_sta ( hdd_adapter_t *pAdapter, v_U8_t STAId )
   @return                : VOS_STATUS_E_FAILURE if any errors encountered,
                          : VOS_STATUS_SUCCESS otherwise
   ===========================================================================*/
+#ifdef DIRECT_AUDIO_SUPPORT
+extern void SDA_Rx_fun( struct net_device *dev, struct sk_buff *skb);
+#endif
 VOS_STATUS hdd_softap_rx_packet_cbk(v_VOID_t *vosContext,
                                     adf_nbuf_t rxBuf, v_U8_t staId)
 {
@@ -854,6 +868,13 @@ VOS_STATUS hdd_softap_rx_packet_cbk(v_VOID_t *vosContext,
 
       skb->protocol = eth_type_trans(skb, skb->dev);
 
+#ifdef DIRECT_AUDIO_SUPPORT
+#define DIRECT_AUDIO_LLC_TYPE 0x43FF
+        if (skb->protocol == cpu_to_be16(DIRECT_AUDIO_LLC_TYPE)) {
+           SDA_Rx_fun(pAdapter->dev, skb);
+           rxstat = NET_RX_SUCCESS;
+        } else {
+#endif
       /*
        * If this is not a last packet on the chain
        * Just put packet into backlog queue, not scheduling RX sirq
@@ -872,6 +893,9 @@ VOS_STATUS hdd_softap_rx_packet_cbk(v_VOID_t *vosContext,
           */
          rxstat = netif_rx_ni(skb);
       }
+#ifdef DIRECT_AUDIO_SUPPORT
+      }
+#endif
 
       if (NET_RX_SUCCESS == rxstat)
          ++pAdapter->hdd_stats.hddTxRxStats.rxDelivered[cpu_index];
diff --git a/CORE/HDD/src/wlan_hdd_tx_rx.c b/CORE/HDD/src/wlan_hdd_tx_rx.c
index f86e99f..4ee7adf 100644
--- a/CORE/HDD/src/wlan_hdd_tx_rx.c
+++ b/CORE/HDD/src/wlan_hdd_tx_rx.c
@@ -1165,6 +1165,9 @@ VOS_STATUS hdd_mon_rx_packet_cbk(v_VOID_t *vos_ctx, adf_nbuf_t rx_buf,
   @return                : VOS_STATUS_E_FAILURE if any errors encountered,
                          : VOS_STATUS_SUCCESS otherwise
   ===========================================================================*/
+#ifdef DIRECT_AUDIO_SUPPORT
+extern void SDA_Rx_fun( struct net_device *dev, struct sk_buff *skb);
+#endif
 VOS_STATUS hdd_rx_packet_cbk(v_VOID_t *vosContext,
                              adf_nbuf_t rxBuf, v_U8_t staId)
 {
@@ -1266,6 +1269,13 @@ VOS_STATUS hdd_rx_packet_cbk(v_VOID_t *vosContext,
       ++pAdapter->stats.rx_packets;
       pAdapter->stats.rx_bytes += skb->len;
 
+#ifdef DIRECT_AUDIO_SUPPORT
+#define DIRECT_AUDIO_LLC_TYPE 0x43FF
+      if (skb->protocol == cpu_to_be16(DIRECT_AUDIO_LLC_TYPE)) {
+         SDA_Rx_fun(pAdapter->dev, skb);
+         rxstat = NET_RX_SUCCESS;
+      } else {
+#endif
       /*
        * If this is not a last packet on the chain
        * Just put packet into backlog queue, not scheduling RX sirq
@@ -1284,6 +1294,9 @@ VOS_STATUS hdd_rx_packet_cbk(v_VOID_t *vosContext,
           */
          rxstat = netif_rx_ni(skb);
       }
+#ifdef DIRECT_AUDIO_SUPPORT
+      }
+#endif
 
       if (NET_RX_SUCCESS == rxstat)
          ++pAdapter->hdd_stats.hddTxRxStats.rxDelivered[cpu_index];
diff --git a/CORE/HDD/src/wlan_hdd_wext.c b/CORE/HDD/src/wlan_hdd_wext.c
index fd738da..7e9a17f 100644
--- a/CORE/HDD/src/wlan_hdd_wext.c
+++ b/CORE/HDD/src/wlan_hdd_wext.c
@@ -243,6 +243,12 @@ static const hdd_freq_chan_map_t freq_chan_map[] = { {2412, 1}, {2417, 2},
 #define WE_DUMP_STATS                         85
 #define WE_CLEAR_STATS                        86
 #define WE_SET_CHANNEL                        87
+#ifdef CONFIG_WLAN_FWLOG_FILE
+#define WE_DBGLOG_FWLOG_FILE_ENABLE           88
+#define WE_DBGLOG_FWLOG_FILE_MAX_SIZE         89
+#endif
+#define WE_SET_DIRECT_AUDIO_TEST              90
+#define WE_USB_CONTX_DEBUG                    91
 
 
 /* Private ioctls and their sub-ioctls */
@@ -305,6 +311,8 @@ static const hdd_freq_chan_map_t freq_chan_map[] = { {2412, 1}, {2417, 2},
 #define WE_GET_TEMPERATURE              56
 #define WE_GET_FW_STATUS                57
 #define WE_CAP_TSF                      58
+/* continue usb */
+#define WE_GET_USB_CONTX_DEBUG          59
 
 /* Private ioctls and their sub-ioctls */
 #define WLAN_PRIV_SET_INT_GET_INT     (SIOCIWFIRSTPRIV + 2)
@@ -6131,6 +6139,45 @@ VOS_STATUS wlan_hdd_get_temperature(hdd_adapter_t *pAdapter,
     return VOS_STATUS_SUCCESS;
 }
 
+#ifdef DIRECT_AUDIO_SUPPORT
+extern int Direct_Audio_TX_debug(unsigned int usbdbgtxtime);
+extern int Direct_Audio_RX_debug(void);
+#ifdef CONFIG_CONTX_USB_DEBUG
+int txkeeprun=0;
+int txkeepruntoofast=0;
+int txkeepruntoofastseriously=0;
+#define CONTX_LOOP_TIMEMS 20
+int txkeepcountmax=2147483647;
+extern int SDA_CONTX_COUNT_RESET(void);
+extern int SDA_CONTX_COUNT_RESULT(char *, A_UINT8 wait_loop);
+struct work_struct sda_contx_work;
+int init_sda_work=0;
+struct completion completion_usbcontx;
+static void sda_contx_work_item(struct work_struct *work)
+{
+		int transmit_count = txkeepcountmax;
+        while (txkeeprun && transmit_count > 0){
+                Direct_Audio_TX_debug(1);
+                transmit_count -= 32;
+                if (txkeepruntoofast) {
+                        yield();
+                        msleep(30);
+                        txkeepruntoofast = 0;
+                }
+                if (txkeepruntoofastseriously) {
+                        yield();
+                        msleep(1000);
+                        txkeepruntoofastseriously = 0;
+                        pr_err("USB contx run too fast, cause seriously delay\n");
+                }
+
+        }
+        complete(&completion_usbcontx);
+}
+
+#endif /* CONFIG_CONTX_USB_DEBUG */
+#endif /* DIRECT_AUDIO_SUPPORT */
+
 /* set param sub-ioctls */
 static int __iw_setint_getnone(struct net_device *dev,
                                struct iw_request_info *info,
@@ -6981,6 +7028,27 @@ static int __iw_setint_getnone(struct net_device *dev,
              break;
         }
 
+#ifdef CONFIG_WLAN_FWLOG_FILE
+        case WE_DBGLOG_FWLOG_FILE_ENABLE:
+        {
+             hddLog(LOG1, "WE_DBGLOG_FWLOG_FILE_ENABLE val %d", set_value);
+             pHddCtx->fw_log_settings.dl_fwlog_file = set_value;
+             ret = process_wma_set_command((int)pAdapter->sessionId,
+                                          (int)WMI_DBGLOG_FWLOG_FILE_ENABLE,
+                                          set_value, DBG_CMD);
+             break;
+        }
+        case WE_DBGLOG_FWLOG_FILE_MAX_SIZE:
+        {
+             hddLog(LOG1, "WE_DBGLOG_FWLOG_FILE_MAX_SIZE val %d", set_value);
+             pHddCtx->fw_log_settings.dl_fwlog_file_max_size = set_value;
+             ret = process_wma_set_command((int)pAdapter->sessionId,
+                                          (int)WMI_DBGLOG_FWLOG_FILE_MAX_SIZE,
+                                          set_value, DBG_CMD);
+             break;
+        }
+#endif
+
     case WE_SET_TXRX_FWSTATS:
     {
            hddLog(LOG1, "WE_SET_TXRX_FWSTATS val %d", set_value);
@@ -7376,6 +7444,20 @@ static int __iw_setint_getnone(struct net_device *dev,
           }
           break;
         }
+#ifdef DIRECT_AUDIO_SUPPORT
+        case WE_SET_DIRECT_AUDIO_TEST:
+        {
+           hddLog(LOGW, "%s: Try Direct_Audiofunction %s\n",
+                      __func__, set_value ? "TX" : "RX");
+
+           if (set_value) {
+               ret = Direct_Audio_TX_debug(0);
+           } else {
+               ret = Direct_Audio_RX_debug();
+           }
+           break;
+        }
+#endif /* DIRECT_AUDIO_SUPPORT */
         default:
         {
            hddLog(LOGE, "%s: Invalid sub command %d", __func__, sub_cmd);
@@ -8672,6 +8754,37 @@ static int __iw_get_char_setnone(struct net_device *dev,
             wrqu->data.length = strlen(extra) + 1;
             break;
         }
+#if defined(CONFIG_CONTX_USB_DEBUG) && defined(DIRECT_AUDIO_SUPPORT)
+        case WE_GET_USB_CONTX_DEBUG:
+        {
+            hddLog(LOGW, "%s: USB_CONTX for 20000 packets\n", __func__);
+
+            SDA_CONTX_COUNT_RESET();
+
+            txkeeprun = 1;
+            txkeepcountmax = 20000;
+            init_completion(&completion_usbcontx);
+
+            if(!init_sda_work) {
+            	init_sda_work = 1;
+            	INIT_WORK(&sda_contx_work, sda_contx_work_item);
+            }
+
+            schedule_work(&sda_contx_work);
+
+            wait_for_completion_timeout(&completion_usbcontx,
+                                         msecs_to_jiffies(100000));
+
+            msleep(1000);  //wait for qued data to flush
+            SDA_CONTX_COUNT_RESULT(extra, 10);
+            txkeeprun = 0;
+            txkeepcountmax = 2147483647;
+
+            wrqu->data.length = strnlen(extra, WE_MAX_STR_LEN-1)+1;
+            break;
+        }
+
+#endif /* CONFIG_CONTX_USB_DEBUG */
         default:
         {
             hddLog(LOGE, "%s: Invalid IOCTL command %d", __func__, sub_cmd );
@@ -11909,6 +12022,13 @@ static const struct iw_priv_args we_private_args[] = {
         IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
         0, "erx_dri_sample" },
 
+#ifdef DIRECT_AUDIO_SUPPORT
+    {   WE_SET_DIRECT_AUDIO_TEST,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+        0, "aow" },
+
+#endif
+
     {   WLAN_PRIV_SET_NONE_GET_INT,
         0,
         IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
@@ -12569,6 +12689,26 @@ static const struct iw_priv_args we_private_args[] = {
         IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2,
         0, "crash_inject" },
 #endif
+#ifdef CONFIG_WLAN_FWLOG_FILE
+    {   WE_DBGLOG_FWLOG_FILE_ENABLE,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+        0,
+        "dl_fwlog_file" },
+    {   WE_DBGLOG_FWLOG_FILE_MAX_SIZE,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+        0,
+        "dl_fwlog_size" },
+#endif
+#ifdef CONFIG_CONTX_USB_DEBUG
+    {   WE_USB_CONTX_DEBUG,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+        0,
+        "setusbcontx" },
+    {   WE_GET_USB_CONTX_DEBUG,
+        0,
+        IW_PRIV_TYPE_CHAR| WE_MAX_STR_LEN,
+        "getusbcontx" },
+#endif
     {   WE_SET_MON_MODE_CHAN,
         IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2,
         0, "setMonChan" },
diff --git a/CORE/MAC/inc/sirApi.h b/CORE/MAC/inc/sirApi.h
index c4b2bfc..e8d106e 100644
--- a/CORE/MAC/inc/sirApi.h
+++ b/CORE/MAC/inc/sirApi.h
@@ -3617,7 +3617,8 @@ typedef enum ext_wow_type
     EXT_WOW_TYPE_APP_TYPE1, /* wow type: only enable wakeup for app type1 */
     EXT_WOW_TYPE_APP_TYPE2, /* wow type: only enable wakeup for app type2 */
     EXT_WOW_TYPE_APP_TYPE1_2, /* wow type: enable wakeup for app type1&2 */
-
+    EXT_WOW_TYPE_APP_PULSETEST,
+    EXT_WOW_DISABLED = 255, /* wow type: only enable wakeup for app type1 */
 }EXT_WOW_TYPE;
 
 typedef struct
@@ -3625,18 +3626,97 @@ typedef struct
     tANI_U8 vdev_id;
     EXT_WOW_TYPE type;
     tANI_U32 wakeup_pin_num;
+    tANI_U8 swol_pulsetest_type;
+    tANI_U8 swol_pulsetest_application;
 } tSirExtWoWParams, *tpSirExtWoWParams;
 
 typedef struct
 {
     tANI_U8 vdev_id;
-    tSirMacAddr wakee_mac_addr;
     tANI_U8 identification_id[8];
     tANI_U8 password[16];
     tANI_U32 id_length;
     tANI_U32 pass_length;
+
+    tANI_U8 swol_indoor_wakee[6];
+    tANI_U8 swol_indoor_key[8][16];
+    tANI_U8 swol_indoor_key_len[8];
+    tANI_U8 swol_indoor_key_mac[8][6];
+    tANI_U32 swol_indoor_app_mask[8];
+    tANI_U8 swol_indoor_waker_check;
+    tANI_U8 swol_indoor_pw_check;
+    tANI_U8 swol_indoor_pattern;
+    tANI_U8 swol_indoor_exception;
+    tANI_U8 swol_indoor_exception_app;
+    tANI_U8 swol_assist_enable;
 } tSirAppType1Params, *tpSirAppType1Params;
 
+/*SWOW waker used format*/
+struct waker{
+    u8 key_mac[6];
+    u8 key_len;
+    u8 key[16]; //Hex format
+    u32 app_mask;
+};
+
+struct ioctl_priv_params {
+    u16 cmd_id; //Mapping to "enum ioctl_priv_cmds"
+    u16 cmd_len;//Read or Write length
+    union {
+    /*Structure of SWOW USED*/
+        struct {
+            u8 cmd;
+            char* arp_ip_addr;
+        } swow_start;       //IOCTL_PRIV_SWOW_START
+
+        struct {
+            u8 waker_id;
+            struct waker write_waker;
+        } swow_waker_w;     //IOCTL_PRIV_SWOW_WAKER_W
+
+        struct {
+            struct waker read_waker[8];
+        } swow_waker_r;     //IOCTL_PRIV_SWOW_WAKER_R
+
+        struct {
+            u8 exception;
+            u8 exception_app;
+        } swow_exception;       //IOCTL_PRIV_SWOW_EXCEPTION_W & IOCTL_PRIV_SWOW_EXCEPTION_R
+
+        struct {
+            u8 pattern;
+        } swow_pattern;       //IOCTL_PRIV_SWOW_PATTEN_W & IOCTL_PRIV_SWOW_PATTEN_R
+
+        struct {
+            u8 waker_check;
+            u8 pw_check;
+        } swow_filter;       //IOCTL_PRIV_SWOW_FILTER_W & IOCTL_PRIV_SWOW_FILTER_R
+
+        struct {
+            u8 type;
+            u8 app;
+        } swow_pulse_test;   //IOCTL_PRIV_SWOW_PULSE_TEST
+        struct {
+            u8 enable;
+        } swow_assist;       //IOCTL_PRIV_SWOW_ASSISTANT
+    } params;
+} __packed;
+
+enum ioctl_priv_cmds
+{
+    IOCTL_PRIV_SWOW_START       = 33,//Write of swow_start
+    IOCTL_PRIV_SWOW_WAKER_W     = 34,//Write of swow_waker
+    IOCTL_PRIV_SWOW_WAKER_R     = 35,//Read of swow_waker
+    IOCTL_PRIV_SWOW_EXCEPTION_W = 36,//Write of swow_exception
+    IOCTL_PRIV_SWOW_EXCEPTION_R = 37,//Read of swow_exception
+    IOCTL_PRIV_SWOW_PATTEN_W    = 38,//Write of swow_pattern
+    IOCTL_PRIV_SWOW_PATTEN_R    = 39,//Read of swow_pattern
+    IOCTL_PRIV_SWOW_FILTER_W    = 40,//Write of swow_filter
+    IOCTL_PRIV_SWOW_FILTER_R    = 41,//Read of swow_filter
+    IOCTL_PRIV_SWOW_PULSE_TEST  = 42,//Write of swow_pulse_test
+    IOCTL_PRIV_SWOW_ASSISTANT   = 43,//Write of enable_assist
+};
+
 typedef struct
 {
     tANI_U8 vdev_id;
diff --git a/CORE/MAC/src/pe/lim/limUtils.c b/CORE/MAC/src/pe/lim/limUtils.c
index 156c2c7..bfed2fe 100644
--- a/CORE/MAC/src/pe/lim/limUtils.c
+++ b/CORE/MAC/src/pe/lim/limUtils.c
@@ -7097,9 +7097,15 @@ v_U8_t* limGetIEPtr(tpAniSirGlobal pMac, v_U8_t *pIes, int length, v_U8_t eid,eS
         left -= (size_of_len_field+1);
         if(elem_len > left)
         {
+#ifdef CONFIG_CUST_PLATFORM
+            limLog(pMac, LOGW,
+                    FL("****Invalid IEs eid = %d elem_len=%d left=%d*****"),
+                                                    eid,elem_len,left);
+#else
             limLog(pMac, LOGE,
                     FL("****Invalid IEs eid = %d elem_len=%d left=%d*****"),
                                                     eid,elem_len,left);
+#endif
             return NULL;
         }
         if (elem_id == eid)
diff --git a/CORE/SAP/src/sapFsm.c b/CORE/SAP/src/sapFsm.c
index 6cd052b..aba9501 100644
--- a/CORE/SAP/src/sapFsm.c
+++ b/CORE/SAP/src/sapFsm.c
@@ -2819,6 +2819,26 @@ sapSignalHDDevent
                          pCsrRoamInfo->peerMac,sizeof(tSirMacAddr));
             sapApAppEvent.sapevt.sapStationAssocReassocCompleteEvent.staId = pCsrRoamInfo->staId ;
             sapApAppEvent.sapevt.sapStationAssocReassocCompleteEvent.statusCode = pCsrRoamInfo->statusCode;
+#ifdef CONFIG_CUST_PLATFORM
+            if ((pCsrRoamInfo->assocReqLength > 4) && pCsrRoamInfo->assocReqPtr) {
+                vos_mem_copy(sapApAppEvent.sapevt.sapStationAssocReassocCompleteEvent.ies, pCsrRoamInfo->assocReqPtr + 4,
+                             pCsrRoamInfo->assocReqLength-4);
+                sapApAppEvent.sapevt.sapStationAssocReassocCompleteEvent.iesLen = pCsrRoamInfo->assocReqLength - 4;
+            } else {
+                sapApAppEvent.sapevt.sapStationAssocReassocCompleteEvent.iesLen = pCsrRoamInfo->rsnIELen;
+                vos_mem_copy(sapApAppEvent.sapevt.sapStationAssocReassocCompleteEvent.ies, pCsrRoamInfo->prsnIE,
+                             pCsrRoamInfo->rsnIELen);
+
+                if(pCsrRoamInfo->addIELen)
+                {
+                    v_U8_t  len = sapApAppEvent.sapevt.sapStationAssocReassocCompleteEvent.iesLen;
+                    sapApAppEvent.sapevt.sapStationAssocReassocCompleteEvent.iesLen
+                                                            += pCsrRoamInfo->addIELen;
+                    vos_mem_copy(&sapApAppEvent.sapevt.sapStationAssocReassocCompleteEvent.ies[len], pCsrRoamInfo->paddIE,
+                                 pCsrRoamInfo->addIELen);
+                }
+            }
+#else
             sapApAppEvent.sapevt.sapStationAssocReassocCompleteEvent.iesLen = pCsrRoamInfo->rsnIELen;
             vos_mem_copy(sapApAppEvent.sapevt.sapStationAssocReassocCompleteEvent.ies, pCsrRoamInfo->prsnIE,
                         pCsrRoamInfo->rsnIELen);
@@ -2843,6 +2863,7 @@ sapSignalHDDevent
                 vos_mem_copy(&sapApAppEvent.sapevt.sapStationAssocReassocCompleteEvent.ies[len], pCsrRoamInfo->paddIE,
                             pCsrRoamInfo->addIELen);
             }
+#endif
 
             /* also fill up the channel info from the csrRoamInfo */
             pChanInfo =
diff --git a/CORE/SERVICES/BMI/ol_fw.c b/CORE/SERVICES/BMI/ol_fw.c
index 7b194ba..8a249f3 100644
--- a/CORE/SERVICES/BMI/ol_fw.c
+++ b/CORE/SERVICES/BMI/ol_fw.c
@@ -1177,6 +1177,315 @@ void ol_schedule_fw_indication_work(struct ol_softc *scn)
 A_UINT32 fw_stack_addr;
 void *fw_ram_seg_addr[FW_RAM_SEG_CNT];
 
+#if defined(CONFIG_CRASH_DUMP_CLD) || defined(CONFIG_WLAN_FWLOG_FILE)
+
+#define GET_INODE_FROM_FILEP(filp) ((filp)->f_path.dentry->d_inode)
+
+int _readwrite_file(const char *filename, char *rbuf,
+	const char *wbuf, size_t length, int mode)
+{
+	int ret = 0;
+	struct file *filp = (struct file *)-ENOENT;
+	mm_segment_t oldfs;
+	oldfs = get_fs();
+	set_fs(KERNEL_DS);
+
+	do {
+		filp = filp_open(filename, mode, S_IRUSR);
+
+		if (IS_ERR(filp) || !filp->f_op) {
+			ret = -ENOENT;
+			break;
+		}
+
+		if (!filp->f_op->write || !filp->f_op->read) {
+			filp_close(filp, NULL);
+			ret = -ENOENT;
+			break;
+		}
+
+		if (length == 0) {
+			/* Read the length of the file only */
+			struct inode    *inode;
+
+			inode = GET_INODE_FROM_FILEP(filp);
+			if (!inode) {
+				printk(KERN_ERR
+					"_readwrite_file: Error 2\n");
+				ret = -ENOENT;
+				break;
+			}
+			ret = i_size_read(inode->i_mapping->host);
+			break;
+		}
+
+		if (wbuf) {
+			ret = filp->f_op->write(
+				filp, wbuf, length, &filp->f_pos);
+			if (ret < 0) {
+				printk(KERN_ERR
+					"_readwrite_file: Error 3\n");
+				break;
+			}
+		} else {
+			ret = filp->f_op->read(
+				filp, rbuf, length, &filp->f_pos);
+			if (ret < 0) {
+				printk(KERN_ERR
+					"_readwrite_file: Error 4\n");
+				break;
+			}
+		}
+	} while (0);
+
+	if (!IS_ERR(filp))
+		filp_close(filp, NULL);
+
+	set_fs(oldfs);
+	return ret;
+}
+
+#ifdef CONFIG_CRASH_DUMP_CLD
+#define DUMP_BUF_SIZE 255*1024
+
+#define CRASH_DUMP_PATH "/opt/var/log/"
+#define CRASH_DUMP_FILE "/opt/var/log/cld_fwcrash.log"
+
+static void crash_dump_file_init(const char* filename)
+{
+	int ret;
+
+	ret = _readwrite_file(filename, NULL,
+	                NULL, 0, (O_WRONLY | O_CREAT | O_TRUNC));
+	if (ret < 0) {
+		printk("%s:%d: fail to write\n", __func__, __LINE__);
+	}
+
+}
+static void crash_dump_flush(const char* filename, char* buf, unsigned int len)
+{
+	int ret;
+	ret = _readwrite_file(filename, NULL,
+	                      buf,
+	                      len,
+	                      (O_WRONLY | O_APPEND | O_CREAT));
+	if (ret < 0) {
+		printk("%s:%d: fail to write\n", __func__, __LINE__);
+	}
+}
+
+static void crash_dump_init(struct ol_softc *scn)
+{
+	/*
+           Reuse scn->ramdump[0] for FW_ASSERT_PATTERN
+	   and FW_REG_PATTERN to save memory.
+         */
+	scn->ramdump[0] = vos_mem_malloc(sizeof(struct fw_ramdump) +
+					DUMP_BUF_SIZE);
+	if (!scn->ramdump[0]) {
+		pr_err("Fail to allocate memory for ram dump");
+		VOS_BUG(0);
+	}
+	(scn->ramdump[0])->mem = (A_UINT8 *) (scn->ramdump[0] + 1);
+	(scn->ramdump[0])->length = 0;
+}
+
+static void crash_dump_write_buf(struct ol_softc *scn,char* buf, unsigned int len)
+{
+	A_UINT8 *ram_ptr = NULL;
+
+	if((DUMP_BUF_SIZE - (scn->ramdump[0])->length) < len) {
+		crash_dump_flush(CRASH_DUMP_FILE, (scn->ramdump[0])->mem, (scn->ramdump[0])->length);
+		(scn->ramdump[0])->length = 0;
+	}
+
+	ram_ptr = (scn->ramdump[0])->mem + (scn->ramdump[0])->length;
+
+	memcpy(ram_ptr, buf, len);
+	(scn->ramdump[0])->length += len;
+}
+
+static void crash_dump_write(struct ol_softc *scn, char* fmt, ...)
+{
+	unsigned int len;
+	A_UINT8 buf[128];
+	va_list args;
+
+	va_start(args, fmt);
+	len = vsnprintf(buf, sizeof(buf) - 1, fmt, args);
+	va_end(args);
+
+	return crash_dump_write_buf(scn, buf, len);
+}
+
+void dump_fw_crash_to_file(struct ol_softc *scn)
+{
+	A_UINT32 *reg, pattern, i;
+	A_UINT32 MSPId = 0, mSPId = 0, SIId = 0, CRMId = 0, len;
+	A_UINT8 *data;
+	A_UINT8 temp_buf[128];
+	int dumpcomplete = 0;
+	char fw_dump_filename[40];
+
+	data = scn->hif_sc->fw_data;
+	len = scn->hif_sc->fw_data_len;
+	pattern = *((A_UINT32 *) data);
+
+	if (pattern == FW_ASSERT_PATTERN) {
+		crash_dump_init(scn);
+		crash_dump_file_init(CRASH_DUMP_FILE);
+
+		MSPId = (scn->target_fw_version & 0xf0000000) >> 28;
+		mSPId = (scn->target_fw_version & 0xf000000) >> 24;
+		SIId = (scn->target_fw_version & 0xf00000) >> 20;
+		CRMId = scn->target_fw_version & 0x7fff;
+
+		pr_err("Firmware crash detected...\n");
+		pr_err("Host SW version: %s\n", QWLAN_VERSIONSTR);
+		pr_err("FW version: %d.%d.%d.%d", MSPId, mSPId, SIId, CRMId);
+
+		crash_dump_write(scn, "Firmware crash detected...\n");
+		crash_dump_write(scn, "Host SW version: %s\n", QWLAN_VERSIONSTR);
+		crash_dump_write(scn, "FW version: %d.%d.%d.%d\n", MSPId, mSPId, SIId, CRMId);
+
+		if (vos_is_load_unload_in_progress(VOS_MODULE_ID_VOSS, NULL)) {
+			printk(KERN_INFO "%s: Loading/Unloading is in progress, ignore!\n",
+				__func__);
+			return;
+		}
+		reg = (A_UINT32 *) (data + 4);
+		for (i = 0; i < min_t(A_UINT32, len - 4, FW_REG_DUMP_CNT); i += 4) {
+			memset(temp_buf, 0, sizeof(temp_buf));
+			hex_dump_to_buffer(reg+i, 16, 16, 4, temp_buf, sizeof(temp_buf), false);
+			crash_dump_write(scn, "%#08x: %s\n", i*4, temp_buf);
+		}
+		print_hex_dump(KERN_DEBUG, " ", DUMP_PREFIX_OFFSET, 16, 4, reg,
+				min_t(A_UINT32, len - 4, FW_REG_DUMP_CNT * 4),
+				false);
+		scn->fw_ram_dumping = 0;
+
+		if (scn->enableFwSelfRecovery)
+			vos_set_logp_in_progress(VOS_MODULE_ID_VOSS, TRUE);
+	}
+#ifdef CONFIG_CRASH_DUMP_STACK
+	else if (pattern == FW_REG_PATTERN) {
+		A_UINT32 start_addr = 0;
+		reg = (A_UINT32 *) (data + 4);
+		start_addr = *reg++;
+
+		if (scn->fw_ram_dumping == 0) {
+			pr_err("Firmware stack dump:");
+			crash_dump_write(scn, "Firmware stack dump:\n");
+			scn->fw_ram_dumping = 1;
+			fw_stack_addr = start_addr;
+		}
+		/* len is in byte, but it's printed in double-word. */
+		for (i = 0; i < (len - 8); i += 16) {
+			if ((*reg == FW_REG_END_PATTERN) && (i == len - 12)) {
+				scn->fw_ram_dumping = 0;
+				pr_err("Stack start address = %#08x\n", fw_stack_addr);
+
+				crash_dump_write(scn, "Stack start address = %#08x\n",
+					fw_stack_addr);
+				crash_dump_flush(CRASH_DUMP_FILE, (scn->ramdump[0])->mem, (scn->ramdump[0])->length);
+				vos_mem_free(scn->ramdump[0]);
+				break;
+			}
+
+			memset(temp_buf, 0, sizeof(temp_buf));
+			hex_dump_to_buffer(reg, 16, 16, 4, temp_buf,
+						sizeof(temp_buf), false);
+
+			crash_dump_write(scn,"%#08x: %s\n", start_addr + i, temp_buf);
+			//pr_err("%#08x: %s\n", start_addr + i, temp_buf);
+
+			reg += 4;
+		}
+	}
+	else if((pattern & FW_RAMDUMP_PATTERN_MASK) == FW_RAMDUMP_PATTERN) {
+		char *fw_ram_seg_name[FW_RAM_SEG_CNT] = {"DRAM", "IRAM", "AXI"};
+		A_UINT8 *ram_ptr = NULL;
+		VOS_ASSERT(scn->ramdump_index < FW_RAM_SEG_CNT);
+
+		i = scn->ramdump_index;
+
+		memset(fw_dump_filename, 0, sizeof(fw_dump_filename));
+		scnprintf(fw_dump_filename, sizeof(fw_dump_filename), "%scld_%s.bin",
+		          CRASH_DUMP_PATH, fw_ram_seg_name[i]);
+
+		reg = (A_UINT32 *) (data + 4);
+		if (scn->fw_ram_dumping == 0) {
+			scn->fw_ram_dumping = 1;
+
+			pr_err("Firmware %s dump:\n", fw_ram_seg_name[i]);
+
+			crash_dump_file_init(fw_dump_filename);
+			scn->ramdump[i] = vos_mem_malloc(sizeof(struct fw_ramdump) +
+							DUMP_BUF_SIZE);
+			if (!scn->ramdump[i]) {
+				pr_err("Fail to allocate memory for ram dump");
+				VOS_BUG(0);
+			}
+			(scn->ramdump[i])->mem =
+				(A_UINT8 *) (scn->ramdump[i] + 1);
+			fw_ram_seg_addr[i] = (scn->ramdump[i])->mem;
+
+			pr_err("FW %s start addr = %#08x\n",
+				fw_ram_seg_name[i], *reg);
+			pr_err("Memory addr for %s = %#08x\n",
+				fw_ram_seg_name[i],
+				(A_UINT32) (scn->ramdump[i])->mem);
+			(scn->ramdump[i])->start_addr = *reg;
+			(scn->ramdump[i])->length = 0;
+		}
+		reg++;
+
+		if((DUMP_BUF_SIZE - (scn->ramdump[i])->length) < len - 8) {
+			crash_dump_flush(fw_dump_filename, (scn->ramdump[i])->mem, (scn->ramdump[i])->length);
+			(scn->ramdump[i])->length = 0;
+		}
+		ram_ptr = (scn->ramdump[i])->mem + (scn->ramdump[i])->length;
+		(scn->ramdump[i])->length += (len - 8);
+		memcpy(ram_ptr, (A_UINT8 *) reg, len - 8);
+
+		if (pattern == FW_RAMDUMP_END_PATTERN) {
+			int j;
+			//pr_err("%s memory size = %d\n", fw_ram_seg_name[i],
+			//		(scn->ramdump[i])->length);
+			for (j = 0; j < scn->ramdump[i]->length; j += 16) {
+			        memset(temp_buf, 0, sizeof(temp_buf));
+			        hex_dump_to_buffer(scn->ramdump[i]->mem + j, 16, 16, 4, temp_buf, sizeof(temp_buf), false);
+			}
+			//print_hex_dump(KERN_DEBUG, " ", DUMP_PREFIX_OFFSET, 16, 4, scn->ramdump[i]->mem, scn->ramdump[i]->length, false);
+
+
+			crash_dump_flush(fw_dump_filename, (scn->ramdump[i])->mem, (scn->ramdump[i])->length);
+
+			vos_mem_free(scn->ramdump[i]);
+			scn->ramdump[i] = NULL;
+			if (i == (FW_RAM_SEG_CNT - 1)) {
+				dumpcomplete = 1;
+				pr_err("F/W crash log dump completed\n");
+			}
+
+			scn->ramdump_index++;
+			scn->fw_ram_dumping = 0;
+		}
+	}
+#endif
+
+	if (dumpcomplete) {
+		if (vos_is_logp_in_progress(VOS_MODULE_ID_VOSS, NULL)) {
+			/* dispatch 'offline' uevent after FWDump */
+			A_MSLEEP(1500);
+			kobject_uevent(&scn->adf_dev->dev->kobj, KOBJ_OFFLINE);
+			vos_set_logp_in_progress(VOS_MODULE_ID_VOSS, FALSE);
+		}
+	}
+}
+#endif
+#endif
+
 /* ol_ramdump_handler is to receive information of firmware crash dump, and
  * save it in host memory. It consists of 5 parts: registers, call stack,
  * DRAM dump, IRAM dump, and AXI dump, and they are reported to host in order.
@@ -1191,6 +1500,12 @@ void *fw_ram_seg_addr[FW_RAM_SEG_CNT];
  *            of the last packet is FW_RAMDUMP_END_PATTERN;
  * IRAM dump and AXI dump are with the same format as DRAM dump.
  */
+#ifdef CONFIG_CRASH_DUMP_CLD
+void ol_ramdump_handler(struct ol_softc *scn)
+{
+	dump_fw_crash_to_file(scn);
+}
+#else
 void ol_ramdump_handler(struct ol_softc *scn)
 {
 	A_UINT32 *reg, pattern, i, start_addr = 0;
@@ -1297,6 +1612,7 @@ void ol_ramdump_handler(struct ol_softc *scn)
 		}
 	}
 }
+#endif /* CONFIG_CRASH_DUMP_CLD */
 #endif
 
 #define REGISTER_DUMP_LEN_MAX   60
diff --git a/CORE/SERVICES/COMMON/adf/adf_nbuf.c b/CORE/SERVICES/COMMON/adf/adf_nbuf.c
index 944894f..84fa2fd 100644
--- a/CORE/SERVICES/COMMON/adf/adf_nbuf.c
+++ b/CORE/SERVICES/COMMON/adf/adf_nbuf.c
@@ -245,6 +245,10 @@ skb_cb:
      */
     skb_reserve(skb, reserve);
 
+#ifdef CONFIG_CUST_PLATFORM
+    skb->next=NULL;
+#endif
+
     return skb;
 }
 
diff --git a/CORE/SERVICES/COMMON/adf/adf_os_mem.h b/CORE/SERVICES/COMMON/adf/adf_os_mem.h
index a7ba013..2ab6076 100644
--- a/CORE/SERVICES/COMMON/adf/adf_os_mem.h
+++ b/CORE/SERVICES/COMMON/adf/adf_os_mem.h
@@ -44,6 +44,9 @@
 #endif
 
 #include <i_vos_types.h>
+#ifdef CONFIG_VOS_MEM_PRE_ALLOC
+#include <vos_memory.h>
+#endif
 
 #ifdef MEMORY_DEBUG
 #define adf_os_mem_alloc(_osdev, _size) adf_os_mem_alloc_debug(_osdev,\
@@ -70,17 +73,24 @@ adf_os_mem_free_debug(void *buf);
 static inline void *
 adf_os_mem_alloc(adf_os_device_t osdev, adf_os_size_t size)
 {
-#ifdef CONFIG_WCNSS_MEM_PRE_ALLOC
+#if defined(CONFIG_WCNSS_MEM_PRE_ALLOC) || defined(CONFIG_VOS_MEM_PRE_ALLOC)
     void *p_mem;
 #endif
 
-#ifdef CONFIG_WCNSS_MEM_PRE_ALLOC
+#if defined(CONFIG_WCNSS_MEM_PRE_ALLOC)
    if (size > WCNSS_PRE_ALLOC_GET_THRESHOLD)
    {
        p_mem = wcnss_prealloc_get(size);
        if (NULL != p_mem)
            return p_mem;
    }
+#elif defined(CONFIG_VOS_MEM_PRE_ALLOC)
+	if (size > VOS_PRE_ALLOC_GET_THRESHOLD)
+	{
+		p_mem = vos_prealloc_get(size);
+		if (NULL != p_mem)
+			return p_mem;
+	}
 #endif
 
     return __adf_os_mem_alloc(osdev, size);
@@ -94,11 +104,16 @@ adf_os_mem_alloc(adf_os_device_t osdev, adf_os_size_t size)
 static inline void
 adf_os_mem_free(void *buf)
 {
-#ifdef CONFIG_WCNSS_MEM_PRE_ALLOC
+#if defined(CONFIG_WCNSS_MEM_PRE_ALLOC)
     if (wcnss_prealloc_put(buf))
     {
         return;
     }
+#elif defined(CONFIG_VOS_MEM_PRE_ALLOC)
+	if (vos_prealloc_put(buf))
+	{
+		return;
+	}
 #endif
 
     __adf_os_mem_free(buf);
diff --git a/CORE/SERVICES/COMMON/dbglog_host.h b/CORE/SERVICES/COMMON/dbglog_host.h
index d17acc5..3115740 100644
--- a/CORE/SERVICES/COMMON/dbglog_host.h
+++ b/CORE/SERVICES/COMMON/dbglog_host.h
@@ -185,6 +185,16 @@ dbglog_set_timestamp_resolution(wmi_unified_t  wmi_handle, A_UINT16 tsr);
 int
 dbglog_report_enable(wmi_unified_t  wmi_handle, A_BOOL isenable);
 
+#ifdef CONFIG_WLAN_FWLOG_FILE
+/** Enable write fwlog into a file */
+int
+dbglog_fwlog_file_enable(wmi_unified_t  wmi_handle, A_BOOL isenable);
+
+/** set max size of fwlog file */
+int
+dbglog_fwlog_file_max_size (wmi_unified_t  wmi_handle, A_UINT32 size);
+#endif
+
 /** Set the log level
 * @brief DBGLOG_INFO - Information lowest log level
 * @brief DBGLOG_WARNING
diff --git a/CORE/SERVICES/COMMON/ol_txrx_ctrl_api.h b/CORE/SERVICES/COMMON/ol_txrx_ctrl_api.h
index cc18608..44951f2 100644
--- a/CORE/SERVICES/COMMON/ol_txrx_ctrl_api.h
+++ b/CORE/SERVICES/COMMON/ol_txrx_ctrl_api.h
@@ -766,6 +766,12 @@ int
 ol_txrx_get_tx_pending(
     ol_txrx_pdev_handle pdev);
 
+void ol_txrx_dump_tx_desc(ol_txrx_pdev_handle pdev);
+
+#if defined(CONFIG_HL_SUPPORT)
+int ol_txrx_get_tx_pending_hl( struct ol_txrx_pdev_t* pdev);
+#endif
+
 /**
  * ol_txrx_get_queue_status() - Get the status of tx queues.
  * @pdev: the data physical device object
diff --git a/CORE/SERVICES/COMMON/wma_api.h b/CORE/SERVICES/COMMON/wma_api.h
index 0d1c124..2253134 100644
--- a/CORE/SERVICES/COMMON/wma_api.h
+++ b/CORE/SERVICES/COMMON/wma_api.h
@@ -175,6 +175,9 @@ static inline VOS_STATUS wma_send_egap_conf_params(WMA_HANDLE handle,
 
 extern int wma_scpc_event_handler(void *handle, u_int8_t *event, u_int32_t len);
 
+void wma_stop_allscan(WMA_HANDLE wma_handle);
+void wma_scan_completion_timeout(void *data);
+
 VOS_STATUS wma_set_tx_power_scale(uint8_t vdev_id, int value);
 VOS_STATUS wma_set_tx_power_scale_decr_db(uint8_t vdev_id, int value);
 
diff --git a/CORE/SERVICES/COMMON/wmi_unified.h b/CORE/SERVICES/COMMON/wmi_unified.h
index fcfba3b..9c50869 100644
--- a/CORE/SERVICES/COMMON/wmi_unified.h
+++ b/CORE/SERVICES/COMMON/wmi_unified.h
@@ -3570,7 +3570,11 @@ typedef enum {
     /** set type of the debug output */
     WMI_DBGLOG_TYPE,
     /** Enable Disable debug */
-    WMI_DBGLOG_REPORT_ENABLE
+    WMI_DBGLOG_REPORT_ENABLE,
+    /** Enable fwlog write to file */
+    WMI_DBGLOG_FWLOG_FILE_ENABLE,
+    /** set max size of fwlog file */
+    WMI_DBGLOG_FWLOG_FILE_MAX_SIZE,
 } WMI_DBG_PARAM;
 
 /* param_value for param_id WMI_PDEV_PARAM_CTS_CBW */
@@ -8328,6 +8332,7 @@ typedef struct {
     A_UINT32 swol_indoor_pattern;     /* wakeup pattern */
     A_UINT32 swol_indoor_exception;   /* wakeup when exception happens */
     A_UINT32 swol_indoor_exception_app;
+    A_UINT32 swol_assist_enable;
 } wmi_extwow_set_app_type1_params_cmd_fixed_param;
 
 typedef struct {
diff --git a/CORE/SERVICES/HIF/USB/if_usb.c b/CORE/SERVICES/HIF/USB/if_usb.c
index 4b92609..e482817 100644
--- a/CORE/SERVICES/HIF/USB/if_usb.c
+++ b/CORE/SERVICES/HIF/USB/if_usb.c
@@ -42,6 +42,12 @@
 #include "epping_main.h"
 #include "vos_sched.h"
 
+#if defined(CONFIG_USB_PRELOAD)
+#include "wlan_btc_svc.h"
+#include "wlan_nlink_common.h"
+#include "vos_getBin.h"
+#endif
+
 #ifndef REMOVE_PKT_LOG
 #include "ol_txrx_types.h"
 #include "pktlog_ac_api.h"
@@ -151,6 +157,38 @@ static int hif_usb_disable_lpm(struct usb_device *udev)
 	return ret;
 }
 
+#ifdef CONFIG_CUST_PLATFORM
+static int ssvd_disable_micom_reset(void)
+{
+	const char cmd=0x36, ack=0x36;
+	const int len=4;
+	char data[4]={0, 9, 1, 0};
+	int ret, cnt=0;
+	const struct kernel_symbol *sym = NULL;
+	int (*micom_fn)(char cmd, char ack, char *data, int len);
+
+	printk(KERN_ERR "%s\n", __func__);
+
+	sym = find_symbol("sdp_micom_send_cmd_ack", NULL, NULL, 1, true);
+
+	if (sym) {
+		micom_fn = (void*)sym->value;
+	} else {
+		printk(KERN_ERR "[%s] there is no micom driver\n", __func__ );
+		return -1;
+	}
+	do {
+		ret = micom_fn(cmd, ack, data, len);
+		if(ret) {
+			printk( KERN_ERR "%s : Send msg fail(cnt=%d)\n", __func__, cnt );
+			msleep( 50 );
+		}
+		cnt++;
+	} while(ret && (cnt < 3));
+	return ret;
+}
+#endif
+
 static int
 hif_usb_probe(struct usb_interface *interface, const struct usb_device_id *id)
 {
@@ -194,7 +232,7 @@ hif_usb_probe(struct usb_interface *interface, const struct usb_device_id *id)
 
 	if ((usb_control_msg(pdev, usb_sndctrlpipe(pdev, 0),
 			     USB_REQ_SET_CONFIGURATION, 0, 1, 0, NULL, 0,
-			     HZ)) < 0) {
+			     2000)) < 0) {
 		pr_info("%s[%d]\n\r", __func__, __LINE__);
 	}
 	usb_set_interface(pdev, 0, 0);
@@ -226,16 +264,27 @@ hif_usb_probe(struct usb_interface *interface, const struct usb_device_id *id)
 	atomic_set(&sc->hdd_removed_processing, 0);
 	sc->hdd_removed_wait_cnt = 0;
 
+#if defined(CONFIG_USB_PRELOAD)
+	/* Send WLAN UP indication to Nlink Service */
+	if (!WLAN_IS_EPPING_ENABLED(vos_get_conparam()))
+		send_btc_nlink_msg(WLAN_MODULE_UP_IND, 0);
+#endif
 	sc->interface = interface;
 	sc->reboot_notifier.notifier_call = hif_usb_reboot;
 	register_reboot_notifier(&sc->reboot_notifier);
 
 	usb_sc = sc;
+#ifdef CONFIG_CUST_PLATFORM
+	if (ssvd_disable_micom_reset())
+		pr_err ("%s: failed to disable micom reset\n",__func__);
+#endif
 	return 0;
 
 err_config:
 	hif_deinit_adf_ctx(ol_sc);
-	HIFDiagWriteCOLDRESET(sc->hif_device);
+	if (sc->hif_device != NULL)
+		HIFDiagWriteCOLDRESET(sc->hif_device);
+	
 	A_FREE(ol_sc);
 err_attach:
 	ret = -EIO;
@@ -334,23 +383,44 @@ static int hif_usb_suspend(struct usb_interface *interface, pm_message_t state)
 	struct hif_usb_softc *sc = device->sc;
 	void *vos = vos_get_global_context(VOS_MODULE_ID_HIF, NULL);
 	v_VOID_t * temp_module;
+        ol_txrx_pdev_handle txrx_pdev = vos_get_context(VOS_MODULE_ID_TXRX, vos);
+        u32 tx_drain_wait_cnt = 0;
+        int tx_pending = 0;
+
+	pr_err("Enter:%s,Line:%d\n", __func__,__LINE__);
 
-	printk("Enter:%s,Line:%d\n", __func__,__LINE__);
+        if (!txrx_pdev) {
+            printk("%s: txrx_pdev is NULL\n", __func__);
+            return (-1);
+        }
 
 	temp_module = vos_get_context(VOS_MODULE_ID_WDA, vos);
 	if (!temp_module) {
-		printk("%s: WDA module is NULL\n", __func__);
+		printk("KERN_ERR %s: WDA module is NULL\n", __func__);
 		return (-1);
 	}
 
 	if (wma_check_scan_in_progress(temp_module)) {
-		printk("%s: Scan in progress. Aborting suspend\n", __func__);
-		return (-1);
+		printk(KERN_ERR "%s: Scan in progress. Cancel all exising scan req\n", __func__);
+		wma_stop_allscan(temp_module);
+		msleep(10);
 	}
 
+        /* Wait for pending tx completion */
+        while ((tx_pending = ol_txrx_get_tx_pending_hl(txrx_pdev))) {
+            msleep(OL_ATH_TX_DRAIN_WAIT_DELAY);
+            if (++tx_drain_wait_cnt > OL_ATH_TX_DRAIN_WAIT_CNT) {
+                printk(KERN_ERR "%s: tx frames are pending: %d\n", __func__, tx_pending);
+                ol_txrx_dump_tx_desc(txrx_pdev);
+                break;
+            }
+        }
+        ol_txrx_pdev_pause(txrx_pdev, 0);
+
 	/* No need to send WMI_PDEV_SUSPEND_CMDID to FW if WOW is enabled */
 	if (wma_is_wow_mode_selected(temp_module)) {
 		if (wma_enable_wow_in_fw(temp_module, 0)) {
+                        ol_txrx_pdev_unpause(txrx_pdev, 0);
 			pr_warn("%s[%d]: fail\n", __func__, __LINE__);
 			return -1;
 		}
@@ -359,6 +429,7 @@ static int hif_usb_suspend(struct usb_interface *interface, pm_message_t state)
 		(PM_EVENT_HIBERNATE & state.event) == PM_EVENT_HIBERNATE) {
 		if (wma_suspend_target
 		    (vos_get_context(VOS_MODULE_ID_WDA, vos), 0)) {
+                        ol_txrx_pdev_unpause(txrx_pdev, 0);
 			pr_warn("%s[%d]: fail\n", __func__, __LINE__);
 			return -1;
 		}
@@ -367,10 +438,9 @@ static int hif_usb_suspend(struct usb_interface *interface, pm_message_t state)
 	sc->suspend_state = 1;
 	usb_hif_flush_all(device);
 
-	printk("Exit:%s,Line:%d\n", __func__,__LINE__);
+	pr_err("Exit:%s,Line:%d\n", __func__,__LINE__);
 	return 0;
 }
-
 #ifdef WLAN_LINK_UMAC_SUSPEND_WITH_BUS_SUSPEND
 void hdd_resume_wlan(void);
 #endif
@@ -381,8 +451,9 @@ static int hif_usb_resume(struct usb_interface *interface)
 	struct hif_usb_softc *sc = device->sc;
 	void *vos = vos_get_global_context(VOS_MODULE_ID_HIF, NULL);
 	v_VOID_t * temp_module;
+        ol_txrx_pdev_handle txrx_pdev = vos_get_context(VOS_MODULE_ID_TXRX, vos);
 
-	printk("Enter:%s,Line:%d\n", __func__,__LINE__);
+	pr_err("Enter:%s,Line:%d\n", __func__,__LINE__);
 	temp_module = vos_get_context(VOS_MODULE_ID_WDA, vos);
 	if (!temp_module) {
 		printk("%s: WDA module is NULL\n", __func__);
@@ -403,18 +474,17 @@ static int hif_usb_resume(struct usb_interface *interface)
 		pr_warn("%s[%d]: fail\n", __func__, __LINE__);
 		return (-1);
 	}
-	printk("Exit:%s,Line:%d\n", __func__,__LINE__);
+        ol_txrx_pdev_unpause(txrx_pdev, 0);
+	pr_err("Exit:%s,Line:%d\n", __func__,__LINE__);
 	return 0;
 }
 
 static int hif_usb_reset_resume(struct usb_interface *intf)
 {
-	HIF_DEVICE_USB *device = usb_get_intfdata(intf);
-	struct hif_usb_softc *sc = device->sc;
-
-	printk("Enter:%s,Line:%d \n\r", __func__,__LINE__);
-	HIFDiagWriteCOLDRESET(sc->hif_device);
-	printk("Exit:%s,Line:%d \n\r", __func__,__LINE__);
+	pr_err("Enter:%s,Line:%d \n\r", __func__,__LINE__);
+	hif_usb_resume(usb_sc->interface);
+	real_wlan_hdd_cfg80211_resume_wlan();
+	pr_err("Exit:%s,Line:%d \n\r", __func__,__LINE__);
 	return 0;
 }
 
@@ -509,13 +579,25 @@ static int is_usb_driver_register = 0;
 int hif_register_driver(void)
 {
 	int status = 0;
+#ifndef CONFIG_USB_PRELOAD
 	int probe_wait_cnt = 0;
+#endif
 	is_usb_driver_register = 1;
 	init_waitqueue_head(&hif_usb_unload_event_wq);
 	atomic_set(&hif_usb_unload_state, HIF_USB_UNLOAD_STATE_NULL);
 	usb_register_notify(&hif_usb_dev_nb);
 	status = usb_register(&hif_usb_drv_id);
 
+#if defined (CONFIG_USB_PRELOAD)
+	if (!WLAN_IS_EPPING_ENABLED(vos_get_conparam())) {
+		return status;
+	} else {
+		if (usb_sc && status == 0)
+			return 0;
+		else
+			return -1;
+	}
+#else
 	/* wait for usb probe done, 2s at most*/
 	while(!usb_sc && probe_wait_cnt < 10) {
 		A_MSLEEP(200);
@@ -526,6 +608,7 @@ int hif_register_driver(void)
 		return 0;
 	else
 		return -1;
+#endif
 }
 
 void hif_unregister_driver(void)
diff --git a/CORE/SERVICES/HIF/USB/if_usb.h b/CORE/SERVICES/HIF/USB/if_usb.h
index 1cd06d2..07502ac 100644
--- a/CORE/SERVICES/HIF/USB/if_usb.h
+++ b/CORE/SERVICES/HIF/USB/if_usb.h
@@ -43,7 +43,7 @@
  * long suspend thread has to sleep before checking pending tx
  * frame count.
  */
-#define OL_ATH_TX_DRAIN_WAIT_DELAY     50	/* ms */
+#define OL_ATH_TX_DRAIN_WAIT_DELAY     100	/* ms */
 /*
  * Wait time (in unit of OL_ATH_TX_DRAIN_WAIT_DELAY) for pending
  * tx frame completion before suspend. Refer: hif_pci_suspend()
diff --git a/CORE/SERVICES/HIF/USB/usbdrv.c b/CORE/SERVICES/HIF/USB/usbdrv.c
index 0d5a0ae..9c9fc07 100644
--- a/CORE/SERVICES/HIF/USB/usbdrv.c
+++ b/CORE/SERVICES/HIF/USB/usbdrv.c
@@ -1023,7 +1023,7 @@ A_STATUS usb_hif_submit_ctrl_out(HIF_DEVICE_USB *device,
 					 req,
 					 USB_DIR_OUT | USB_TYPE_VENDOR |
 					 USB_RECIP_DEVICE, value, index, buf,
-					 size, 2 * HZ);
+					 size, 2000);
 
 		if (result < 0) {
 			AR_DEBUG_PRINTF(ATH_DEBUG_ERR, (
@@ -1068,7 +1068,7 @@ A_STATUS usb_hif_submit_ctrl_in(HIF_DEVICE_USB *device,
 					 req,
 					 USB_DIR_IN | USB_TYPE_VENDOR |
 					 USB_RECIP_DEVICE, value, index, buf,
-					 size, 2 * HZ);
+					 size, 2000);
 
 		if (result < 0) {
 			AR_DEBUG_PRINTF(ATH_DEBUG_ERR,
diff --git a/CORE/SERVICES/WMA/regdomain.h b/CORE/SERVICES/WMA/regdomain.h
index 516a3af..d675b91 100644
--- a/CORE/SERVICES/WMA/regdomain.h
+++ b/CORE/SERVICES/WMA/regdomain.h
@@ -1091,7 +1091,41 @@ enum CountryCode {
 
     CTRY_AUSTRALIA2           = 5000,    /* Australia for AP only */
     CTRY_CANADA2              = 5001,    /* Canada for AP only */
-    CTRY_BELGIUM2             = 5002     /* Belgium/Cisco implementation */
+    CTRY_BELGIUM2             = 5002,    /* Belgium/Cisco implementation */
+#ifdef SS_REGULATORY
+    CTRY_QM                   = 5003,    /* customer_1_spec */
+    CTRY_QN                   = 5004,    /* customer_1_spec */
+    CTRY_QO                   = 5005,    /* customer_1_spec */
+    CTRY_QP                   = 5006,    /* customer_1_spec */
+    CTRY_QQ                   = 5007,    /* customer_1_spec */
+    CTRY_QR                   = 5008,    /* customer_1_spec */
+    CTRY_QS                   = 5009,    /* customer_1_spec */
+    CTRY_QT                   = 5010,    /* customer_1_spec */
+    CTRY_QU                   = 5011,    /* customer_1_spec */
+    CTRY_QV                   = 5012,    /* customer_1_spec */
+    CTRY_QW                   = 5013,    /* customer_1_spec */
+    CTRY_QX                   = 5014,    /* customer_1_spec */
+    CTRY_QY                   = 5015,    /* customer_1_spec */
+    CTRY_QZ                   = 5016,    /* customer_1_spec */
+    CTRY_XA                   = 5017,    /* customer_1_spec */
+    CTRY_XB                   = 5018,    /* customer_1_spec */
+    CTRY_XC                   = 5019,  	 /* customer_1_spec */
+    CTRY_XD                   = 5020,	 /* customer_1_spec */
+    CTRY_XE                   = 5021, 	 /* customer_1_spec */
+    CTRY_XF                   = 5022, 	 /* customer_1_spec */
+    CTRY_XG                   = 5023, 	 /* customer_1_spec */
+    CTRY_XH                   = 5024, 	 /* customer_1_spec */
+    CTRY_XI                   = 5025, 	 /* customer_1_spec */
+    CTRY_XJ                   = 5026,	 /* customer_1_spec */
+    CTRY_XK                   = 5027, 	 /* customer_1_spec */
+    CTRY_XL                   = 5028, 	 /* customer_1_spec */
+    CTRY_XM                   = 5029, 	 /* customer_1_spec */
+    CTRY_XN                   = 5030, 	 /* customer_1_spec */
+    CTRY_XO                   = 5031, 	 /* customer_1_spec */
+    CTRY_XP                   = 5032, 	 /* customer_1_spec */
+    CTRY_XQ                   = 5033, 	 /* customer_1_spec */
+    CTRY_XR                   = 5034, 	 /* customer_1_spec */
+#endif /* SS_REGULATORY */
 };
 
 int32_t regdmn_get_country_alpha2(struct regulatory *reg);
diff --git a/CORE/SERVICES/WMA/regdomain_common.h b/CORE/SERVICES/WMA/regdomain_common.h
index baeb8f2..34d90f9 100644
--- a/CORE/SERVICES/WMA/regdomain_common.h
+++ b/CORE/SERVICES/WMA/regdomain_common.h
@@ -102,6 +102,9 @@ enum EnumRd {
     FCC4_FCCA   = 0x12,     /* USA - Public Safety */
     FCC5_FCCA   = 0x13,     /* US with no DFS (UNII-1 + UNII-3 Only)*/
     FCC6_FCCA   = 0x14,     /* Canada for AP only*/
+#ifdef SS_REGULATORY
+    FCC5_WORLD  = 0x15,
+#endif /* SS_REGULATORY */
 
     FCC2_FCCA   = 0x20,     /* Canada */
     FCC2_WORLD  = 0x21,     /* Australia & HK */
@@ -220,6 +223,9 @@ enum EnumRd {
     MKK12_MKKA2 = 0xDD,     /* Japan UNI-1 even + UNI-1 odd + UNI-2 + mid-band + 4.9GHz + MKKA2 */
 
     MKK13_MKKB  = 0xDE,     /* Japan UNI-1 even + UNI-1 odd + UNI-2 + mid-band + MKKB + All passive + no adhoc */
+#ifdef SS_REGULATORY
+    MKK5_MKKA	= 0XDF,
+#endif /* SS_REGULATORY */
 
     /* Following definitions are used only by s/w to map old
      * Japan SKUs.
@@ -350,6 +356,9 @@ static const REG_DMN_PAIR_MAPPING ahCmnRegDomainPairs[] = {
 	{FCC3_ETSIC,    FCC3,		ETSIC,		NO_REQ, NO_REQ, PSCAN_DEFER, 0 },
 	{FCC4_FCCA,     FCC4,		FCCA,		DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB, NO_REQ, PSCAN_DEFER, 0 },
 	{FCC5_FCCA,     FCC5,		FCCA,		NO_REQ, NO_REQ, PSCAN_DEFER, 0 },
+#ifdef SS_REGULATORY
+	{FCC5_WORLD,    FCC5,		WORLD,		NO_REQ, NO_REQ, PSCAN_DEFER, 0 },
+#endif /* SS_REGULATORY */
 	{FCC6_FCCA,     FCC6,		FCCA,		NO_REQ, NO_REQ, PSCAN_DEFER, 0 },
 	{FCC6_WORLD,    FCC6,		WORLD,		NO_REQ, NO_REQ, PSCAN_DEFER, 0 },
 
@@ -411,6 +420,9 @@ static const REG_DMN_PAIR_MAPPING ahCmnRegDomainPairs[] = {
 
 	/* MKK5 */
 /*	{MKK5_MKKA,     MKK5,           MKKA,           DISALLOW_ADHOC_11A_TURB | NEED_NFC | LIMIT_FRAME_4MS, NEED_NFC, PSCAN_MKK3, CTRY_JAPAN56 },*/
+#ifdef SS_REGULATORY
+	{MKK5_MKKA, MKK5,       MKKA,       DISALLOW_ADHOC_11A_TURB | NEED_NFC | LIMIT_FRAME_4MS, NEED_NFC, PSCAN_MKK3, CTRY_JAPAN56 },
+#endif /* SS_REGULATORY */
 	{MKK5_MKKB,	MKK5,		MKKA,		DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB | NEED_NFC | LIMIT_FRAME_4MS, NEED_NFC, PSCAN_MKK3 | PSCAN_MKKA | PSCAN_MKKA_G, CTRY_JAPAN13 },
 	{MKK5_MKKA2,MKK5,		MKKA,		DISALLOW_ADHOC_11A_TURB | NEED_NFC | LIMIT_FRAME_4MS, NEED_NFC, PSCAN_MKK3 | PSCAN_MKKA2 | PSCAN_MKKA2_G, CTRY_JAPAN14 },
 	{MKK5_MKKC,	MKK5,		MKKC,		DISALLOW_ADHOC_11A_TURB | NEED_NFC | LIMIT_FRAME_4MS, NEED_NFC, PSCAN_MKK3, CTRY_JAPAN15 },
@@ -672,7 +684,43 @@ static const COUNTRY_CODE_TO_ENUM_RD ahCmnAllCountries[] = {
     {CTRY_VENEZUELA,   FCC1_WORLD,    "VE", "VENEZUELA",      YES,  NO, YES, YES, YES, YES, YES, YES, 7000 },
     {CTRY_VIET_NAM,    ETSI3_WORLD,   "VN", "VIET NAM",       YES,  NO, YES, YES, YES, YES, YES, YES, 7000 },
     {CTRY_YEMEN,       NULL1_WORLD,   "YE", "YEMEN",          YES,  NO, YES, YES, YES,  NO,  NO, NO, 7000 },
-    {CTRY_ZIMBABWE,    ETSI1_WORLD,   "ZW", "ZIMBABWE",       YES,  NO, YES, YES, YES,  NO,  NO, NO, 7000 }
+    {CTRY_ZIMBABWE,    ETSI1_WORLD,   "ZW", "ZIMBABWE",       YES,  NO, YES, YES, YES,  NO,  NO, NO, 7000 },
+#ifdef SS_REGULATORY
+	/*11g, ATu,	GTu, G20, G40, A20, A40, A80*/
+	{CTRY_QM,	NULL1_ETSIB,	"QM", "SS A",       	  YES,  NO, YES, YES,  NO,  NO,  NO,  NO, 7000 },//NO 5G
+	{CTRY_QN,	FCC3_WORLD,		"QN", "SS B",       	  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_QO,	ETSI8_WORLD,	"QO", "SS C", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_QP,	APL10_MKKC,	"QP", "SS D", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_QQ,	ETSI1_WORLD,	"QQ", "SS E", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_QR,	FCC1_WORLD,		"QR", "SS F", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_QS,	FCC2_ETSIC,		"QS", "SS G", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_QT,	ETSI3_WORLD,	"QT", "SS H", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_QU,	ETSI5_WORLD,	"QU", "SS I", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_QV,	APL4_WORLD,		"QV", "SS J", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_QW,	APL5_WORLD,		"QW", "SS K", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_QX,	FCC4_FCCA,		"QX", "SS L", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_QY,	FCC6_WORLD,		"QY", "SS M", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_QZ,	APL2_WORLD,		"QZ", "SS N", 		  YES, YES, YES, YES, YES, YES, YES,  NO, 7000 },//NO AC80
+	{CTRY_XA,	APL9_MKKC,		"XA", "SS O", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XB,	APL8_WORLD,		"XB", "SS P", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XC,	ETSI9_WORLD,	"XC", "SS Q", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XD,	FCC5_WORLD,		"XD", "SS R", 		  YES, YES, YES, YES, YES, YES, YES,  NO, 7000 },//NO AC80
+	{CTRY_XE,	APL6_WORLD,		"XE", "SS S", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XF,	MKK5_MKKA,		"XF", "SS T", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XG,	MKK11_FCCA,		"XG", "SS U", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XH,	MKK15_MKKA1,	"XH", "SS V", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XI,	APL3_WORLD,		"XI", "SS W", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XJ,	FCC6_FCCA,		"XJ", "SS X", 		   NO, YES,  NO,  NO,  NO, YES, YES,  NO, 7000 },//No 2G, NO AC80
+	{CTRY_XK,	APL7_FCCA,		"XK", "SS Y", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XL,	ETSI2_WORLD,	"XL", "SS Z", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XM,	ETSI6_WORLD,	"XM", "SS AA", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XN,	ETSI4_WORLD,	"XN", "SS AB", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XO,	WOR3_WORLD,		"XO", "SS AC", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XP,	WOR01_WORLD,	"XP", "SS AD", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XQ,	WOR02_WORLD,	"XQ", "SS AE", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XR,	WOR4_WORLD,		"XR", "SS AF", 		  YES, YES, YES, YES, YES, YES, YES,  NO, 7000 },//NO AC80
+#endif /* SS_REGULATORY */
+
 };
 
 
diff --git a/CORE/SERVICES/WMA/wma.c b/CORE/SERVICES/WMA/wma.c
index 3930ec2..05c3b4d 100644
--- a/CORE/SERVICES/WMA/wma.c
+++ b/CORE/SERVICES/WMA/wma.c
@@ -2385,10 +2385,16 @@ static int wma_enable_ext_wow(tp_wma_handle wma,
 	cmd->vdev_id = params->vdev_id;
 	cmd->type = params->type;
 	cmd->wakeup_pin_num = params->wakeup_pin_num;
+	cmd->swol_pulsetest_type = params->swol_pulsetest_type;
+	cmd->swol_pulsetest_application = params->swol_pulsetest_application;
 
 	WMA_LOGD("%s: vdev_id %d type %d Wakeup_pin_num %x",
 		 __func__, cmd->vdev_id,
 		 cmd->type, cmd->wakeup_pin_num);
+#ifdef CONFIG_CUST_PLATFORM
+	printk(KERN_ERR "SWOW: vdev_id %d type %d Wakeup_pin_num %x pulsetest:%u %u",
+		 cmd->vdev_id, cmd->type, cmd->wakeup_pin_num, cmd->swol_pulsetest_type, cmd->swol_pulsetest_application);
+#endif
 
 	ret = wmi_unified_cmd_send(wma->wmi_handle, buf, len,
 				   WMI_EXTWOW_ENABLE_CMDID);
@@ -2411,6 +2417,7 @@ static int wma_set_app_type1_params_in_fw(tp_wma_handle wma,
 	wmi_buf_t buf;
 	int32_t len;
 	int ret;
+	int i;
 
 	len = sizeof(wmi_extwow_set_app_type1_params_cmd_fixed_param);
 	buf = wmi_buf_alloc(wma->wmi_handle, len);
@@ -2428,20 +2435,54 @@ static int wma_set_app_type1_params_in_fw(tp_wma_handle wma,
 			wmi_extwow_set_app_type1_params_cmd_fixed_param));
 
 	cmd->vdev_id = appType1Params->vdev_id;
-	WMI_CHAR_ARRAY_TO_MAC_ADDR(appType1Params->wakee_mac_addr,
-							 &cmd->wakee_mac);
-	vos_mem_copy(cmd->ident, appType1Params->identification_id, 8);
+	vos_mem_copy(cmd->ident, appType1Params->identification_id, sizeof(cmd->ident));
 	cmd->ident_len = appType1Params->id_length;
-	vos_mem_copy(cmd->passwd, appType1Params->password, 16);
+	vos_mem_copy(cmd->passwd, appType1Params->password, sizeof(cmd->passwd));
 	cmd->passwd_len = appType1Params->pass_length;
-
-	WMA_LOGD("%s: vdev_id %d wakee_mac_addr %pM "
+	WMI_CHAR_ARRAY_TO_MAC_ADDR(appType1Params->swol_indoor_wakee, &cmd->wakee_mac);
+	vos_mem_copy(cmd->swol_indoor_key, appType1Params->swol_indoor_key, sizeof(cmd->swol_indoor_key));
+	vos_mem_copy(cmd->swol_indoor_key_len, appType1Params->swol_indoor_key_len, sizeof(cmd->swol_indoor_key_len));
+	for (i = 0; i < 8; i++) {
+		WMI_CHAR_ARRAY_TO_MAC_ADDR(appType1Params->swol_indoor_key_mac[i], &cmd->swol_indoor_key_mac[i]);
+	}
+	vos_mem_copy(cmd->swol_indoor_app_mask, appType1Params->swol_indoor_app_mask, sizeof(cmd->swol_indoor_app_mask));
+	cmd->swol_indoor_waker_check = appType1Params->swol_indoor_waker_check;
+	cmd->swol_indoor_pw_check = appType1Params->swol_indoor_pw_check;
+	cmd->swol_indoor_pattern = appType1Params->swol_indoor_pattern;
+	cmd->swol_indoor_exception = appType1Params->swol_indoor_exception;
+	cmd->swol_indoor_exception_app = appType1Params->swol_indoor_exception_app;
+	cmd->swol_assist_enable = appType1Params->swol_assist_enable;
+
+	WMA_LOGD("%s: vdev_id %d "
 			 "identification_id %.8s id_length %u "
 			 "password %.16s pass_length %u",
-		__func__, cmd->vdev_id, appType1Params->wakee_mac_addr,
-		cmd->ident, cmd->ident_len,
+		__func__, cmd->vdev_id, cmd->ident, cmd->ident_len,
 		cmd->passwd, cmd->passwd_len);
 
+#ifdef CONFIG_CUST_PLATFORM
+	printk(KERN_ERR "SWOW: vdev_id %d "
+                         "identification_id %.8s id_length %u "
+                         "password %.16s pass_length %u"
+                         "waker filter:%u passwd filter:%u pattern:%u exception:%u exception_app:%u, assit_enable:%u\n",
+		cmd->vdev_id, cmd->ident, cmd->ident_len,
+		cmd->passwd, cmd->passwd_len,
+		cmd->swol_indoor_waker_check,
+		cmd->swol_indoor_pw_check,
+		cmd->swol_indoor_pattern,
+		cmd->swol_indoor_exception,
+		cmd->swol_indoor_exception_app,
+		cmd->swol_assist_enable);
+	for (i = 0; i < 8; i++) {
+		printk(KERN_ERR "Waker [%d] %08x%08x %s(%u) 0x%x\n",
+			i,
+			cmd->swol_indoor_key_mac[i].mac_addr47to32,
+			cmd->swol_indoor_key_mac[i].mac_addr31to0,
+			cmd->swol_indoor_key[i],
+			cmd->swol_indoor_key_len[i],
+			cmd->swol_indoor_app_mask[i]);
+	}
+#endif
+
 	ret = wmi_unified_cmd_send(wma->wmi_handle, buf, len,
 				   WMI_EXTWOW_SET_APP_TYPE1_PARAMS_CMDID);
 	if (ret) {
@@ -9905,7 +9946,7 @@ static VOS_STATUS wma_stop_scan(tp_wma_handle wma_handle,
 		goto error;
 	}
 
-	WMA_LOGI("WMA --> WMI_STOP_SCAN_CMDID");
+	WMA_LOGE("WMA --> WMI_STOP_SCAN_CMDID");
 
 	return VOS_STATUS_SUCCESS;
 error:
@@ -9915,6 +9956,19 @@ error1:
 	return vos_status;
 }
 
+void wma_stop_allscan(WMA_HANDLE handle)
+{
+	int i;
+	tp_wma_handle wma_handle = handle;
+	for (i = 0; i < wma_handle->max_bssid; i++){
+		if (wma_handle->interfaces[i].scan_info.scan_id){
+			tAbortScanParams abort_scan_req;
+			abort_scan_req.SessionId = wma_handle->interfaces[i].scan_info.scan_id;
+			wma_stop_scan(wma_handle, &abort_scan_req);
+		}
+	}
+}
+
 /* function   : wma_update_channel_list
  * Description : Function is used to update the support channel list
  * Args       : wma_handle, list of supported channels and power
@@ -14692,6 +14746,20 @@ static void wma_process_cli_set_cmd(tp_wma_handle wma,
 				WMA_LOGE("dbglog_report_enable"
 						" failed ret %d", ret);
 			break;
+#ifdef CONFIG_WLAN_FWLOG_FILE
+		case WMI_DBGLOG_FWLOG_FILE_ENABLE:
+                        ret = dbglog_fwlog_file_enable(wma->wmi_handle, privcmd->param_value);
+			if (ret)
+				WMA_LOGE("dbglog_fwlog_file_enable"
+						" failed ret %d", ret);
+			break;
+                case WMI_DBGLOG_FWLOG_FILE_MAX_SIZE:
+                        ret = dbglog_fwlog_file_max_size(wma->wmi_handle, privcmd->param_value);
+                        if (ret)
+                                WMA_LOGE("dbglog_fwlog_file_max_size"
+                                                " failed ret %d", ret);
+                        break;
+#endif
 #ifdef FEATURE_GREEN_AP
 		case WMI_PDEV_GREEN_AP_PS_ENABLE_CMDID:
 			/* Set the Green AP */
diff --git a/CORE/SERVICES/WMA/wma.h b/CORE/SERVICES/WMA/wma.h
index 990ecf5..6970ed7 100644
--- a/CORE/SERVICES/WMA/wma.h
+++ b/CORE/SERVICES/WMA/wma.h
@@ -78,7 +78,11 @@
 
 /** Private **/
 #define WMA_CFG_NV_DNLD_TIMEOUT            500
+#ifdef CONFIG_CUST_PLATFORM
+#define WMA_READY_EVENTID_TIMEOUT          15000
+#else
 #define WMA_READY_EVENTID_TIMEOUT          2000
+#endif
 #define WMA_TGT_SUSPEND_COMPLETE_TIMEOUT   6000
 #define WMA_WAKE_LOCK_TIMEOUT              1000
 #define WMA_MAX_RESUME_RETRY               100
diff --git a/CORE/SME/inc/csrApi.h b/CORE/SME/inc/csrApi.h
index 06965b4..0555e7b 100644
--- a/CORE/SME/inc/csrApi.h
+++ b/CORE/SME/inc/csrApi.h
@@ -1519,6 +1519,10 @@ typedef struct sSirSmeAssocIndToUpperLayerCnf
     /* Timing and fine Timing measurement capability clubbed together */
     tANI_U8              timingMeasCap;
     tSirSmeChanInfo      chan_info;
+#ifdef CONFIG_CUST_PLATFORM
+    tANI_U32             assocReqLength;
+    tANI_U8              assocReqPtr[SIR_MAC_MAX_IE_LENGTH*4];
+#endif
 } tSirSmeAssocIndToUpperLayerCnf, *tpSirSmeAssocIndToUpperLayerCnf;
 
 typedef struct tagCsrSummaryStatsInfo
diff --git a/CORE/SME/src/csr/csrApiRoam.c b/CORE/SME/src/csr/csrApiRoam.c
index 89761bf..ccfb29a 100644
--- a/CORE/SME/src/csr/csrApiRoam.c
+++ b/CORE/SME/src/csr/csrApiRoam.c
@@ -9374,6 +9374,10 @@ void csrRoamJoinedStateMsgProcessor( tpAniSirGlobal pMac, void *pMsgBuf )
 #endif
             pRoamInfo->addIELen = (tANI_U8)pUpperLayerAssocCnf->addIE.length;
             pRoamInfo->paddIE = pUpperLayerAssocCnf->addIE.addIEdata;
+#ifdef CONFIG_CUST_PLATFORM
+            pRoamInfo->assocReqLength = (tANI_U8)pUpperLayerAssocCnf->assocReqLength;
+            pRoamInfo->assocReqPtr = pUpperLayerAssocCnf->assocReqPtr;
+#endif
             vos_mem_copy(pRoamInfo->peerMac, pUpperLayerAssocCnf->peerMacAddr,
                          sizeof(tSirMacAddr));
             vos_mem_copy(&pRoamInfo->bssid, pUpperLayerAssocCnf->bssId,
@@ -11462,11 +11466,17 @@ void csrRoamWaitForKeyTimeOutHandler(void *pv)
         return;
     }
 
-    smsLog(pMac, LOGW, FL("WaitForKey timer expired in state=%s sub-state=%s"),
-           macTraceGetNeighbourRoamState(
-           pMac->roam.neighborRoamInfo[pInfo->sessionId].neighborRoamState),
-           macTraceGetcsrRoamSubState(
-           pMac->roam.curSubState[pInfo->sessionId]));
+    if (pInfo->sessionId < CSR_ROAM_SESSION_MAX) {
+               smsLog(pMac, LOGW, FL("WaitForKey timer expired in state=%s sub-state=%s"),
+                       macTraceGetNeighbourRoamState(
+                       pMac->roam.neighborRoamInfo[pInfo->sessionId].neighborRoamState),
+                       macTraceGetcsrRoamSubState(
+                       pMac->roam.curSubState[pInfo->sessionId]));
+     } else {
+               smsLog(pMac, LOGW, "WaitForKey timer expired pInfo->sessionId (%d) exceed! ",
+                       pInfo->sessionId);
+     }
+
 
     if( CSR_IS_WAIT_FOR_KEY( pMac, pInfo->sessionId ) )
     {
@@ -15070,6 +15080,12 @@ eHalStatus csrSendAssocIndToUpperLayerCnfMsg(   tpAniSirGlobal pMac,
         pBuf += sizeof (tANI_U8);
         vos_mem_copy((void *)pBuf, &pAssocInd->chan_info,
                         sizeof(tSirSmeChanInfo));
+#ifdef CONFIG_CUST_PLATFORM
+        if (pAssocInd->assocReqLength && pAssocInd->assocReqPtr) {
+            pMsg->assocReqLength = pAssocInd->assocReqLength;
+            vos_mem_copy(pMsg->assocReqPtr, pAssocInd->assocReqPtr, pAssocInd->assocReqLength);
+        }
+#endif
         msgQ.type = eWNI_SME_UPPER_LAYER_ASSOC_CNF;
         msgQ.bodyptr = pMsg;
         msgQ.bodyval = 0;
diff --git a/CORE/SME/src/csr/csrApiScan.c b/CORE/SME/src/csr/csrApiScan.c
index 86bc234..673de5b 100644
--- a/CORE/SME/src/csr/csrApiScan.c
+++ b/CORE/SME/src/csr/csrApiScan.c
@@ -2896,6 +2896,10 @@ eHalStatus csrScanningStateMsgProcessor( tpAniSirGlobal pMac, void *pMsgBuf )
             pRoamInfo->prsnIE = pUpperLayerAssocCnf->rsnIE.rsnIEdata;
             pRoamInfo->addIELen = (tANI_U8)pUpperLayerAssocCnf->addIE.length;
             pRoamInfo->paddIE = pUpperLayerAssocCnf->addIE.addIEdata;
+#ifdef CONFIG_CUST_PLATFORM
+            pRoamInfo->assocReqLength = (tANI_U8)pUpperLayerAssocCnf->assocReqLength;
+            pRoamInfo->assocReqPtr = pUpperLayerAssocCnf->assocReqPtr;
+#endif
             vos_mem_copy(pRoamInfo->peerMac, pUpperLayerAssocCnf->peerMacAddr, sizeof(tSirMacAddr));
             vos_mem_copy(&pRoamInfo->bssid, pUpperLayerAssocCnf->bssId, sizeof(tCsrBssid));
             pRoamInfo->wmmEnabledSta = pUpperLayerAssocCnf->wmmEnabledSta;
diff --git a/CORE/SME/src/csr/csrNeighborRoam.c b/CORE/SME/src/csr/csrNeighborRoam.c
index 3a65e32..0eb6a1b 100644
--- a/CORE/SME/src/csr/csrNeighborRoam.c
+++ b/CORE/SME/src/csr/csrNeighborRoam.c
@@ -1935,7 +1935,7 @@ tANI_U32 csrGetCurrentAPRssi(tpAniSirGlobal pMac,
     tpCsrNeighborRoamControlInfo pNeighborRoamInfo =
                                         &pMac->roam.neighborRoamInfo[sessionId];
 #ifdef FEATURE_WLAN_LFR
-    tANI_U32 CurrAPRssi = pNeighborRoamInfo->lookupDOWNRssi;
+    tANI_U32 CurrAPRssi = abs(pNeighborRoamInfo->lookupDOWNRssi);
 #else
         /* We are setting this as default value to make sure we return this value,
         when we do not see this AP in the scan result for some reason.However,it is
diff --git a/CORE/UTILS/FWLOG/dbglog_host.c b/CORE/UTILS/FWLOG/dbglog_host.c
index fa7931d..e7fba85 100644
--- a/CORE/UTILS/FWLOG/dbglog_host.c
+++ b/CORE/UTILS/FWLOG/dbglog_host.c
@@ -1269,6 +1269,112 @@ char * DBG_MSG_ARR[WLAN_MODULE_ID_MAX][MAX_DBG_MSGS] =
     },
 };
 
+#ifdef CONFIG_WLAN_FWLOG_FILE
+extern int _readwrite_file(const char *filename, char *rbuf,
+                           const char *wbuf, size_t length, int mode);
+
+#define FWLOG_FILE_BUF_MAX_DEFAULT_SIZE	  (16*1024) /* default 16k */
+#define FWLOG_FILE_BUF_THREHOLD           (12*1024) /* default 12k */
+#define FWLOG_FILE_MAX_DEFAULT_SIZE       (10*1024*1024) /* default 10M */
+#define FWLOG_FILE_DEFAULT_PATH           "/opt/var/log/cld_fw.log"
+
+struct _dbglog_fwlog_file {
+    A_UINT8  print_to_file;
+    A_UINT32 file_max_size;
+    A_UINT8  file_path_and_name[64];
+    A_UINT32 file_size;
+    A_UINT32 buf_used_size;
+    A_UINT32 buf_free_size;
+    A_UINT8* buf_free_idx;
+    struct mutex lock;
+    struct work_struct work;
+    adf_os_timer_t timer;
+    A_UINT8* buf;
+    A_UINT32 overflow;
+} dbglog_fwlog_file_ctx;
+
+inline void dbglog_fwlog_file_trunc(void)
+{
+
+    _readwrite_file(dbglog_fwlog_file_ctx.file_path_and_name, NULL,
+                    NULL, 0, (O_WRONLY | O_CREAT | O_TRUNC));
+
+    dbglog_fwlog_file_ctx.file_size = 0;
+}
+
+
+void dbglog_fwlog_file_write_file(void)
+{
+    int ret;
+
+    if (dbglog_fwlog_file_ctx.buf_used_size) {
+        if (dbglog_fwlog_file_ctx.file_size >= dbglog_fwlog_file_ctx.file_max_size) {
+            dbglog_fwlog_file_trunc();
+        }
+        ret = _readwrite_file(dbglog_fwlog_file_ctx.file_path_and_name, NULL,
+                              dbglog_fwlog_file_ctx.buf,
+                              dbglog_fwlog_file_ctx.buf_used_size,
+                              (O_WRONLY | O_APPEND | O_CREAT));
+        if (ret < 0) {
+            printk("%s:%d: fail to write\n", __func__, __LINE__);
+            return;
+        }
+
+        dbglog_fwlog_file_ctx.buf_free_idx = dbglog_fwlog_file_ctx.buf;
+        dbglog_fwlog_file_ctx.file_size += dbglog_fwlog_file_ctx.buf_used_size;
+        dbglog_fwlog_file_ctx.buf_used_size = 0;
+        dbglog_fwlog_file_ctx.buf_free_size = FWLOG_FILE_BUF_MAX_DEFAULT_SIZE;
+    }
+}
+
+
+void dbglog_fwlog_file_thread(struct work_struct *work)
+{
+    mutex_lock(&dbglog_fwlog_file_ctx.lock);
+    dbglog_fwlog_file_write_file();
+    mutex_unlock(&dbglog_fwlog_file_ctx.lock);
+}
+
+
+void dbglog_fwlog_file_timeout_handler(void* ctx)
+{
+    schedule_work(&dbglog_fwlog_file_ctx.work);
+}
+
+int dbglog_fwlog_file_init(void)
+{
+    dbglog_fwlog_file_ctx.buf = kmalloc(FWLOG_FILE_BUF_MAX_DEFAULT_SIZE, GFP_KERNEL);
+    if (dbglog_fwlog_file_ctx.buf == NULL) {
+        printk("%s:%d: not enough mem\n", __func__, __LINE__);
+        return -ENOMEM;
+    }
+
+    dbglog_fwlog_file_ctx.print_to_file = 0;
+    dbglog_fwlog_file_ctx.overflow = 0;
+    dbglog_fwlog_file_ctx.file_max_size = FWLOG_FILE_MAX_DEFAULT_SIZE;
+	A_SNPRINTF(dbglog_fwlog_file_ctx.file_path_and_name,
+			strnlen(FWLOG_FILE_DEFAULT_PATH, 63) + 1,
+			FWLOG_FILE_DEFAULT_PATH);
+    dbglog_fwlog_file_ctx.file_size = 0;
+    dbglog_fwlog_file_ctx.buf_used_size = 0;
+    dbglog_fwlog_file_ctx.buf_free_size = FWLOG_FILE_BUF_MAX_DEFAULT_SIZE;
+    dbglog_fwlog_file_ctx.buf_free_idx = dbglog_fwlog_file_ctx.buf;
+    mutex_init(&dbglog_fwlog_file_ctx.lock);
+    INIT_WORK(&dbglog_fwlog_file_ctx.work, dbglog_fwlog_file_thread);
+    adf_os_timer_init(NULL, &dbglog_fwlog_file_ctx.timer, dbglog_fwlog_file_timeout_handler, NULL, ADF_DEFERRABLE_TIMER);
+
+    return 0;
+}
+
+void dbglog_fwlog_file_deinit(void)
+{
+    adf_os_timer_cancel(&dbglog_fwlog_file_ctx.timer);
+    adf_os_timer_free(&dbglog_fwlog_file_ctx.timer);
+    flush_work(&dbglog_fwlog_file_ctx.work);
+    mutex_unlock(&dbglog_fwlog_file_ctx.lock);
+    kfree(dbglog_fwlog_file_ctx.buf);
+}
+#endif
 int dbglog_module_log_enable(wmi_unified_t  wmi_handle, A_UINT32 mod_id,
                   bool isenable)
 {
@@ -1408,6 +1514,31 @@ dbglog_set_mod_enable_bitmap(wmi_unified_t  wmi_handle,A_UINT32 log_level, A_UIN
 			mod_enable_bitmap,bitmap_len);
 }
 
+#ifdef CONFIG_WLAN_FWLOG_FILE
+int dbglog_fwlog_file_enable(wmi_unified_t  wmi_handle, bool isenable)
+{
+
+	if (isenable) {
+		dbglog_fwlog_file_ctx.print_to_file = 1;
+		dbglog_fwlog_file_trunc();
+	} else {
+		dbglog_fwlog_file_ctx.print_to_file = 0;
+	}
+	return 0;
+}
+
+
+int dbglog_fwlog_file_max_size(wmi_unified_t  wmi_handle, A_UINT32 size)
+{
+        if (size == 0) {
+             dbglog_fwlog_file_ctx.file_max_size = FWLOG_FILE_MAX_DEFAULT_SIZE;
+        } else {
+             dbglog_fwlog_file_ctx.file_max_size = size;
+        }
+        return 0;
+}
+#endif
+
 int dbglog_report_enable(wmi_unified_t  wmi_handle, bool isenable)
 {
     int bitmap[2] = {0};
@@ -1425,6 +1556,9 @@ int dbglog_report_enable(wmi_unified_t  wmi_handle, bool isenable)
 	bitmap[1] = 0x1F;
 	/* set the module level bitmap  */
 	dbglog_set_mod_enable_bitmap(wmi_handle, 0x0, bitmap, 2);
+#ifdef CONFIG_WLAN_FWLOG_FILE
+	dbglog_fwlog_file_trunc();
+#endif
     } else {
         dbglog_set_vap_enable_bitmap(wmi_handle, bitmap[0]);
         dbglog_set_mod_enable_bitmap(wmi_handle, DBGLOG_LVL_MAX, bitmap, 2);
@@ -1459,6 +1593,58 @@ dbglog_printf(
 {
     char buf[128];
     va_list ap;
+#ifdef CONFIG_WLAN_FWLOG_FILE
+    int len = 0;
+
+    if (dbglog_fwlog_file_ctx.print_to_file) {
+        mutex_lock(&dbglog_fwlog_file_ctx.lock);
+
+        if (dbglog_fwlog_file_ctx.buf_used_size  == 0) {
+	    adf_os_timer_cancel(&dbglog_fwlog_file_ctx.timer);
+            adf_os_timer_start(&dbglog_fwlog_file_ctx.timer, 100);
+        }
+
+        if (dbglog_fwlog_file_ctx.buf_free_size <= 120) {
+            dbglog_fwlog_file_ctx.overflow++;
+            printk("%s:%d: overflow:%u\n", __func__, __LINE__, dbglog_fwlog_file_ctx.overflow);
+            mutex_unlock(&dbglog_fwlog_file_ctx.lock);
+            return;
+        }
+
+	if (vap_id < DBGLOG_MAX_VDEVID) {
+            len = snprintf(dbglog_fwlog_file_ctx.buf_free_idx, dbglog_fwlog_file_ctx.buf_free_size,
+                           "[%u] vap-%u ", timestamp, vap_id);
+	} else {
+            len = snprintf(dbglog_fwlog_file_ctx.buf_free_idx, dbglog_fwlog_file_ctx.buf_free_size,
+                           "[%u] ", timestamp);
+	}
+
+        va_start(ap, fmt);
+        len += vsnprintf(dbglog_fwlog_file_ctx.buf_free_idx + len, dbglog_fwlog_file_ctx.buf_free_size - len, fmt, ap);
+	dbglog_fwlog_file_ctx.buf_free_idx[len] = '\n';
+	len++;
+        dbglog_fwlog_file_ctx.buf_free_idx += len;
+        dbglog_fwlog_file_ctx.buf_used_size += len;
+        dbglog_fwlog_file_ctx.buf_free_size -= len;
+        va_end(ap);
+        if ((dbglog_fwlog_file_ctx.buf_used_size >= FWLOG_FILE_BUF_THREHOLD) ||
+            ((dbglog_fwlog_file_ctx.file_size + dbglog_fwlog_file_ctx.buf_used_size) >= dbglog_fwlog_file_ctx.file_max_size)) {
+            adf_os_timer_cancel(&dbglog_fwlog_file_ctx.timer);
+            dbglog_fwlog_file_write_file();
+        }
+        mutex_unlock(&dbglog_fwlog_file_ctx.lock);
+    } else {
+        if (vap_id < DBGLOG_MAX_VDEVID) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (DBGLOG_PRINT_PREFIX "[%u] vap-%u ", timestamp, vap_id));
+        } else {
+            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (DBGLOG_PRINT_PREFIX "[%u] ", timestamp));
+        }
+        va_start(ap, fmt);
+        vsnprintf(buf, sizeof(buf), fmt, ap);
+        va_end(ap);
+        AR_DEBUG_PRINTF(ATH_DEBUG_INFO, ("%s\n", buf));
+    }
+#else
 
     if (vap_id < DBGLOG_MAX_VDEVID) {
         AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (DBGLOG_PRINT_PREFIX "[%u] vap-%u ", timestamp, vap_id));
@@ -1471,6 +1657,7 @@ dbglog_printf(
     va_end(ap);
 
     AR_DEBUG_PRINTF(ATH_DEBUG_INFO, ("%s\n", buf));
+#endif
 }
 
 void
@@ -1481,6 +1668,60 @@ dbglog_printf_no_line_break(
 {
     char buf[128];
     va_list ap;
+#ifdef CONFIG_WLAN_FWLOG_FILE
+    int len = 0;
+
+    if (dbglog_fwlog_file_ctx.print_to_file) {
+        mutex_lock(&dbglog_fwlog_file_ctx.lock);
+
+        if (dbglog_fwlog_file_ctx.buf_used_size  == 0) {
+	    adf_os_timer_cancel(&dbglog_fwlog_file_ctx.timer);
+            adf_os_timer_start(&dbglog_fwlog_file_ctx.timer, 100);
+        }
+
+        if (dbglog_fwlog_file_ctx.buf_free_size <= 120) {
+            dbglog_fwlog_file_ctx.overflow++;
+            printk("%s:%d: overflow:%u\n", __func__, __LINE__, dbglog_fwlog_file_ctx.overflow);
+            mutex_unlock(&dbglog_fwlog_file_ctx.lock);
+            return;
+        }
+
+	if (vap_id < DBGLOG_MAX_VDEVID) {
+		len = snprintf(dbglog_fwlog_file_ctx.buf_free_idx, dbglog_fwlog_file_ctx.buf_free_size,
+			"[%u] vap-%u ", timestamp, vap_id);
+	} else {
+		len = snprintf(dbglog_fwlog_file_ctx.buf_free_idx, dbglog_fwlog_file_ctx.buf_free_size,
+			"[%u] ", timestamp);
+	}
+
+        va_start(ap, fmt);
+        len += vsnprintf(dbglog_fwlog_file_ctx.buf_free_idx + len, dbglog_fwlog_file_ctx.buf_free_size - len, fmt, ap);
+	dbglog_fwlog_file_ctx.buf_free_idx[len] = '\n';
+	len++;
+        dbglog_fwlog_file_ctx.buf_free_idx += len;
+        dbglog_fwlog_file_ctx.buf_used_size += len;
+        dbglog_fwlog_file_ctx.buf_free_size -= len;
+        va_end(ap);
+        if ((dbglog_fwlog_file_ctx.buf_used_size >= FWLOG_FILE_BUF_THREHOLD) ||
+            ((dbglog_fwlog_file_ctx.file_size + dbglog_fwlog_file_ctx.buf_used_size) >= dbglog_fwlog_file_ctx.file_max_size)) {
+            adf_os_timer_cancel(&dbglog_fwlog_file_ctx.timer);
+            dbglog_fwlog_file_write_file();
+        }
+        mutex_unlock(&dbglog_fwlog_file_ctx.lock);
+    } else {
+        if (vap_id < DBGLOG_MAX_VDEVID) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (DBGLOG_PRINT_PREFIX "[%u] vap-%u ", timestamp, vap_id));
+        } else {
+            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (DBGLOG_PRINT_PREFIX "[%u] ", timestamp));
+        }
+
+        va_start(ap, fmt);
+        vsnprintf(buf, sizeof(buf), fmt, ap);
+        va_end(ap);
+
+        AR_DEBUG_PRINTF(ATH_DEBUG_INFO, ("%s", buf));
+    }
+#else
 
     if (vap_id < DBGLOG_MAX_VDEVID) {
         AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (DBGLOG_PRINT_PREFIX "[%u] vap-%u ", timestamp, vap_id));
@@ -1493,6 +1734,7 @@ dbglog_printf_no_line_break(
     va_end(ap);
 
     AR_DEBUG_PRINTF(ATH_DEBUG_INFO, ("%s", buf));
+#endif
 }
 
 #define USE_NUMERIC 0
@@ -1502,6 +1744,75 @@ dbglog_default_print_handler(A_UINT32 mod_id, A_UINT16 vap_id, A_UINT32 dbg_id,
                              A_UINT32 timestamp, A_UINT16 numargs, A_UINT32 *args)
 {
     int i;
+#ifdef CONFIG_WLAN_FWLOG_FILE
+    int len = 0;
+
+    if (dbglog_fwlog_file_ctx.print_to_file) {
+        mutex_lock(&dbglog_fwlog_file_ctx.lock);
+
+        if (dbglog_fwlog_file_ctx.buf_used_size  == 0) {
+	    adf_os_timer_cancel(&dbglog_fwlog_file_ctx.timer);
+            adf_os_timer_start(&dbglog_fwlog_file_ctx.timer, 100);
+        }
+
+        if (dbglog_fwlog_file_ctx.buf_free_size <= 120) {
+            dbglog_fwlog_file_ctx.overflow++;
+            printk("%s:%d: overflow:%u\n", __func__, __LINE__, dbglog_fwlog_file_ctx.overflow);
+            mutex_unlock(&dbglog_fwlog_file_ctx.lock);
+            return TRUE;
+        }
+
+	if (vap_id < DBGLOG_MAX_VDEVID) {
+            len = snprintf(dbglog_fwlog_file_ctx.buf_free_idx, dbglog_fwlog_file_ctx.buf_free_size,
+                           "[%u] vap-%u %s (", timestamp, vap_id, dbglog_get_msg(mod_id, dbg_id));
+	} else {
+            len = snprintf(dbglog_fwlog_file_ctx.buf_free_idx, dbglog_fwlog_file_ctx.buf_free_size,
+                           "[%u] %s (", timestamp, dbglog_get_msg(mod_id, dbg_id));
+	}
+
+        for (i = 0; i < numargs; i++) {
+#if USE_NUMERIC
+            len += snprintf(dbglog_fwlog_file_ctx.buf_free_idx + len, dbglog_fwlog_file_ctx.buf_free_size - len, "%u", args[i]);
+#else
+            len += snprintf(dbglog_fwlog_file_ctx.buf_free_idx + len, dbglog_fwlog_file_ctx.buf_free_size - len, "%#x", args[i]);
+#endif
+            if ((i + 1) < numargs) {
+                dbglog_fwlog_file_ctx.buf_free_idx[len] = ',';
+                dbglog_fwlog_file_ctx.buf_free_idx[len+1] = ' ';
+                len += 2;
+            }
+        }
+        len += snprintf(dbglog_fwlog_file_ctx.buf_free_idx + len, dbglog_fwlog_file_ctx.buf_free_size - len, " )\n");
+        dbglog_fwlog_file_ctx.buf_free_idx += len;
+        dbglog_fwlog_file_ctx.buf_used_size += len;
+        dbglog_fwlog_file_ctx.buf_free_size -= len;
+        if ((dbglog_fwlog_file_ctx.buf_used_size >= FWLOG_FILE_BUF_THREHOLD) ||
+            ((dbglog_fwlog_file_ctx.file_size + dbglog_fwlog_file_ctx.buf_used_size) >= dbglog_fwlog_file_ctx.file_max_size)) {
+            adf_os_timer_cancel(&dbglog_fwlog_file_ctx.timer);
+            dbglog_fwlog_file_write_file();
+        }
+        mutex_unlock(&dbglog_fwlog_file_ctx.lock);
+    } else {
+
+        if (vap_id < DBGLOG_MAX_VDEVID) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (DBGLOG_PRINT_PREFIX "[%u] vap-%u %s ( ", timestamp, vap_id, dbglog_get_msg(mod_id, dbg_id)));
+        } else {
+            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (DBGLOG_PRINT_PREFIX "[%u] %s ( ", timestamp, dbglog_get_msg(mod_id, dbg_id)));
+        }
+
+        for (i = 0; i < numargs; i++) {
+#if USE_NUMERIC
+            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, ("%u", args[i]));
+#else
+            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, ("%#x", args[i]));
+#endif
+            if ((i + 1) < numargs) {
+                AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (", "));
+            }
+        }
+        AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (" )\n"));
+    }
+#else
 
     if (vap_id < DBGLOG_MAX_VDEVID) {
         AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (DBGLOG_PRINT_PREFIX "[%u] vap-%u %s ( ", timestamp, vap_id, dbglog_get_msg(mod_id, dbg_id)));
@@ -1520,6 +1831,7 @@ dbglog_default_print_handler(A_UINT32 mod_id, A_UINT16 vap_id, A_UINT32 dbg_id,
         }
     }
     AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (" )\n"));
+#endif
 
     return TRUE;
 }
@@ -4197,6 +4509,12 @@ dbglog_init(wmi_unified_t wmi_handle)
     /* Initialize debugfs */
     dbglog_debugfs_init(wmi_handle);
 #endif /* WLAN_OPEN_SOURCE */
+#ifdef CONFIG_WLAN_FWLOG_FILE
+    res = dbglog_fwlog_file_init();
+    if (res != 0) {
+        return res;
+    }
+#endif
 
     return res;
 }
@@ -4206,6 +4524,9 @@ dbglog_deinit(wmi_unified_t wmi_handle)
 {
     int res = 0;
 
+#ifdef CONFIG_WLAN_FWLOG_FILE
+    dbglog_fwlog_file_deinit();
+#endif
 #ifdef WLAN_OPEN_SOURCE
     /* DeInitialize the fw debug log queue */
     skb_queue_purge(&wmi_handle->dbglog.fwlog_queue);
diff --git a/CORE/VOSS/inc/vos_cnss.h b/CORE/VOSS/inc/vos_cnss.h
index 2fc7525..4bd1e51 100644
--- a/CORE/VOSS/inc/vos_cnss.h
+++ b/CORE/VOSS/inc/vos_cnss.h
@@ -44,6 +44,8 @@ enum cnss_bus_width_type {
 	CNSS_BUS_WIDTH_HIGH
 };
 
+struct pci_dev;
+
 static inline void vos_wlan_pci_link_down(void){ return; }
 static inline int vos_pcie_shadow_control(struct pci_dev *dev, bool enable)
 {
diff --git a/CORE/VOSS/inc/vos_memory.h b/CORE/VOSS/inc/vos_memory.h
index 2147f24..9879504 100644
--- a/CORE/VOSS/inc/vos_memory.h
+++ b/CORE/VOSS/inc/vos_memory.h
@@ -89,6 +89,21 @@ v_VOID_t *vos_mem_malloc_debug(v_SIZE_t size, const char *fileName,
 v_VOID_t * vos_mem_malloc( v_SIZE_t size );
 #endif
 
+#ifdef CONFIG_VOS_MEM_PRE_ALLOC
+#define VOS_PRE_ALLOC_GET_THRESHOLD (16*1024)
+
+struct vos_prealloc {
+	v_UINT_t occupied;
+	v_UINT_t size;
+	v_VOID_t *ptr;
+};
+
+v_UINT_t vos_prealloc_init(v_VOID_t);
+v_VOID_t vos_prealloc_deinit(v_VOID_t);
+v_SINT_t vos_prealloc_put(v_VOID_t *ptr);
+v_VOID_t *vos_prealloc_get(v_UINT_t size);
+
+#endif /* CONFIG_VOS_MEM_PRE_ALLOC */
 
 /*----------------------------------------------------------------------------
 
diff --git a/CORE/VOSS/src/vos_memory.c b/CORE/VOSS/src/vos_memory.c
index 9012401..4ae1f5f 100644
--- a/CORE/VOSS/src/vos_memory.c
+++ b/CORE/VOSS/src/vos_memory.c
@@ -62,6 +62,11 @@
 #include <net/cnss_prealloc.h>
 #endif
 
+#ifdef CONFIG_VOS_MEM_PRE_ALLOC
+#include <vos_getBin.h>
+#include <epping_main.h>
+#endif
+
 #ifdef MEMORY_DEBUG
 #include "wlan_hdd_dp_utils.h"
 #include <linux/stacktrace.h>
@@ -107,6 +112,35 @@ static struct s_vos_mem_usage_struct g_usage_mem_buf[MAX_USAGE_TRACE_BUF_NUM];
 
 #define VOS_GET_MEMORY_TIME_THRESHOLD 300
 
+#ifdef CONFIG_VOS_MEM_PRE_ALLOC
+static DEFINE_MUTEX(alloc_lock);
+
+/* pre-alloced at load time
+ * following three definition must fit
+ * to avoid memory corruption */
+#define TOTOTAL_PRELOCATE (40*10 + 64*2 + 128*1 + 256*2)*1024
+static struct vos_prealloc vos_allocs[] = {
+	{0, 40 * 1024, NULL},
+	{0, 40 * 1024, NULL},
+	{0, 40 * 1024, NULL},
+	{0, 40 * 1024, NULL},
+	{0, 40 * 1024, NULL},
+	{0, 40 * 1024, NULL},
+	{0, 40 * 1024, NULL},
+	{0, 40 * 1024, NULL},
+	{0, 40 * 1024, NULL},
+	{0, 40 * 1024, NULL},
+	{0, 64 * 1024, NULL},
+	{0, 64 * 1024, NULL},
+	{0, 128 * 1024, NULL},
+	{0, 256 * 1024, NULL},
+	{0, 256 * 1024, NULL},
+};
+
+v_BYTE_t pre_alloc_pool[TOTOTAL_PRELOCATE];
+
+#endif /* CONFIG_VOS_MEM_PRE_ALLOC */
+
 /*---------------------------------------------------------------------------
  * Type Declarations
  * ------------------------------------------------------------------------*/
@@ -118,6 +152,89 @@ static struct s_vos_mem_usage_struct g_usage_mem_buf[MAX_USAGE_TRACE_BUF_NUM];
 /*---------------------------------------------------------------------------
  * External Function implementation
  * ------------------------------------------------------------------------*/
+
+#ifdef CONFIG_VOS_MEM_PRE_ALLOC
+
+/* pre-alloced at load time*/
+v_UINT_t vos_prealloc_init(v_VOID_t)
+{
+	v_UINT_t i;
+	v_UINT_t alloc_pos = 0;
+
+	for (i = 0; i < ARRAY_SIZE(vos_allocs); i++) {
+		vos_allocs[i].occupied = 0;
+		vos_allocs[i].ptr = &pre_alloc_pool[alloc_pos];
+		alloc_pos += vos_allocs[i].size;
+		if (alloc_pos > TOTOTAL_PRELOCATE)
+			return -ENOMEM;
+	}
+	return 0;
+}
+v_VOID_t vos_prealloc_deinit(v_VOID_t)
+{
+	v_UINT_t i;
+
+	for (i = 0; i < ARRAY_SIZE(vos_allocs); i++)
+		vos_allocs[i].occupied = 0;
+}
+
+v_VOID_t vos_trace_prealloc_occupied(v_VOID_t)
+{
+	int i;
+	printk("Memory allocs occupied:");
+
+	for (i = 0; i < ARRAY_SIZE(vos_allocs); i++) {
+		printk(" %d", vos_allocs[i].occupied);
+	}
+	printk("\n");
+}
+
+v_VOID_t *vos_prealloc_get(v_UINT_t size)
+{
+	v_UINT_t i = 0;
+
+	if (WLAN_IS_EPPING_ENABLED(vos_get_conparam()))
+		return NULL;
+
+	vos_trace_prealloc_occupied();
+	mutex_lock(&alloc_lock);
+	for (i = 0; i < ARRAY_SIZE(vos_allocs); i++) {
+		if (vos_allocs[i].occupied)
+			continue;
+		if (vos_allocs[i].size >= size) {
+			/* we found the slot */
+			vos_allocs[i].occupied = 1;
+			mutex_unlock(&alloc_lock);
+			vos_trace_prealloc_occupied();
+			return vos_allocs[i].ptr;
+		}
+	}
+	vos_trace_prealloc_occupied();
+	VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_FATAL,
+		"vos_pre: %s: prealloc not available at size %d\n", __func__, size);
+	mutex_unlock(&alloc_lock);
+	return NULL;
+}
+
+v_SINT_t vos_prealloc_put(v_VOID_t *ptr)
+{
+	v_UINT_t i = 0;
+
+	if (WLAN_IS_EPPING_ENABLED(vos_get_conparam()))
+		return 0;
+	mutex_lock(&alloc_lock);
+	for (i = 0; i < ARRAY_SIZE(vos_allocs); i++) {
+		if (vos_allocs[i].ptr == ptr) {
+			vos_allocs[i].occupied = 0;
+			mutex_unlock(&alloc_lock);
+			return 1;
+		}
+	}
+	mutex_unlock(&alloc_lock);
+	return 0;
+}
+#endif /* CONFIG_VOS_MEM_PRE_ALLOC */
+
 #ifdef MEMORY_DEBUG
 #ifdef MEM_USAGE_TRACE
 static void
@@ -413,7 +530,7 @@ v_VOID_t *vos_mem_malloc_debug(v_SIZE_t size, const char *fileName,
        flags = GFP_ATOMIC;
    }
 
-#ifdef CONFIG_WCNSS_MEM_PRE_ALLOC
+#if defined(CONFIG_WCNSS_MEM_PRE_ALLOC)
    if (size > WCNSS_PRE_ALLOC_GET_THRESHOLD)
    {
       v_VOID_t *pmem;
@@ -423,6 +540,14 @@ v_VOID_t *vos_mem_malloc_debug(v_SIZE_t size, const char *fileName,
          return pmem;
       }
    }
+#elif defined(CONFIG_VOS_MEM_PRE_ALLOC)
+	if (size > VOS_PRE_ALLOC_GET_THRESHOLD)
+	{
+		v_VOID_t *pmem;
+		pmem = vos_prealloc_get(size);
+		if (NULL != pmem)
+			return pmem;
+	}
 #endif
 
    new_size = size + sizeof(struct s_vos_mem_struct) + 8;
@@ -480,9 +605,12 @@ v_VOID_t vos_mem_free( v_VOID_t *ptr )
         VOS_STATUS vosStatus;
         struct s_vos_mem_struct* memStruct = ((struct s_vos_mem_struct*)ptr) - 1;
 
-#ifdef CONFIG_WCNSS_MEM_PRE_ALLOC
+#if defined(CONFIG_WCNSS_MEM_PRE_ALLOC)
         if (wcnss_prealloc_put(ptr))
             return;
+#elif defined(CONFIG_VOS_MEM_PRE_ALLOC)
+		if (vos_prealloc_put(ptr))
+   			return;
 #endif
 
         spin_lock_irqsave(&vosMemList.lock, IrqFlags);
@@ -521,7 +649,7 @@ v_VOID_t vos_mem_free( v_VOID_t *ptr )
 v_VOID_t * vos_mem_malloc( v_SIZE_t size )
 {
    int flags = GFP_KERNEL;
-#ifdef CONFIG_WCNSS_MEM_PRE_ALLOC
+#if defined(CONFIG_WCNSS_MEM_PRE_ALLOC) || defined(CONFIG_VOS_MEM_PRE_ALLOC)
     v_VOID_t* pmem;
 #endif
    v_VOID_t* memPtr = NULL;
@@ -538,7 +666,7 @@ v_VOID_t * vos_mem_malloc( v_SIZE_t size )
    {
       flags = GFP_ATOMIC;
    }
-#ifdef CONFIG_WCNSS_MEM_PRE_ALLOC
+#if defined(CONFIG_WCNSS_MEM_PRE_ALLOC)
    if(size > WCNSS_PRE_ALLOC_GET_THRESHOLD)
    {
        pmem = wcnss_prealloc_get(size);
@@ -547,6 +675,13 @@ v_VOID_t * vos_mem_malloc( v_SIZE_t size )
            return pmem;
        }
    }
+#elif defined(CONFIG_VOS_MEM_PRE_ALLOC)
+	if(size > VOS_PRE_ALLOC_GET_THRESHOLD)
+	{
+		pmem = vos_prealloc_get(size);
+		if(NULL != pmem)
+			return pmem;
+	}
 #endif
    time_before_kmalloc = vos_timer_get_system_time();
    memPtr = kmalloc(size, flags);
@@ -571,9 +706,12 @@ v_VOID_t vos_mem_free( v_VOID_t *ptr )
     if (ptr == NULL)
       return;
 
-#ifdef CONFIG_WCNSS_MEM_PRE_ALLOC
+#if defined(CONFIG_WCNSS_MEM_PRE_ALLOC)
     if(wcnss_prealloc_put(ptr))
         return;
+#elif defined(CONFIG_VOS_MEM_PRE_ALLOC)
+    if(vos_prealloc_put(ptr))
+        return;
 #endif
 
     kfree(ptr);
diff --git a/Kbuild b/Kbuild
index aad48a3..22f776c 100644
--- a/Kbuild
+++ b/Kbuild
@@ -288,6 +288,10 @@ ifeq ($(CONFIG_ROME_IF),pci)
 	CONFIG_EXT_WOW := 1
 endif
 
+ifeq ($(CONFIG_ROME_IF),usb)
+	CONFIG_EXT_WOW := 1
+endif
+
 #Set this to 1 to catch erroneous Target accesses during debug.
 CONFIG_ATH_PCIE_ACCESS_DEBUG := 0
 
@@ -441,6 +445,10 @@ ifeq ($(CONFIG_WLAN_FEATURE_NAN_DATAPATH),y)
 HDD_OBJS += $(HDD_SRC_DIR)/wlan_hdd_nan_datapath.o
 endif
 
+ifeq ($(CONFIG_DIRECT_AUDIO),y)
+HDD_OBJS += $(HDD_SRC_DIR)/wlan_hdd_direct_audio.o
+endif
+
 ############ EPPING ############
 EPPING_DIR :=	CORE/EPPING
 EPPING_INC_DIR :=	$(EPPING_DIR)/inc
@@ -1553,6 +1561,41 @@ ifeq ($(CONFIG_WLAN_FEATURE_NAN_DATAPATH),y)
 CDEFINES += -DWLAN_FEATURE_NAN_DATAPATH
 endif
 
+ifeq ($(CONFIG_DIRECT_AUDIO),y)
+CDEFINES += -DDIRECT_AUDIO_SUPPORT
+ifeq ($(CONFIG_ROME_IF),usb)
+CDEFINES += -DCONFIG_CONTX_USB_DEBUG
+endif
+endif
+
+ifeq ($(CONFIG_VOS_MEM_PRE_ALLOC),y)
+CDEFINES += -DCONFIG_VOS_MEM_PRE_ALLOC
+endif
+
+ifeq ($(CONFIG_USB_PRELOAD),y)
+CDEFINES += -DCONFIG_USB_PRELOAD
+endif
+
+ifeq ($(CONFIG_SS_REGULATORY),y)
+CDEFINES += -DSS_REGULATORY
+endif
+
+ifeq ($(CONFIG_FWCRASH_DUMP),y)
+CDEFINES += -DCONFIG_CRASH_DUMP_CLD
+CDEFINES += -DCONFIG_CRASH_DUMP_STACK
+CDEFINES += -DCONFIG_WLAN_FWLOG_FILE
+endif
+
+ifeq ($(CONFIG_CUST_PLATFORM),y)
+CDEFINES += -DCONFIG_CUST_PLATFORM
+endif
+
+ifeq ($(CONFIG_VD_PREVENT),y)
+CDEFINES += -DCONFIG_VD_PREVENT_DEADCODE
+CDEFINES += -DCONFIG_VD_PREVENT_NO_EFFECT
+CDEFINES += -DCONFIG_VD_PREVENT_MISSING_BREAK
+endif
+
 ifeq ($(CONFIG_DPTRACE_ENABLE), y)
 CDEFINES += -DFEATURE_DPTRACE_ENABLE
 endif
diff --git a/firmware_bin/WCNSS_qcom_cfg.usb.ini b/firmware_bin/WCNSS_qcom_cfg.usb.ini
index e830762..7a02f80 100644
--- a/firmware_bin/WCNSS_qcom_cfg.usb.ini
+++ b/firmware_bin/WCNSS_qcom_cfg.usb.ini
@@ -2,6 +2,8 @@
 
 # defaults for the WLAN Driver
 
+gSoftApMaxPeers=4
+gGoMaxPeers=10
 
 # Enable IMPS or not
 gEnableImps=1
@@ -101,7 +103,7 @@ hostNSOffload=1
 
 #Flag to enable IPChkSumOffld feature or not
 
-gEnableIPChecksumOffload=0
+gEnableIPChecksumOffload=1
 
 #SoftAP Related Parameters
 
@@ -142,7 +144,7 @@ gFixedRate=0
 
 # RTS threshold
 
-RTSThreshold=192000
+RTSThreshold=1048576
 
 
 # Intra-BSS forward
@@ -157,12 +159,15 @@ WmmIsEnabled=0
 
 # 802.11d support
 
-g11dSupportEnabled=1
+g11dSupportEnabled=0
 
 # 802.11h support
 
 g11hSupportEnabled=1
 
+# DFS Master Capability
+gEnableDFSMasterCap=0
+
 # ESE Support and fast transition
 EseEnabled=0
 ImplicitQosIsEnabled=0
@@ -178,7 +183,9 @@ gMaxNeighborReqTries=3
 # Legacy (non-ESE, non-802.11r) Fast Roaming Support
 # To enable, set FastRoamEnabled=1
 # To disable, set FastRoamEnabled=0
-FastRoamEnabled=1
+FastRoamEnabled=0
+gRoamBmissFirstBcnt=0
+gRoamBmissFinalBcnt=0
 
 #Check if the AP to which we are roaming is better than current AP in terms of RSSI.
 #Checking is disabled if set to Zero.Otherwise it will use this value as to how better
@@ -318,17 +325,17 @@ gStaKeepAlivePeriod = 30
 #gGoLinkMonitorPeriod/ gApLinkMonitorPeriod is period where link is idle and it is period
 #where we send NULL frame.
 
-#gApLinkMonitorPeriod = 10
+gApLinkMonitorPeriod = 30
 
-#gGoLinkMonitorPeriod = 10
+gGoLinkMonitorPeriod = 10
 
 #gGoKeepAlivePeriod/gApKeepAlivePeriod is time to spend to check whether frame are succeed to send or not.
 #Hence total effective detection time is gGoLinkMonitorPeriod+ gGoKeepAlivePeriod/gApLinkMonitorPeriod+ gApKeepAlivePeriod.
 
 
-gGoKeepAlivePeriod = 20
+gGoKeepAlivePeriod = 3
 
-gApKeepAlivePeriod = 20
+gApKeepAlivePeriod = 10
 
 
 #If set will start with active scan after driver load, otherwise will start with
@@ -342,9 +349,11 @@ gEnableBypass11d=1
 
 gEnableDFSChnlScan=1
 
+# Enable DFS channel roam
+# 0: DISABLE, 1: ENABLED_NORMAL, 2: ENABLED_ACTIVE
+gAllowDFSChannelRoam=1
 
 gVhtChannelWidth=2
-gEnableLogp=1
 
 
 # Enable Automatic Tx Power control
@@ -367,18 +376,43 @@ gVhtTxMCS=2
 # Valid values are 0,1,2. If commented out, the default value is 0.
 # 0=MCS0-7, 1=MCS0-8, 2=MCS0-9
 gEnable2x2=1
-gVhtRxMCS2x2=0
+gVhtRxMCS2x2=2
 gVhtTxMCS2x2=2
 
+
+# Valid chain mask values
+# 01 - enables chain0
+# 02 - enables chain1
+# 03 - enables both chain 0 and chain 1
+# if set to 0 or 1 then all vdevs comes up in 1x1 mode in that band.
+gChainMask_2g=3
+gChainMask_5g=3
+
+# NSS cfg bit definition.
+# STA          BIT[0:1]
+# SAP          BIT[2:3]
+# P2P_GO       BIT[4:5]
+# P2P_CLIENT   BIT[6:7]
+# IBSS         BIT[8:9]
+# TDLS         BIT[10:11]
+# P2P_DEVICE   BIT[12:13]
+# OCB          BIT[14:15]
+# Valid values are 1 or 2 for each two bit configuration.
+# if 2-bit value is set to 1 then the corresponidng vdev comes up in 1x1 mode
+# in the band, if set to 2 then that vdev comes up in 2x2 mode in that band.
+gVdevTypeNss_2g=43690
+gVdevTypeNss_5g=43690
 # Scan Timing Parameters
 # gPassiveMaxChannelTime=110
 # gPassiveMinChannelTime=60
-# gActiveMaxChannelTime=40
-# gActiveMinChannelTime=20
+gActiveMaxChannelTime=80
+gActiveMinChannelTime=40
 
 #If set to 0, MCC is not allowed.
 gEnableMCCMode=1
 
+# MCC to SCC Switch mode: 0-Disable 1-Enable 2-Force SCC if same band
+gWlanMccToSccSwitchMode = 0
 # 1=enable STBC; 0=disable STBC
 gEnableRXSTBC=1
 
@@ -388,6 +422,11 @@ gEnableTXSTBC=1
 # 1=enable rx LDPC; 0=disable
 gEnableRXLDPC=1
 
+# Enable Tx beamforming in VHT20MHz
+# Valid values are 0,1. If commented out, the default value is 0.
+# 0=disable, 1=enable
+gEnableTxBFin20MHz=1
+
 # Enable Active mode offload
 gEnableActiveModeOffload=1
 
@@ -396,20 +435,16 @@ gEnableActiveModeOffload=1
 #If Set to 0 it will not enable the feature
 gScanAgingTime=0
 
+#Enable Scan Results Aging based on number of scans
+gScanResultAgeCount=1
+
 #Enable Power saving mechanism Based on Android Framework
 #If set to 0 Driver internally control the Power saving mechanism
 #If set to 1 Android Framwrok control the Power saving mechanism
 isAndroidPsEn=0
 
-#disable LDPC in STA mode if the AP is TXBF capable
-gDisableLDPCWithTxbfAP=1
-
 #Enable thermal mitigation
-gThermalMitigationEnable=1
-gThermalTempMinLevel1=90
-gThermalTempMaxLevel0=110
-gThermalTempMaxLevel1=115
-gThrottlePeriod=100
+gThermalMitigationEnable=0
 
 gEnableFastRoamInConcurrency=1
 
@@ -437,7 +472,7 @@ gFlexConnectPowerFactor=0
 gNumChanCombinedConc=60
 
 #Enable Power Save offload
-gEnablePowerSaveOffload=1
+gEnablePowerSaveOffload=2
 
 #Enable firmware uart print
 gEnablefwprint=0
@@ -445,8 +480,11 @@ gEnablefwprint=0
 #Enable firmware log
 gEnablefwlog=1
 
+gFwDebugLogLevel=6
+#gFwDebugModuleLoglevel=1,0,2,0,4,0,5,0,6,0,7,4,8,0,9,0,11,0,13,0,17,0,18,0,19,0,27,0,29,0,31,0,35,0,36,0,38,0
+
 #IPA config
-gIPAEnable=1
+gIPAConfig=0
 gIPADescSize=800
 gIPAPreFilterEnable=1
 gIPARMEnable=1
@@ -458,7 +496,7 @@ gEnableP2pListenOffload=1
 gVhtAmpduLenExponent=7
 
 # Maximum MPDU length (VHT only. Valid values: 0->3895 octets, 1->7991 octets, 2->11454 octets)
-gVhtMpduLen=0
+gVhtMpduLen=2
 
 # Maximum number of wow filters required
 #gMaxWoWFilters=22
@@ -475,8 +513,55 @@ gVhtMpduLen=0
 # 1=Enable (default), 0=Disable
 gEnableMCCAdaptiveScheduler=1
 
+# RX packet handling options
+# 0: no rx thread, no RPS, for MDM
+# 1: RX thread
+# 2: RPS
+rxhandle=1
+
+# Set Thermal Power limit
+TxPower2g=10
+TxPower5g=10
+
+# Remove Overlap channel restriction
+gEnableOverLapCh=0
+
+#Enable or Disable 5G early beacon termination
+gEnable5gEBT=1
+# controlling the following offload patterns
+# through ini parameter. Default value is 1
+# to disable set it to zero. ssdp = 0
+# Setup multicast pattern for mDNS 224.0.0.251,
+# SSDP 239.255.255.250 and LLMNR 224.0.0.252
+
+
+ssdp = 0
+#Enable Memory Deep Sleep
+gEnableMemDeepSleep=1
+
+# Maximum number of concurrent connections
+gMaxConcurrentActiveSessions=2
+
+# Disable/Enable GreenAP
+# 0 to disable, 1 to enable, default: 1
+gEnableGreenAp=1
+
+# Whether userspace country code setting shld have priority
+gCountryCodePriority=1
+
+# Enable(1)/Disable(0) SIFS burst
+gEnableSifsBurst=1
+
+# Enable/Disable channel avoidance for SAP in SCC scenario
+# 0 - disable
+# 1 - enable
+gSapSccChanAvoidance=0
+
+# Inactivity time (in ms) to end TX Service Period while in IBSS power save mode
+gIbssTxSpEndInactivityTime=10
+
 #Enable or Disable p2p device address administered
-isP2pDeviceAddrAdministrated=0
+isP2pDeviceAddrAdministrated=1
 
 #Disable scan_pno by default
 gPNOScanSupport=0
@@ -484,82 +569,86 @@ gPNOScanSupport=0
 #Enable TDLS
 gEnableTDLSSupport=1
 
+# Enable support for Implicit Trigger of TDLS. That is, wlan driver shall
+# initiate TDLS Discovery towards a peer whenever setup criteria (throughput
+# and RSSI) is met and then will initiate teardown when teardown criteria
+# (idle packet count and RSSI) is met.
+#  0 - disable
+#  1 - enable
+gEnableTDLSImplicitTrigger=1
+
+# Enable TDLS External Control. That is, user space application has to
+# first configure a peer MAC in wlan driver towards which TDLS is desired.
+# Device will establish TDLS only towards those configured peers whenever
+# TDLS criteria (throughput and RSSI threshold) is met and teardown TDLS
+# when teardown criteria (idle packet count and RSSI) is met. However,
+# device will accept TDLS connection if it is initiated from any other peer,
+# even if that peer is not configured.
+#  0 - disable
+#  1 - enable
+# For TDLS External Control, Implicit Trigger must also be enabled.
+gTDLSExternalControl=1
+
+# Enable support for TDLS off-channel operation
+#  0 - disable
+#  1 - enable
+# TDLS off-channel operation will be invoked when there is only one
+# TDLS connection.
+gEnableTDLSOffChannel=1
+
 # Regulatory Setting; 0=STRICT; 1=CUSTOM
 gRegulatoryChangeCountry=1
 
+gCountryCodePriority=0
+
 # Disable FW log function by default
 gFwDebugLogType=0
-gFwDebugModuleLoglevel=0,0
-
-# Enable or Disable Rx thread
-# 1=Enable (default), 0=Disable
-gEnableRxThread=0
+#gFwDebugModuleLoglevel=0,0
 
 # Enable or Disable FW self-recovery
 # Currently, It's for USB only.
 # 1=Enable, 0=Disable (default)
 gEnableFwSelfRecovery=0
 
-# Enable or Disable SAP suspend
-# 1=Enable (default), 0=Disable
-gEnableSapSuspend=0
-
 # Enable TxBF
 gTxBFEnable=1
 
-# Enable or Disable DHCP Server offload
-# 1=Enable, 0=Disable (default)
-gDHCPServerOffloadEnable=0
-# Set max number of DHCP Clients
-# Its value could not be greater than 10
-#gDHCPMaxNumClients=10
-# Set DHCP server IP
-# 4th field could not be greater than 99, that is xxx,xxx,xxx,0 ~ xxx,xxx,xxx,99
-# 1st field could not be within the range of 224 ~ 239 (multicast IP address)
-#gDHCPServerIP=192,168,1,2
-
-# gEnableSAPAuthOffload: Enable Software AP Authentication Offload feature
+# Enable/Disable Roaming Offload Support (a.k.a Key Management Offload)
+# 0 to disable, 1 to enable
+gRoamOffloadEnabled=0
+
+# Enable or Disable Random MAC (Spoofing)
 # 1=Enable, 0=Disable (default)
-gEnableSAPAuthOffload=0
-# gSAPAuthOffloadSec: Software AP Authentication Offload security Type, 0: disabled, 1: WPA2-PSK CCMP
-# gSAPAuthOffloadSec=1
-# gSAPAuthOffloadKey: Passphrase of Security
-# gSAPAuthOffloadKey=12345678
+gEnableMacAddrSpoof=0
 
+# Enable to check FW hash if secure FW feature is enabled. It's for defconfig
+# builds only since it will be ignored in performance/release builds.
+gEnableFWHashCheck=1
 
-# Enable or Disable UDP response offload feature
-# 1=Enable, 0=Disable (default)
-gudp_resp_offload_support=0
-# Set UDP packet dest port
-# It's value is between 0 and 65535
-# Default is 0
-# gudp_resp_offload_dest_port=0
-# Set UDP payload filter
-# It is only include Arabic numerals and English letter
-# It's length should be between 1 and 127
-# gudp_resp_offload_payload_filter=require status
-# Set UDP response payload
-# It is only include Arabic numerals and English letter
-# It's length should be between 1 and 127
-# gudp_resp_offload_response_payload=status=off
-
-
-
-
-# Enable or Disable WOW Pulse feature
-# 1 = Enable, 0 = Disable (default)
-gwow_pulse_support = 0
-# GPIO PIN
-# It's value is between 0 and 255
-# Default is 35
-# gwow_pulse_pin = 35
-# Set WOW Pulse interval low
-# It's value is between 160 and 480
-# gwow_pulse_interval_low = 180
-# Set WOW Pulse interval high
-# It's value is between 20 and 40
-# gwow_pulse_interval_high = 20
+gTxLdpcEnable=3
+gEnableMuBformee=1
+
+#Auto Shutdown wlan : Value in Seconds. 0 means disabled. Max 1 day = 86400 sec
+gWlanAutoShutdown = 0
+
+gEnableLpassSupport=0
+# intervals length (in ms) during WLAN P2P (single vdev) + BT Paging
+# min 20ms, max 200ms
+gBTIntervalPageP2P=0
+gWLIntervalPageP2P=0
+
+# intervals length (in ms) during WLAN STA (single vdev) + BT Paging
+# min 20ms, max 200ms
+gBTIntervalPageSTA=0
+gWLIntervalPageSTA=0
+
+# intervals length (in ms) during WLAN SAP (single vdev) + BT Paging
+# min 20ms, max 200ms
+gBTIntervalPageSAP=0
+gWLIntervalPageSAP=0
+gEnableVhtFor24GHzBand=1
 
+gExtWowApp1WakeupPinNumber=35
 
 END
 
