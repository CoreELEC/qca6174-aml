diff -uNr qcacld-2.0/CORE/CLD_TXRX/HTT/htt.c qcacld-2.0-new/CORE/CLD_TXRX/HTT/htt.c
--- qcacld-2.0/CORE/CLD_TXRX/HTT/htt.c	2015-10-20 10:18:50.000000000 +0800
+++ qcacld-2.0-new/CORE/CLD_TXRX/HTT/htt.c	2015-10-28 19:17:05.000000000 +0800
@@ -314,6 +314,12 @@
     return NULL;
 }
 
+void htt_pdev_set_sniffer_channel(htt_pdev_handle pdev, unsigned char channel, int freq)
+{
+	pdev->sniffer_channel = channel;
+	pdev->sniffer_center_freq = freq;
+}
+
 A_STATUS
 htt_attach_target(htt_pdev_handle pdev)
 {
diff -uNr qcacld-2.0/CORE/CLD_TXRX/HTT/htt_h2t.c qcacld-2.0-new/CORE/CLD_TXRX/HTT/htt_h2t.c
--- qcacld-2.0/CORE/CLD_TXRX/HTT/htt_h2t.c	2015-10-20 10:18:50.000000000 +0800
+++ qcacld-2.0-new/CORE/CLD_TXRX/HTT/htt_h2t.c	2015-10-28 19:17:17.000000000 +0800
@@ -227,6 +227,7 @@
 #ifndef REMOVE_PKT_LOG
  if (ol_cfg_is_packet_log_enabled(pdev->ctrl_pdev))
    {
+	   printk(KERN_ERR"okkwon : pktlog_enabled\n");
        enable_ctrl_data = 1;
        enable_mgmt_data = 1;
        enable_null_data = 1;
@@ -240,6 +241,7 @@
    }
    else
    {
+	   printk(KERN_ERR"okkwon : pktlog_disabled\n");
        adf_os_print("Pkt log is disabled\n");
        enable_ctrl_data = 0;
        enable_mgmt_data = 0;
@@ -248,6 +250,8 @@
        enable_hdr       = 0;
        enable_ppdu_start= 0;
        enable_ppdu_end  = 0;
+	   /* okkwon to do : auto config for this disable_aspm */
+       htt_htc_disable_aspm();
    }
 #else
     enable_ctrl_data = 0;
diff -uNr qcacld-2.0/CORE/CLD_TXRX/HTT/htt_rx.c qcacld-2.0-new/CORE/CLD_TXRX/HTT/htt_rx.c
--- qcacld-2.0/CORE/CLD_TXRX/HTT/htt_rx.c	2015-10-20 10:18:50.000000000 +0800
+++ qcacld-2.0-new/CORE/CLD_TXRX/HTT/htt_rx.c	2015-10-28 19:18:01.000000000 +0800
@@ -39,6 +39,8 @@
  *      rx ring (applies to LL only).
  */
 
+#include <net/ieee80211_radiotap.h>
+
 #include <adf_os_mem.h>   /* adf_os_mem_alloc,free, etc. */
 #include <adf_os_types.h> /* adf_os_print, a_bool_t */
 #include <adf_nbuf.h>     /* adf_nbuf_t, etc. */
@@ -58,6 +60,9 @@
 #include <wma_api.h>
 #endif
 
+#include <linux/ieee80211.h>
+#include <net/cfg80211.h>
+
 #ifdef DEBUG_DMA_DONE
 extern int process_wma_set_command(int sessid, int paramid,
                                    int sval, int vpdev);
@@ -93,6 +98,14 @@
 #define HTT_RX_RING_REFILL_RETRY_TIME_MS    50
 #endif
 
+/* FIXME: This is a HW definition not provded by HW, where does it go ? */
+enum {
+    HW_RX_DECAP_FORMAT_RAW = 0,
+    HW_RX_DECAP_FORMAT_NWIFI,
+    HW_RX_DECAP_FORMAT_8023,
+    HW_RX_DECAP_FORMAT_ETH2,
+};
+
 static int
 CEIL_PWR2(int value)
 {
@@ -831,6 +844,800 @@
 #define MAX_DONE_BIT_CHECK_ITER 5
 #endif
 
+enum htt_rx_mpdu_encrypt_type {
+	HTT_RX_MPDU_ENCRYPT_WEP40            = 0,
+	HTT_RX_MPDU_ENCRYPT_WEP104           = 1,
+	HTT_RX_MPDU_ENCRYPT_TKIP_WITHOUT_MIC = 2,
+	HTT_RX_MPDU_ENCRYPT_WEP128           = 3,
+	HTT_RX_MPDU_ENCRYPT_TKIP_WPA         = 4,
+	HTT_RX_MPDU_ENCRYPT_WAPI             = 5,
+	HTT_RX_MPDU_ENCRYPT_AES_CCM_WPA2     = 6,
+	HTT_RX_MPDU_ENCRYPT_NONE             = 7,
+};
+
+static int htt_rx_crypto_param_len(enum htt_rx_mpdu_encrypt_type type)
+{
+	switch (type) {
+		case HTT_RX_MPDU_ENCRYPT_WEP40:
+		case HTT_RX_MPDU_ENCRYPT_WEP104:
+			return 4;
+		case HTT_RX_MPDU_ENCRYPT_TKIP_WITHOUT_MIC:
+		case HTT_RX_MPDU_ENCRYPT_WEP128: /* not tested */
+		case HTT_RX_MPDU_ENCRYPT_TKIP_WPA:
+		case HTT_RX_MPDU_ENCRYPT_WAPI: /* not tested */
+		case HTT_RX_MPDU_ENCRYPT_AES_CCM_WPA2:
+			return 8;
+		case HTT_RX_MPDU_ENCRYPT_NONE:
+			return 0;
+	}
+
+	return 0;
+}
+
+struct rfc1042_hdr {
+	u8 llc_dsap;
+	u8 llc_ssap;
+	u8 llc_ctrl;
+	u8 snap_oui[3];
+	__be16 snap_type;
+} __packed;
+
+struct amsdu_subframe_hdr {
+	u8 dst[ETH_ALEN];
+	u8 src[ETH_ALEN];
+	__be16 len;
+} __packed;
+
+static int htt_rx_radiotap_space(struct htt_host_rx_desc_base *rxd)
+{
+	int len;
+
+	/* always present fields */
+	len = sizeof(struct ieee80211_radiotap_header) + 8;
+
+	if (rxd->ppdu_start.preamble_type == 0x8 ||
+			rxd->ppdu_start.preamble_type == 0x9)
+	{
+		/* HT */
+		len += 3;
+	}
+
+	if (rxd->ppdu_start.preamble_type == 0xc ||
+			rxd->ppdu_start.preamble_type == 0xd)
+	{
+		/* VHT */
+		len += 12;
+	}
+
+	return len;
+}
+
+static const u8 rx_legacy_rate_idx[] = {
+	3,	/* 0x00  - 11Mbps  */
+	2,	/* 0x01  - 5.5Mbps */
+	1,	/* 0x02  - 2Mbps   */
+	0,	/* 0x03  - 1Mbps   */
+	3,	/* 0x04  - 11Mbps  */
+	2,	/* 0x05  - 5.5Mbps */
+	1,	/* 0x06  - 2Mbps   */
+	0,	/* 0x07  - 1Mbps   */
+	10,	/* 0x08  - 48Mbps  */
+	8,	/* 0x09  - 24Mbps  */
+	6,	/* 0x0A  - 12Mbps  */
+	4,	/* 0x0B  - 6Mbps   */
+	11,	/* 0x0C  - 54Mbps  */
+	9,	/* 0x0D  - 36Mbps  */
+	7,	/* 0x0E  - 18Mbps  */
+	5,	/* 0x0F  - 9Mbps   */
+};
+
+static const u16 rx_legacy_bitrate[] = {
+	10,
+	20,
+	55,
+	110,
+	60,
+	90,
+	120,
+	180,
+	240,
+	360,
+	480,
+	540,
+};
+
+static int htt_set_rx_radiotap_header(
+		htt_pdev_handle pdev,
+		adf_nbuf_t skb,
+		struct htt_host_rx_desc_base *rxd)
+{
+	int rtap_len;
+	struct ieee80211_radiotap_header *rthdr;
+	unsigned char rthdr_buff[30];
+	unsigned char * pos;
+	int mpdulen;
+	__le32 *it_present;
+	u32 it_present_val;
+	int preamble_type;
+	u16 channel_flags = 0;
+	uint8_t * new_head;
+	u32 info0, info1, info2;
+	u8 cck, rate, rate_idx;
+	u16 bitrate;
+
+	rtap_len = htt_rx_radiotap_space(rxd);
+
+	mpdulen = skb->len;
+	mpdulen += 4;	/* FCS len */
+
+	rthdr = (struct ieee80211_radiotap_header *)rthdr_buff;
+	memset(rthdr, 0, rtap_len);
+	it_present = &rthdr->it_present;
+
+	/* radiotap header, set always present flags */
+	rthdr->it_len = cpu_to_le16(rtap_len);
+	it_present_val = BIT(IEEE80211_RADIOTAP_FLAGS) |
+		BIT(IEEE80211_RADIOTAP_CHANNEL);
+
+	put_unaligned_le32(it_present_val, it_present);
+
+	pos = (void *)(it_present + 1);
+
+	if (rxd->attention.fcs_err) {
+		/* FCS error */
+		*pos |= IEEE80211_RADIOTAP_F_BADFCS;
+	}
+
+	*pos |= IEEE80211_RADIOTAP_F_FCS;
+	pos++;
+
+	preamble_type = rxd->ppdu_start.preamble_type;
+
+	info0 = rxd->ppdu_start.ht_sig_vht_sig_a_1;
+	info1 = rxd->ppdu_start.ht_sig_vht_sig_a_2;
+	info2 = rxd->ppdu_start.vht_sig_b;
+
+	if (preamble_type == 0x4) {
+		/* legacy preamble */
+		rthdr->it_present |= cpu_to_le32(1 << IEEE80211_RADIOTAP_RATE);
+		cck = rxd->ppdu_start.l_sig_rate_select;
+		rate = rxd->ppdu_start.l_sig_rate;
+		rate_idx = 0;
+
+		if (rate >= 0x8 && rate <= 0x0f) {
+			if (pdev->sniffer_channel < 15) {
+				if (cck)
+					rate &= ~BIT(3);
+			}
+			rate_idx = rx_legacy_rate_idx[rate];
+			bitrate = rx_legacy_bitrate[rate_idx];
+			*pos = DIV_ROUND_UP(bitrate, 5);
+		}
+	} else {
+		/* HT || VHT */
+		*pos = 0;
+	}
+	pos ++;
+
+	*pos = pdev->sniffer_center_freq & 0xff;
+	pos++;
+	*pos = (pdev->sniffer_center_freq & 0xff00) >> 8;
+	pos++;
+
+	if(pdev->sniffer_channel > 15) {
+		channel_flags |= IEEE80211_CHAN_OFDM | IEEE80211_CHAN_5GHZ;
+	} else if(preamble_type != 0x4) {
+		channel_flags |= IEEE80211_CHAN_DYN | IEEE80211_CHAN_2GHZ;
+	} else if(!cck) {
+		channel_flags |= IEEE80211_CHAN_OFDM | IEEE80211_CHAN_2GHZ;
+	} else {
+		channel_flags |= IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_CCK;
+	}
+
+	*pos = channel_flags & 0xff;
+	pos++;
+	*pos = (channel_flags & 0xff00) >> 8;
+	pos++;
+
+	*pos = -96 + rxd->ppdu_start.rssi_comb;
+	rthdr->it_present |= 1 << IEEE80211_RADIOTAP_DBM_ANTSIGNAL;
+	pos++;
+
+	/* HT preamble */
+	if (preamble_type == 0x8 || preamble_type == 0x9) {
+		rthdr->it_present |= cpu_to_le32(1 << IEEE80211_RADIOTAP_MCS);
+		*pos++ = IEEE80211_RADIOTAP_MCS_HAVE_MCS |
+			IEEE80211_RADIOTAP_MCS_HAVE_GI |
+			IEEE80211_RADIOTAP_MCS_HAVE_BW |
+			IEEE80211_RADIOTAP_MCS_HAVE_FEC;
+		*pos = 0;
+		if (info1 & (1<<7)) 
+			*pos |= IEEE80211_RADIOTAP_MCS_SGI;
+		if (info0 & (1<<7))
+			*pos |= IEEE80211_RADIOTAP_MCS_BW_40;
+		if (rxd->ppdu_start.is_greenfield)
+			*pos |= IEEE80211_RADIOTAP_MCS_FMT_GF;
+		if (info1 & (1<<8)) 
+			*pos |= IEEE80211_RADIOTAP_MCS_FEC_LDPC;
+		if (info1 & (3<<4))
+			*pos |= (1<<4);	/* stbc */
+		pos++;
+		*pos++ = info1 & 0x1f; /* okkwon todo : set rate index */
+	}
+
+	if(preamble_type == 0xc || preamble_type == 0xd) {
+		while ((pos - (u8*)rthdr)%4)
+			pos ++;
+		rthdr->it_present |= cpu_to_le32(1 << IEEE80211_RADIOTAP_VHT);
+		put_unaligned_le16(IEEE80211_RADIOTAP_VHT_KNOWN_GI |
+				IEEE80211_RADIOTAP_VHT_KNOWN_BANDWIDTH |
+				IEEE80211_RADIOTAP_VHT_KNOWN_STBC |
+				IEEE80211_RADIOTAP_VHT_KNOWN_BEAMFORMED, pos);
+		pos += 2;
+		if (info1 & 0x1)
+			*pos |= IEEE80211_RADIOTAP_VHT_FLAG_SGI;
+		if (info0 & (1<<3))
+			*pos |= IEEE80211_RADIOTAP_VHT_FLAG_STBC;
+		if (info1 & (1<<8))
+			*pos |= IEEE80211_RADIOTAP_VHT_FLAG_BEAMFORMED;
+		pos++;
+		switch ((info0 & 0x3)){
+			case 2:
+				*pos++ = 4;
+				break;
+			case 3:
+				*pos++ = 11;
+				break;
+			case 1:
+				*pos++ = 1;
+				break;
+			case 0:
+				*pos++ = 0;
+				break;
+		}
+		*pos = (((info1&0xf0)>>4) << 4) | (((info0>>10) & 0x07) +1);
+		pos += 4;
+		if (info1 & (1<<2))
+			*pos |= 0x01;
+		pos++;
+		/* group ID */
+		pos++;
+		/* partial AID */
+		pos+=2;
+	}
+	
+	if (adf_nbuf_headroom(skb) < rtap_len &&
+			/* okkwon much overhead -_-? */
+			! adf_nbuf_expand(skb, rtap_len, 0)) {
+		return -1;
+	}
+
+	adf_nbuf_push_head(skb, rtap_len);
+	new_head = adf_nbuf_data(skb);
+	if(new_head) 
+		memcpy(new_head, rthdr_buff, rtap_len);
+
+	return 0;
+}
+
+adf_nbuf_t htt_sniffer_restitch_amsdu (adf_nbuf_t head_msdu) {
+	adf_nbuf_t msdu, prev_buf;
+	unsigned decap_format, wifi_hdr_len, sec_hdr_len, msdu_llc_len,
+			 dir,
+			 is_amsdu, msdu_len;
+	struct htt_host_rx_desc_base *rx_desc;
+	char *hdr_desc;
+	unsigned char *dest;
+	struct ieee80211_frame *wh;
+	struct ieee80211_qoscntl*qos;
+	int is_first_frag;
+
+	rx_desc = htt_rx_desc(head_msdu);
+
+	decap_format = rx_desc->msdu_start.decap_format;
+	hdr_desc = &rx_desc->rx_hdr_status[0];
+
+	/* Base size */
+	wifi_hdr_len = sizeof(struct ieee80211_frame);
+	wh = (struct ieee80211_frame*)hdr_desc;
+
+	dir = wh->i_fc[1] & IEEE80211_FC1_DIR_MASK;
+	if (dir == IEEE80211_FC1_DIR_DSTODS) {
+		wifi_hdr_len += 6;
+	}
+
+	is_amsdu = 0;
+	if (wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_QOS) {
+		qos = (struct ieee80211_qoscntl*)
+			(hdr_desc + wifi_hdr_len);
+		wifi_hdr_len += 2;
+
+		is_amsdu = (qos->i_qos[0] & IEEE80211_QOS_AMSDU);
+	}
+
+	/* TODO: Any security headers associated with MPDU */
+	sec_hdr_len = 0;
+
+	/* MSDU related stuff LLC - AMSDU subframe header etc */
+	msdu_llc_len = is_amsdu ? (14 + 8) : 8;
+
+	if (decap_format == 0) {
+		/* raw format */
+		prev_buf = head_msdu;
+
+		msdu_len = adf_nbuf_len(prev_buf);
+
+		/* Drop the zero-length msdu */
+		if (!msdu_len) {
+			printk(KERN_ERR"okkwon : %s msdu_len 0\n", __func__);
+			goto mpdu_stitch_fail;
+		}
+		msdu = adf_nbuf_next(head_msdu);
+		is_first_frag = 1;
+
+		while (msdu) {
+			msdu_len = adf_nbuf_len(msdu);
+			/* Drop the zero-length msdu */
+			if (!msdu_len) {
+				printk(KERN_ERR"okkwon : %s msdu_len 0 in loop\n", __func__);
+				goto mpdu_stitch_fail;
+			}
+
+			head_msdu = adf_nbuf_expand(head_msdu, 0, msdu_len);
+			if (!head_msdu) {
+				printk(KERN_ERR"okkwon : %s skb expand fail\n", __func__);
+				goto mpdu_stitch_fail;
+			}
+
+			dest = adf_nbuf_put_tail(head_msdu, msdu_len);
+			if (!dest) {
+				printk(KERN_ERR"okkwon : %s skb dest get failure\n", __func__);
+				goto mpdu_stitch_fail;
+			}
+			adf_os_mem_copy(dest, adf_nbuf_data(msdu), msdu_len);
+			printk(KERN_ERR"okkwon msdu_len %d\n", msdu_len);
+			print_hex_dump(KERN_ERR, "head:", 2, 16, 4, adf_nbuf_data(msdu), 16, 0);
+
+#if 0
+			msdu = adf_nbuf_expand(msdu,
+					HTT_RX_STD_DESC_RESERVATION + wifi_hdr_len + sec_hdr_len,
+					0);
+			if (!msdu) {
+				goto mpdu_stitch_fail;
+			}
+
+			dest = adf_nbuf_push_head(msdu, wifi_hdr_len + sec_hdr_len);
+			if (!dest) {
+				goto mpdu_stitch_fail;
+			}
+			adf_os_mem_copy(dest, hdr_desc, wifi_hdr_len + sec_hdr_len);
+			print_hex_dump(KERN_ERR, "hdr:", 2, 16, 4, hdr_desc, 50, 0);
+
+			dest = adf_nbuf_push_head(msdu, HTT_RX_STD_DESC_RESERVATION);
+			if (!msdu) {
+				goto mpdu_stitch_fail;
+			}
+			adf_os_mem_copy(dest, rx_desc, HTT_RX_STD_DESC_RESERVATION);
+			adf_nbuf_pull_head(msdu, HTT_RX_STD_DESC_RESERVATION);
+#endif
+
+			/* Move to the next */
+			prev_buf = msdu;
+			msdu = adf_nbuf_next(msdu);
+			if (is_first_frag) {
+				is_first_frag = 0;
+			} else {
+				adf_nbuf_set_next(prev_buf, NULL);
+				adf_nbuf_free(prev_buf);
+			}
+		}
+#if 0
+		adf_nbuf_trim_tail(prev_buf, 4);
+#endif
+
+		adf_nbuf_set_next(head_msdu, NULL);
+
+		goto mpdu_stitch_done;
+	} else {
+		printk(KERN_ERR"okkwon : decap format error\n");
+		goto mpdu_stitch_fail;
+	}
+
+mpdu_stitch_done:
+	return head_msdu;
+
+mpdu_stitch_fail:
+	return NULL;
+}
+
+struct htt_host_rx_desc_base rxd_backup;
+
+int
+htt_rx_sniffer_amsdu_pop_ll(
+    htt_pdev_handle pdev,
+    adf_nbuf_t rx_ind_msg,
+    adf_nbuf_t *head_msdu,
+    adf_nbuf_t *tail_msdu)
+{
+    int msdu_len, msdu_chaining = 0;
+    adf_nbuf_t msdu;
+    struct htt_host_rx_desc_base *rx_desc;
+    u_int8_t *rx_ind_data;
+    u_int32_t *msg_word, num_msdu_bytes;
+    enum htt_t2h_msg_type msg_type;
+	struct htt_host_rx_desc_base *rxd;
+	adf_nbuf_t skb;
+	int fmt;
+	adf_nbuf_t to_free = NULL;
+
+#if 0
+	if (htt_rx_ring_elems(pdev) == 0) {
+		/* okkwon todo : is this allowed -_-? */
+		printk(KERN_ERR"okkwon : %s ring elem 0\n", __func__);
+		head_msdu = NULL;
+		return 0;
+	}
+#endif
+
+    HTT_ASSERT1(htt_rx_ring_elems(pdev) != 0);
+    rx_ind_data = adf_nbuf_data(rx_ind_msg);
+    msg_word = (u_int32_t *)rx_ind_data;
+
+    msg_type = HTT_T2H_MSG_TYPE_GET(*msg_word);
+
+    if (adf_os_unlikely(HTT_T2H_MSG_TYPE_RX_FRAG_IND == msg_type)) {
+        num_msdu_bytes = HTT_RX_FRAG_IND_FW_RX_DESC_BYTES_GET(
+            *(msg_word + HTT_RX_FRAG_IND_HDR_PREFIX_SIZE32));
+    } else {
+        num_msdu_bytes = HTT_RX_IND_FW_RX_DESC_BYTES_GET(
+            *(msg_word + HTT_RX_IND_HDR_PREFIX_SIZE32 +
+            HTT_RX_PPDU_DESC_SIZE32));
+    }
+
+    msdu = *head_msdu = htt_rx_netbuf_pop(pdev);
+
+    while (1) {
+        int last_msdu, msdu_len_invalid, msdu_chained;
+        int byte_offset;
+
+        /*
+         * Set the netbuf length to be the entire buffer length initially,
+         * so the unmap will unmap the entire buffer.
+         */
+        adf_nbuf_set_pktlen(msdu, HTT_RX_BUF_SIZE);
+        adf_nbuf_unmap(pdev->osdev, msdu, ADF_OS_DMA_FROM_DEVICE);
+
+        /* cache consistency has been taken care of by the adf_nbuf_unmap */
+
+        /*
+         * Now read the rx descriptor.
+         * Set the length to the appropriate value.
+         * Check if this MSDU completes a MPDU.
+         */
+        rx_desc = htt_rx_desc(msdu);
+		
+		        /*
+         * Make the netbuf's data pointer point to the payload rather
+         * than the descriptor.
+         */
+        adf_nbuf_pull_head(msdu, HTT_RX_STD_DESC_RESERVATION);
+
+        /*
+		 * Sanity check - confirm the HW is finished filling in the rx data.
+		 * If the HW and SW are working correctly, then it's guaranteed that
+		 * the HW's MAC DMA is done before this point in the SW.
+		 * To prevent the case that we handle a stale Rx descriptor, just
+		 * assert for now until we have a way to recover.
+		 */
+
+		if (adf_os_unlikely(!((*(u_int32_t *) &rx_desc->attention)
+						& RX_ATTENTION_0_MSDU_DONE_MASK))) {
+
+			int dbg_iter = MAX_DONE_BIT_CHECK_ITER;
+
+
+			adf_os_print("malformed frame\n");
+
+			while (dbg_iter &&
+					(!((*(u_int32_t *) &rx_desc->attention) &
+					   RX_ATTENTION_0_MSDU_DONE_MASK))) {
+				adf_os_mdelay(1);
+
+				adf_os_invalidate_range((void *)rx_desc,
+						(void*)((char *)rx_desc +
+							HTT_RX_STD_DESC_RESERVATION));
+
+				adf_os_print("debug iter %d success %d\n", dbg_iter,
+						pdev->rx_ring.dbg_sync_success);
+
+				dbg_iter--;
+			}
+
+			if (adf_os_unlikely(!((*(u_int32_t *) &rx_desc->attention)
+							& RX_ATTENTION_0_MSDU_DONE_MASK)))
+			{
+				/* okkwon todo : is this allowed -_-? */
+				printk(KERN_ERR"okkwon : recovery failed - memory leak -_-?\n");
+//				to_free = *head_msdu;
+				*head_msdu = NULL;
+				break;
+			}
+			pdev->rx_ring.dbg_sync_success++;
+			adf_os_print("debug iter %d success %d\n", dbg_iter,
+					pdev->rx_ring.dbg_sync_success);
+		}
+
+		/*
+		 * Copy the FW rx descriptor for this MSDU from the rx indication
+		 * message into the MSDU's netbuf.
+		 * HL uses the same rx indication message definition as LL, and
+		 * simply appends new info (fields from the HW rx desc, and the
+		 * MSDU payload itself).
+		 * So, the offset into the rx indication message only has to account
+		 * for the standard offset of the per-MSDU FW rx desc info within
+		 * the message, and how many bytes of the per-MSDU FW rx desc info
+		 * have already been consumed.  (And the endianness of the host,
+		 * since for a big-endian host, the rx ind message contents,
+         * including the per-MSDU rx desc bytes, were byteswapped during
+         * upload.)
+         */
+        if (pdev->rx_ind_msdu_byte_idx < num_msdu_bytes) {
+            if (adf_os_unlikely(HTT_T2H_MSG_TYPE_RX_FRAG_IND == msg_type)) {
+                byte_offset = HTT_ENDIAN_BYTE_IDX_SWAP(
+                    HTT_RX_FRAG_IND_FW_DESC_BYTE_OFFSET);
+            } else {
+                byte_offset = HTT_ENDIAN_BYTE_IDX_SWAP(
+                    HTT_RX_IND_FW_RX_DESC_BYTE_OFFSET +
+                    pdev->rx_ind_msdu_byte_idx);
+            }
+
+            *((u_int8_t *) &rx_desc->fw_desc.u.val) = rx_ind_data[byte_offset];
+            /*
+             * The target is expected to only provide the basic per-MSDU rx
+             * descriptors.  Just to be sure, verify that the target has not
+             * attached extension data (e.g. LRO flow ID).
+             */
+            /*
+             * The assertion below currently doesn't work for RX_FRAG_IND
+             * messages, since their format differs from the RX_IND format
+             * (no FW rx PPDU desc in the current RX_FRAG_IND message).
+             * If the RX_FRAG_IND message format is updated to match the
+             * RX_IND message format, then the following assertion can be
+             * restored.
+             */
+            //adf_os_assert((rx_ind_data[byte_offset] & FW_RX_DESC_EXT_M) == 0);
+            pdev->rx_ind_msdu_byte_idx += 1; // or more, if there's ext data
+        } else {
+            /*
+             * When an oversized AMSDU happened, FW will lost some of
+             * MSDU status - in this case, the FW descriptors provided
+             * will be less than the actual MSDUs inside this MPDU.
+             * Mark the FW descriptors so that it will still deliver to
+             * upper stack, if no CRC error for this MPDU.
+             *
+             * FIX THIS - the FW descriptors are actually for MSDUs in
+             * the end of this A-MSDU instead of the beginning.
+             */
+            *((u_int8_t *) &rx_desc->fw_desc.u.val) = 0;
+        }
+
+        /*
+         *  TCP/UDP checksum offload support
+         */
+        htt_set_checksum_result_ll(pdev, msdu, rx_desc);
+
+        msdu_len_invalid = (*(u_int32_t *) &rx_desc->attention) &
+            RX_ATTENTION_0_MPDU_LENGTH_ERR_MASK;
+        msdu_chained = (((*(u_int32_t *) &rx_desc->frag_info) &
+                         RX_FRAG_INFO_0_RING2_MORE_COUNT_MASK) >>
+                        RX_FRAG_INFO_0_RING2_MORE_COUNT_LSB);
+        msdu_len =
+            ((*((u_int32_t *) &rx_desc->msdu_start)) &
+             RX_MSDU_START_0_MSDU_LENGTH_MASK) >>
+            RX_MSDU_START_0_MSDU_LENGTH_LSB;
+
+        do {
+            if (!msdu_len_invalid && !msdu_chained) {
+#if defined(PEREGRINE_1_0_ZERO_LEN_PHY_ERR_WAR)
+                if (msdu_len > 0x3000) {
+#if 0
+					/* okkwon todo : is this safe to ignore? */
+					printk(KERN_ERR"okkwon : msdu_len %d\n", msdu_len);
+#endif
+					to_free = *head_msdu;
+					*head_msdu = NULL;
+                    break;
+                }
+#endif
+				adf_nbuf_trim_tail(
+						msdu, HTT_RX_BUF_SIZE - (RX_STD_DESC_SIZE + msdu_len));
+			}
+		} while (0);
+
+		if (!msdu_chained && rx_desc->ppdu_end.phy_err) {
+			/* we are safe to free PHY_ERR */
+			to_free = *head_msdu;
+			*head_msdu = NULL;
+			break;
+		}
+
+		if (!msdu_chained && msdu_len <= 4) {
+			/*
+			printk(KERN_ERR"okkwon : msdu len less than 4 %d\n", msdu_len);
+			*/
+			to_free = *head_msdu;
+			*head_msdu = NULL;
+			break;
+		}
+		
+#if 0
+		if (msdu_chained) {
+			printk(KERN_ERR"okkwon msdu_chained %d\n", msdu_chained);
+			htt_print_rx_desc(rx_desc);
+		}
+#endif
+
+		while (msdu_chained--) {
+			/* okkwon : we just discard this safely */
+			adf_nbuf_t next =
+				htt_rx_netbuf_pop(pdev);
+        	adf_nbuf_unmap(pdev->osdev, next, ADF_OS_DMA_FROM_DEVICE);
+			adf_nbuf_set_pktlen(next, HTT_RX_BUF_SIZE);
+			msdu_len -= HTT_RX_BUF_SIZE;
+			adf_nbuf_set_next(msdu, next);
+			msdu = next;
+			msdu_chaining = 1;
+
+			/* okkwon : why do we trim tail if we discard this -_-? */
+#if 0
+			if (msdu_chained == 0) {
+				/* Trim the last one to the correct size - accounting for
+				 * inconsistent HW lengths cuasing length overflows and
+				 * underflows
+				 */
+				if (msdu_len < 0) {
+					printk(KERN_ERR"okkwon : weird msdu len handling for chained msdu\n");
+				}
+
+				if (((unsigned)msdu_len) >
+						((unsigned)(HTT_RX_BUF_SIZE - RX_STD_DESC_SIZE))) {
+					msdu_len = (HTT_RX_BUF_SIZE - RX_STD_DESC_SIZE);
+				}
+
+				adf_nbuf_trim_tail(
+						next, HTT_RX_BUF_SIZE - (RX_STD_DESC_SIZE + msdu_len));
+			}
+#endif
+		}
+
+		last_msdu =
+			((*(((u_int32_t *) &rx_desc->msdu_end) + 4)) &
+			 RX_MSDU_END_4_LAST_MSDU_MASK) >>
+			RX_MSDU_END_4_LAST_MSDU_LSB;
+
+		if (last_msdu) {
+			adf_nbuf_set_next(msdu, NULL);
+			break;
+		} else {
+			adf_nbuf_t next = htt_rx_netbuf_pop(pdev);
+			printk(KERN_ERR"okkwon next msdu is there\n");
+			adf_nbuf_set_next(msdu, next);
+			msdu = next;
+		}
+	}
+	*tail_msdu = msdu;
+
+	if (!msdu_chaining) {
+		if (*head_msdu) {
+			rxd = htt_rx_desc(*head_msdu);
+			fmt = rxd->msdu_start.decap_format;
+			if (fmt) {
+#if 0
+				printk(KERN_ERR"okkwon fmt %d - discard\n", fmt);
+				htt_print_rx_desc(rxd);
+				print_hex_dump(KERN_ERR, "cont:",  2, 16, 4,
+						&rxd->rx_hdr_status[0], 0x20, 0);
+#endif
+				to_free = *head_msdu;
+				*head_msdu = NULL;
+			}
+		}
+		if (*head_msdu && adf_nbuf_next(*head_msdu)) {
+			/* we need to restitch the AMDU */
+			/* copied from htt_rx_restitch_mpdu_from_msdu */
+			*head_msdu = htt_sniffer_restitch_amsdu(*head_msdu);
+			if (*head_msdu == NULL) {
+				printk(KERN_ERR"okkwon : theres error while restitch amsdu\n");
+			} else {
+				adf_nbuf_set_next(*head_msdu, NULL);
+				*tail_msdu = *head_msdu;
+			}
+		}
+		if (*head_msdu) {
+			rxd = (struct htt_host_rx_desc_base *) (adf_nbuf_data(*head_msdu)
+					- HTT_RX_STD_DESC_RESERVATION);
+
+			if (adf_nbuf_next(*head_msdu)) {
+				printk(KERN_ERR"okkwon theres next msdu ??\n");
+				htt_print_rx_desc(rxd);
+				print_hex_dump(KERN_ERR, "", 2, 16, 4,
+						adf_nbuf_data(*head_msdu), 50, 0);
+			}
+
+			if (rxd->attention.first_mpdu) {
+				memcpy((void*)&rxd_backup, (void*)rxd,  sizeof(rxd_backup));
+			} else {
+				/* if this is not a first mpdu.
+				 * We rely on the rx_indinformation -_-
+				 * what am I doing..
+				 */
+				uint32_t * wptr;
+				wptr = (uint32_t *) adf_nbuf_data(rx_ind_msg);
+
+				if (*(wptr+2) & (1<<31)) {
+					/* start values are valid */
+					rxd_backup.ppdu_start.rssi_comb = (*(wptr+2)) & 0xff;
+					rxd_backup.ppdu_start.l_sig_rate = ((*(wptr+2)) >>25)&0xf;
+					rxd_backup.ppdu_start.l_sig_rate_select = ((*(wptr+2)) >>29)&0x1;
+					rxd_backup.ppdu_start.preamble_type = ((*(wptr+9)) >> 24)&0xff;
+					rxd_backup.ppdu_start.ht_sig_vht_sig_a_1 = (*(wptr+9))&0xffff;
+					rxd_backup.ppdu_start.ht_sig_vht_sig_a_2 = (*(wptr+10))&0xffff;
+				}
+
+#if 0
+				/* we use the first MPDU header for the radiotap */
+				if (!rxd->attention.mgmt_type &&
+						!rxd->attention.ctrl_type &&
+						(rxd->attention.mgmt_type !=
+						 rxd_backup.attention.mgmt_type ||
+						 rxd->attention.ctrl_type !=
+						 rxd_backup.attention.ctrl_type)) {
+					uint32_t * wptr;
+					printk("okkwon : first MPDU missing?\n");
+
+					wptr = (uint32_t *) adf_nbuf_data(rx_ind_msg);
+					printk("okkwon : 2 %x 9 %x 10 %x\n", *(wptr + 2),
+							*(wptr + 9), *(wptr + 10));
+
+				}
+#endif
+				rxd = &rxd_backup;
+			}
+
+			if (htt_set_rx_radiotap_header(pdev, *head_msdu, rxd)) {
+				/* there is some problem in expanding head of skb */
+				/* skb was already freed, what can we do -_-? */
+				/* okkwon todo : memory leak? */
+				printk(KERN_ERR"okkwon : mem alloc failure for rt - discard all\n");
+				*head_msdu = NULL;
+			}
+		}
+	}
+
+	skb = to_free;
+	while (skb) {
+		adf_nbuf_t next;
+		next = adf_nbuf_next(skb);
+		adf_nbuf_free(skb);
+		skb = next;
+	}
+
+	/*
+	 * Don't refill the ring yet.
+	 * First, the elements popped here are still in use - it is
+	 * not safe to overwrite them until the matching call to
+	 * mpdu_desc_list_next.
+	 * Second, for efficiency it is preferable to refill the rx ring
+	 * with 1 PPDU's worth of rx buffers (something like 32 x 3 buffers),
+	 * rather than one MPDU's worth of rx buffers (something like 3 buffers).
+	 * Consequently, we'll rely on the txrx SW to tell us when it is done
+     * pulling all the PPDU's rx buffers out of the rx ring, and then
+     * refill it just once.
+     */
+    return msdu_chaining;
+}
+
+
 int
 htt_rx_amsdu_pop_ll(
     htt_pdev_handle pdev,
@@ -1164,14 +1971,6 @@
     return buf;
 }
 
-/* FIXME: This is a HW definition not provded by HW, where does it go ? */
-enum {
-    HW_RX_DECAP_FORMAT_RAW = 0,
-    HW_RX_DECAP_FORMAT_NWIFI,
-    HW_RX_DECAP_FORMAT_8023,
-    HW_RX_DECAP_FORMAT_ETH2,
-};
-
 #define HTT_FCS_LEN (4)
 
 static void
@@ -1540,6 +2339,11 @@
     return HTT_RSSI_INVALID;
 }
 
+int (*htt_rx_sniffer_amsdu_pop)(
+    htt_pdev_handle pdev,
+    adf_nbuf_t rx_ind_msg,
+    adf_nbuf_t *head_msdu,
+    adf_nbuf_t *tail_msdu);
 
 /*
  * htt_rx_amsdu_pop -
@@ -1875,6 +2679,7 @@
 #endif
         htt_rx_ring_fill_n(pdev, pdev->rx_ring.fill_level);
 
+        htt_rx_sniffer_amsdu_pop = htt_rx_sniffer_amsdu_pop_ll;
         htt_rx_amsdu_pop = htt_rx_amsdu_pop_ll;
         htt_rx_offload_msdu_pop = htt_rx_offload_msdu_pop_ll;
         htt_rx_mpdu_desc_list_next = htt_rx_mpdu_desc_list_next_ll;
diff -uNr qcacld-2.0/CORE/CLD_TXRX/HTT/htt_types.h qcacld-2.0-new/CORE/CLD_TXRX/HTT/htt_types.h
--- qcacld-2.0/CORE/CLD_TXRX/HTT/htt_types.h	2015-10-20 10:18:50.000000000 +0800
+++ qcacld-2.0-new/CORE/CLD_TXRX/HTT/htt_types.h	2015-10-28 19:18:26.000000000 +0800
@@ -202,6 +202,8 @@
     int cur_seq_num_hl;
     struct htt_tx_mgmt_desc_ctxt tx_mgmt_desc_ctxt;
     struct targetdef_s *targetdef;
+	unsigned char sniffer_channel;
+	int sniffer_center_freq;
 };
 
 #endif /* _HTT_TYPES__H_ */
diff -uNr qcacld-2.0/CORE/CLD_TXRX/TXRX/ol_rx.c qcacld-2.0-new/CORE/CLD_TXRX/TXRX/ol_rx.c
--- qcacld-2.0/CORE/CLD_TXRX/TXRX/ol_rx.c	2015-10-20 10:18:50.000000000 +0800
+++ qcacld-2.0-new/CORE/CLD_TXRX/TXRX/ol_rx.c	2015-10-28 19:19:32.000000000 +0800
@@ -81,6 +81,7 @@
 
     wh = (struct ieee80211_frame *)
         htt_rx_mpdu_wifi_hdr_retrieve(htt_pdev, rx_mpdu_desc);
+
     /*
      * Klocwork issue #6152
      *  All targets that send a "INVALID_PEER" rx status provide a
@@ -174,6 +175,8 @@
     struct ol_txrx_vdev_t *vdev = NULL;
     struct ol_txrx_peer_t *peer;
     htt_pdev_handle htt_pdev;
+	adf_nbuf_t first_msdu = NULL;
+	adf_nbuf_t last_msdu = NULL;
 
     htt_pdev = pdev->htt_pdev;
     peer = ol_txrx_peer_find_by_id(pdev, peer_id);
@@ -184,7 +187,7 @@
 
     TXRX_STATS_INCR(pdev, priv.rx.normal.ppdus);
 
-    OL_RX_REORDER_TIMEOUT_MUTEX_LOCK(pdev);
+	OL_RX_REORDER_TIMEOUT_MUTEX_LOCK(pdev);
 
     if (htt_rx_ind_flush(pdev->htt_pdev, rx_ind_msg) && peer) {
         htt_rx_ind_flush_seq_num_range(
@@ -219,6 +222,63 @@
         pdev->htt_pdev->rx_ring.sw_rd_idx.msdu_payld;
 #endif
 
+
+	if (pdev->sniffer_vdev) {
+		peer = TAILQ_FIRST(&pdev->sniffer_vdev->peer_list);
+
+		for (mpdu_range = 0; mpdu_range < num_mpdu_ranges; mpdu_range++) {
+			int i, num_mpdus;
+			adf_nbuf_t head_msdu, tail_msdu;
+			int msdu_chaining;
+			enum htt_rx_status status;
+
+#ifdef DEBUG_DMA_DONE
+			pdev->htt_pdev->rx_ring.dbg_mpdu_range = mpdu_range;
+#endif
+
+			htt_rx_ind_mpdu_range_info(
+					pdev->htt_pdev, rx_ind_msg, mpdu_range, &status, &num_mpdus);
+
+#if 0
+			if (num_mpdus > 1) 
+				printk(KERN_ERR"okkwon num_mpdus %d\n", num_mpdus);
+#endif
+
+			for (i = 0; i < num_mpdus; i++) {
+				msdu_chaining = htt_rx_sniffer_amsdu_pop(htt_pdev, rx_ind_msg,
+						&head_msdu, &tail_msdu);
+
+				if (!head_msdu) {
+					/* the skb was freed inside the pop function */
+					continue;
+				}
+
+				if (msdu_chaining) {
+					/* discard!! */
+					adf_nbuf_t skb = head_msdu;
+					while (skb) {
+						adf_nbuf_t next = adf_nbuf_next(skb);
+						adf_nbuf_free(skb);
+						skb = next;
+					}
+				} else {
+					if (!first_msdu) {
+						first_msdu = head_msdu;
+						last_msdu = tail_msdu;
+					} else {
+						/* chain to the last */
+						adf_nbuf_set_next(last_msdu, head_msdu);
+						last_msdu = tail_msdu;
+					}
+				}
+			}
+#if 0
+			printk(KERN_ERR"okkwon first_msdu %x, last_msdu %x\n",
+					(unsigned int)first_msdu, (unsigned int)last_msdu);
+#endif
+
+		}
+	} else {
     for (mpdu_range = 0; mpdu_range < num_mpdu_ranges; mpdu_range++) {
         enum htt_rx_status status;
         int i, num_mpdus;
@@ -230,8 +290,9 @@
 #endif
 
         htt_rx_ind_mpdu_range_info(
-            pdev->htt_pdev, rx_ind_msg, mpdu_range, &status, &num_mpdus);
-        if ((status == htt_rx_status_ok) && peer) {
+				pdev->htt_pdev, rx_ind_msg, mpdu_range, &status, &num_mpdus);
+
+		if ((status == htt_rx_status_ok) && peer) {
             TXRX_STATS_ADD(pdev, priv.rx.normal.mpdus, num_mpdus);
             /* valid frame - deposit it into the rx reordering buffer */
             for (i = 0; i < num_mpdus; i++) {
@@ -403,6 +464,8 @@
                     /* once per mpdu */
                     ol_rx_process_inv_peer(pdev, rx_mpdu_desc, msdu);
                 }
+
+
 		while (1) {
 			 /* Free the nbuf */
 			adf_nbuf_t next;
@@ -416,6 +479,7 @@
             }
         }
     }
+	}
     /*
      * Now that a whole batch of MSDUs have been pulled out of HTT
      * and put into the rx reorder array, it is an appropriate time
@@ -427,7 +491,9 @@
      */
     htt_rx_msdu_buff_replenish(htt_pdev);
 
-    if ((A_TRUE == rx_ind_release) && peer && vdev) {
+	if (pdev->sniffer_vdev) {
+		peer->rx_opt_proc(pdev->sniffer_vdev, peer, 0, first_msdu);
+	} else if ((A_TRUE == rx_ind_release) && peer && vdev) {
         ol_rx_reorder_release(vdev, peer, tid, seq_num_start, seq_num_end);
     }
     OL_RX_REORDER_TIMEOUT_UPDATE(peer, tid);
@@ -844,6 +910,7 @@
 #endif
         htt_rx_msdu_actions(
             pdev->htt_pdev, rx_desc, &discard, &dummy_fwd, &inspect);
+
         if (inspect) {
             ol_rx_inspect(vdev, peer, tid, msdu, rx_desc);
         }
@@ -852,7 +919,8 @@
          * Check the first msdu in the mpdu, if it will be filtered out,
          * then discard the entire mpdu.
          */
-        if (htt_rx_msdu_first_msdu_flag(htt_pdev, rx_desc)) {
+        if (vdev->opmode != wlan_op_mode_monitor &&
+			   htt_rx_msdu_first_msdu_flag(htt_pdev, rx_desc)) {
             filter = ol_rx_filter(vdev, peer, msdu, rx_desc);
         }
 
diff -uNr qcacld-2.0/CORE/CLD_TXRX/TXRX/ol_txrx.c qcacld-2.0-new/CORE/CLD_TXRX/TXRX/ol_txrx.c
--- qcacld-2.0/CORE/CLD_TXRX/TXRX/ol_txrx.c	2015-10-20 10:18:50.000000000 +0800
+++ qcacld-2.0-new/CORE/CLD_TXRX/TXRX/ol_txrx.c	2015-10-28 19:20:11.000000000 +0800
@@ -770,6 +770,12 @@
     adf_os_mem_free(pdev);
 }
 
+void ol_txrx_pdev_set_sniffer_channel(ol_txrx_pdev_handle pdev,
+		unsigned char channel, int freq)
+{
+	htt_pdev_set_sniffer_channel(pdev->htt_pdev, channel, freq);
+}
+
 ol_txrx_vdev_handle
 ol_txrx_vdev_attach(
     ol_txrx_pdev_handle pdev,
@@ -846,14 +852,20 @@
     /* Default MAX Q depth for every VDEV */
     vdev->ll_pause.max_q_depth =
         ol_tx_cfg_max_tx_queue_depth_ll(vdev->pdev->ctrl_pdev);
+	if(vdev->opmode == wlan_op_mode_monitor) {
+		pdev->sniffer_vdev = vdev;
+		pdev->rx_opt_proc = ol_rx_deliver;
+		pdev->frame_format = wlan_frm_fmt_raw;
+	}
     /* add this vdev into the pdev's list */
     TAILQ_INSERT_TAIL(&pdev->vdev_list, vdev, vdev_list_elem);
 
     TXRX_PRINT(TXRX_PRINT_LEVEL_INFO1,
-        "Created vdev %p (%02x:%02x:%02x:%02x:%02x:%02x)\n",
+        "Created vdev %p (%02x:%02x:%02x:%02x:%02x:%02x) type %d\n",
         vdev,
         vdev->mac_addr.raw[0], vdev->mac_addr.raw[1], vdev->mac_addr.raw[2],
-        vdev->mac_addr.raw[3], vdev->mac_addr.raw[4], vdev->mac_addr.raw[5]);
+        vdev->mac_addr.raw[3], vdev->mac_addr.raw[4], vdev->mac_addr.raw[5],
+		vdev->opmode);
 
     /*
      * We've verified that htt_op_mode == wlan_op_mode,
diff -uNr qcacld-2.0/CORE/CLD_TXRX/TXRX/ol_txrx_types.h qcacld-2.0-new/CORE/CLD_TXRX/TXRX/ol_txrx_types.h
--- qcacld-2.0/CORE/CLD_TXRX/TXRX/ol_txrx_types.h	2015-10-20 10:18:50.000000000 +0800
+++ qcacld-2.0-new/CORE/CLD_TXRX/TXRX/ol_txrx_types.h	2015-10-28 19:20:22.000000000 +0800
@@ -676,6 +676,9 @@
 		/* stores time in ms of on and off phase for each throttle level*/
 		int throttle_time_ms[THROTTLE_LEVEL_MAX][THROTTLE_PHASE_MAX];
 	} tx_throttle_ll;
+
+	/* to indicated monitor mode */
+	struct ol_txrx_vdev_t * sniffer_vdev;
 };
 
 struct ol_txrx_vdev_t {
diff -uNr qcacld-2.0/CORE/HDD/inc/smart_cfg.h qcacld-2.0-new/CORE/HDD/inc/smart_cfg.h
--- qcacld-2.0/CORE/HDD/inc/smart_cfg.h	1970-01-01 08:00:00.000000000 +0800
+++ qcacld-2.0-new/CORE/HDD/inc/smart_cfg.h	2015-10-28 19:06:14.000000000 +0800
@@ -0,0 +1,70 @@
+/*
+ * Copyright (c) 2012-2014 The Linux Foundation. All rights reserved.
+ *
+ * Previously licensed under the ISC license by Qualcomm Atheros, Inc.
+ *
+ *
+ * Permission to use, copy, modify, and/or distribute this software for
+ * any purpose with or without fee is hereby granted, provided that the
+ * above copyright notice and this permission notice appear in all
+ * copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
+ * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
+ * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
+ * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
+ * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+/*
+ * This file was originally distributed by Qualcomm Atheros, Inc.
+ * under proprietary terms before Copyright ownership was assigned
+ * to the Linux Foundation.
+ */
+
+#ifndef __SMART_CFG_H
+#define __SMART_CFG_H
+
+#include <linux/workqueue.h>
+#include <linux/jiffies.h>
+#include <linux/timer.h>
+#include <linux/wait.h>
+#include <net/cfg80211.h>
+#include <vos_status.h>
+#include "vos_types.h"
+#include "vos_sched.h"
+#include "wlan_hdd_main.h"
+#include "wlan_hdd_assoc.h"
+#include <linux/sched.h>
+
+
+#define SMARTCFG_DEBUG	1
+#if (1 == SMARTCFG_DEBUG)
+	#define smartcfglog(level, args...) VOS_TRACE( VOS_MODULE_ID_HDD, level, ## args)
+#else
+	#define smartcfglog(level, args...)
+#endif
+
+#define SMARTCFG_FILE	"/data/smartcfg.conf"
+#define SMART_TIME_OUT	1000//ms
+
+typedef enum smrtcfg_state {
+    SMARTCGF_STATE_ERROR = -1,
+    SMARTCGF_STATE_INVALID_DATA,
+    SMARTCGF_STATE_START,
+    SMARTCGF_STATE_INPROGRESS,
+    SMARTCGF_STATE_FIND_BASE,
+    SMARTCGF_STATE_FIND_MAGIC,
+    SMARTCGF_STATE_FIND_PREFIX,
+    SMARTCGF_STATE_FIND_SEQ_HEADER,
+    SMARTCGF_STATE_DONE,
+} smartcfg_state_t;
+
+void smartcfg_promiscuous_handler(struct sk_buff *skb);
+VOS_STATUS smartcfg_task_init(pVosSchedContext pSchedContext,hdd_adapter_t *pAdapter,struct channel_list *channel_list_t);
+VOS_STATUS smartcfg_task_stop(void);
+#endif
+
diff -uNr qcacld-2.0/CORE/HDD/inc/wlan_hdd_main.h qcacld-2.0-new/CORE/HDD/inc/wlan_hdd_main.h
--- qcacld-2.0/CORE/HDD/inc/wlan_hdd_main.h	2015-10-20 10:18:50.000000000 +0800
+++ qcacld-2.0-new/CORE/HDD/inc/wlan_hdd_main.h	2015-10-28 19:22:06.000000000 +0800
@@ -225,7 +225,8 @@
 
 #define HDD_MIN_TX_POWER (-100) // minimum tx power
 #define HDD_MAX_TX_POWER (+100)  // maximum tx power
-
+#define HDD_AK_MAX_BSS_NUM 100	// for Tencent Airkiss
+#define HDD_AK_TIMEOUT 40000
 typedef v_U8_t tWlanHddMacAddr[HDD_MAC_ADDR_LEN];
 
 /*
@@ -545,7 +546,8 @@
    WLAN_HDD_MONITOR,
    WLAN_HDD_FTM,
    WLAN_HDD_IBSS,
-   WLAN_HDD_P2P_DEVICE
+   WLAN_HDD_P2P_DEVICE,
+   WLAN_HDD_SNIFFER
 }device_mode_t;
 
 typedef enum rem_on_channel_request_type
@@ -1082,6 +1084,13 @@
     unsigned int tx_flow_high_watermark_offset;
 #endif /* QCA_LL_TX_FLOW_CT */
     v_BOOL_t offloads_configured;
+
+    //airkiss
+    v_BOOL_t ak_not_1st;
+	v_BOOL_t ak_done;
+	v_BOOL_t ak_found_base;
+    unsigned char ak_chan_list[HDD_AK_MAX_BSS_NUM];
+    vos_timer_t ak_timer;
 };
 
 #define WLAN_HDD_GET_STATION_CTX_PTR(pAdapter) (&(pAdapter)->sessionCtx.station)
@@ -1428,6 +1437,7 @@
 void hdd_set_station_ops( struct net_device *pWlanDev );
 tANI_U8* wlan_hdd_get_intf_addr(hdd_context_t* pHddCtx);
 void wlan_hdd_release_intf_addr(hdd_context_t* pHddCtx, tANI_U8* releaseAddr);
+int hdd_sniffer_start(struct net_device *dev);
 v_U8_t hdd_get_operating_channel( hdd_context_t *pHddCtx, device_mode_t mode );
 
 void hdd_set_conparam ( v_UINT_t newParam );
diff -uNr qcacld-2.0/CORE/HDD/inc/wlan_hdd_tx_rx.h qcacld-2.0-new/CORE/HDD/inc/wlan_hdd_tx_rx.h
--- qcacld-2.0/CORE/HDD/inc/wlan_hdd_tx_rx.h	2015-10-20 10:18:50.000000000 +0800
+++ qcacld-2.0-new/CORE/HDD/inc/wlan_hdd_tx_rx.h	2015-10-28 19:22:34.000000000 +0800
@@ -216,6 +216,8 @@
                                      v_U8_t staId,
                                      WLANTL_RxMetaInfoType* pRxMetaInfo );
 #else
+extern VOS_STATUS hdd_rx_sniffer_cbk(v_VOID_t *vosContext, adf_nbuf_t rxBufChain,
+                                    v_U8_t staId);
 /**============================================================================
   @brief hdd_rx_packet_cbk() - Receive callback registered with TL.
   TL will call this to notify the HDD when a packet was received
diff -uNr qcacld-2.0/CORE/HDD/src/smart_cfg.c qcacld-2.0-new/CORE/HDD/src/smart_cfg.c
--- qcacld-2.0/CORE/HDD/src/smart_cfg.c	1970-01-01 08:00:00.000000000 +0800
+++ qcacld-2.0-new/CORE/HDD/src/smart_cfg.c	2015-08-28 10:35:27.000000000 +0800
@@ -0,0 +1,537 @@
+/*
+ * Copyright (c) 2012-2014 The Linux Foundation. All rights reserved.
+ *
+ * Previously licensed under the ISC license by Qualcomm Atheros, Inc.
+ *
+ *
+ * Permission to use, copy, modify, and/or distribute this software for
+ * any purpose with or without fee is hereby granted, provided that the
+ * above copyright notice and this permission notice appear in all
+ * copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
+ * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
+ * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
+ * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
+ * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+/*
+ * This file was originally distributed by Qualcomm Atheros, Inc.
+ * under proprietary terms before Copyright ownership was assigned
+ * to the Linux Foundation.
+ */
+#include "smart_cfg.h"
+#include <wlan_hdd_includes.h>
+#include <vos_trace.h>
+#include "vos_sched.h"
+#include "sme_Api.h"
+#include <linux/skbuff.h>
+#include "ieee80211_common.h"
+
+struct smartcfg g_smartcfg_t;
+static pVosSchedContext _gpVosSchedContext;
+
+
+const char CRC8Table[]={
+  0, 94, 188, 226, 97, 63, 221, 131, 194, 156, 126, 32, 163, 253, 31, 65,
+  157, 195, 33, 127, 252, 162, 64, 30, 95, 1, 227, 189, 62, 96, 130, 220,
+  35, 125, 159, 193, 66, 28, 254, 160, 225, 191, 93, 3, 128, 222, 60, 98,
+  190, 224, 2, 92, 223, 129, 99, 61, 124, 34, 192, 158, 29, 67, 161, 255,
+  70, 24, 250, 164, 39, 121, 155, 197, 132, 218, 56, 102, 229, 187, 89, 7,
+  219, 133, 103, 57, 186, 228, 6, 88, 25, 71, 165, 251, 120, 38, 196, 154,
+  101, 59, 217, 135, 4, 90, 184, 230, 167, 249, 27, 69, 198, 152, 122, 36,
+  248, 166, 68, 26, 153, 199, 37, 123, 58, 100, 134, 216, 91, 5, 231, 185,
+  140, 210, 48, 110, 237, 179, 81, 15, 78, 16, 242, 172, 47, 113, 147, 205,
+  17, 79, 173, 243, 112, 46, 204, 146, 211, 141, 111, 49, 178, 236, 14, 80,
+  175, 241, 19, 77, 206, 144, 114, 44, 109, 51, 209, 143, 12, 82, 176, 238,
+  50, 108, 142, 208, 83, 13, 239, 177, 240, 174, 76, 18, 145, 207, 45, 115,
+  202, 148, 118, 40, 171, 245, 23, 73, 8, 86, 180, 234, 105, 55, 213, 139,
+  87, 9, 235, 181, 54, 104, 138, 212, 149, 203, 41, 119, 244, 170, 72, 22,
+  233, 183, 85, 11, 136, 214, 52, 106, 43, 117, 151, 201, 74, 20, 246, 168,
+  116, 42, 200, 150, 21, 75, 169, 247, 182, 232, 10, 84, 215, 137, 107, 53
+};
+
+
+//caculate CRC, the index should be counted but it's not in the data array.
+unsigned char CRC8_Table(unsigned char *p, char counter, unsigned char index)
+{
+	unsigned char crc8 = 0;
+
+	crc8 = CRC8Table[crc8^index];
+	for( ; counter > 0; counter--){
+		crc8 = CRC8Table[crc8^*p];
+		p++;
+	}
+
+	return(crc8);
+}
+
+void smartcfg_para_init(struct smartcfg *smartcfg_t)
+{
+	if(!smartcfg_t){
+		smartcfglog(VOS_TRACE_LEVEL_FATAL,"%s:null.\n",__func__);
+		return;
+	}
+	smartcfg_t->ready = false;
+	smartcfg_t->done = false;
+	smartcfg_t->timeout = 0;
+
+	smartcfg_t->found_base_len = 0;
+	smartcfg_t->old_preamble = 0;
+	smartcfg_t->preamble_seq_found = 0;
+	smartcfg_t->preamble_disorder = 0;
+	smartcfg_t->preamble_found_cnt = 0;
+	smartcfg_t->base_length = 0;
+	
+	smartcfg_t->prefix_data = 0;
+	smartcfg_t->old_prefix = 0;
+	smartcfg_t->prefix_seq_found = 0;
+	smartcfg_t->pswd_length =0;
+	smartcfg_t->pswd_crc = 0;
+	smartcfg_t->found_prefix = 0;
+
+	smartcfg_t->old_magic = 0;
+	smartcfg_t->magic_seq_found = 0;
+	smartcfg_t->magic_disorder = 0;
+	smartcfg_t->magic_found_cnt = 0;
+	smartcfg_t->magic_data = 0;
+
+	smartcfg_t->total_length = 0;
+	smartcfg_t->ssid_crc = 0;
+	smartcfg_t->found_magic = 0;
+	smartcfg_t->max_seq_index = 0;
+	smartcfg_t->seq_bitmap_pattern = 0;	
+	
+	smartcfg_t->data_seq = 0;
+	smartcfg_t->data_index = 0;
+	smartcfg_t->seq_crc = 0;
+	smartcfg_t->seq_index = 0;	
+	smartcfg_t->data_seq_bitmap = 0;	
+
+	vos_mem_zero(smartcfg_t->data_section,
+			sizeof(smartcfg_t->data_section));
+	vos_mem_zero(smartcfg_t->ordered_data_section,
+			sizeof(smartcfg_t->ordered_data_section));
+	vos_mem_zero(smartcfg_t->seq_data,
+			sizeof(smartcfg_t->seq_data));
+	vos_mem_zero(smartcfg_t->ssid_str,
+			sizeof(smartcfg_t->ssid_str));
+}
+
+int smartcfg_write_result(char *ssid,int ssid_len, char *passwd,int passwd_len,
+		char random, int random_len)
+{
+	char ctrl_interface[] = "ctrl_interface=/data/misc/wifi/sockets\n";
+	char updata_config[] = "update_config=1\n";
+	char network0[] = "network={\n";
+	char _ssid[] = "ssid=";
+	char proto[] = "proto=RSN\n";
+	char key_mgmt[] = "key_mgmt=WPA-PSK\n";
+	char auth_alg[] = "auth_alg=OPEN\n";
+	char pairwise[] = "pairwise=CCMP\n";
+	char psk[] = "psk=";
+	char network1[] = "}\n";
+	char random_num[] = "#random number=";
+	char enter[] = "\n";
+	char *ppasswd;
+	char *buf;
+	int total_size;
+	struct file *file = NULL;
+	mm_segment_t old_fs;
+
+	ppasswd = vos_mem_malloc(passwd_len+1);
+	if (ppasswd == NULL) {
+	 	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+	        FL("passwd Memory allocation failure"));
+		return VOS_STATUS_E_FAULT;
+	}
+	strncpy(ppasswd,passwd,passwd_len);
+	*(ppasswd+passwd_len) = '\0';
+
+	total_size = sizeof(ctrl_interface) + sizeof(updata_config)	+ sizeof(network0) + sizeof(_ssid) + ssid_len 
+				+ sizeof(enter) + sizeof(proto) + sizeof(key_mgmt) + sizeof(auth_alg) + sizeof(pairwise) + sizeof(psk) 
+				+ passwd_len + sizeof(enter) + sizeof(network1) + sizeof(random_num) + sizeof(random) + sizeof(enter) + 6;
+	buf = vos_mem_malloc(total_size);
+	if (buf == NULL) {
+	 	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+	        FL("Memory allocation failure"));
+		return VOS_STATUS_E_FAULT;
+	}
+	vos_mem_zero(buf,total_size);
+
+	snprintf(buf,total_size,"%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s0x%x%s",ctrl_interface,updata_config,
+		network0,_ssid,ssid,enter,proto,key_mgmt,auth_alg,pairwise,psk,ppasswd,enter,
+		network1,random_num,random,enter);
+	smartcfglog(VOS_TRACE_LEVEL_FATAL,"result:%s\n",buf);
+
+	file =  filp_open(SMARTCFG_FILE,O_RDWR | O_CREAT,0664);
+	if (IS_ERR(file)) {
+		smartcfglog(VOS_TRACE_LEVEL_ERROR,"error occured while opening file %s, exiting...\n", SMARTCFG_FILE);
+		return VOS_STATUS_E_FAULT;
+	}
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+	file->f_op->write(file,(char *)buf,total_size,&file->f_pos);
+	set_fs(old_fs);
+	filp_close(file, NULL);  
+	file = NULL;
+
+	vos_mem_free(ppasswd);
+	vos_mem_free(buf);
+
+	return VOS_STATUS_SUCCESS;
+}
+
+void process_data_seq(struct smartcfg *smartcfg_t,int data)
+{
+	/* data sequence(bit map):
+	bit8	7	   6~0
+	---------------
+	| 0 | 1 |	  crc	 |	......
+	---------------	   |=> sequence header
+	| 0 | 1 |	index  |  .......
+	---------------
+	| 1 |	   data 	 |.........
+	---------------	   |
+	| 1 |	   data 	 |		  |
+	---------------	   |=> data
+	| 1 |	   data 	 |		  |
+	---------------	   |
+	| 1 |	   data 	 |.........
+	---------------
+
+	If b:"0101 1x1x 1x1x" is found, a data sequence is found. 
+	*/
+	int index = (data & 0x180) >> 7;
+	int j = 0;
+	unsigned char crc;
+
+	smartcfg_t->data_seq = (smartcfg_t->data_seq << 2) | index;
+	smartcfg_t->data_section[smartcfg_t->data_index] = data & 0xff;
+	smartcfg_t->data_index = (smartcfg_t->data_index + 1)%6;
+
+	if ((smartcfg_t->data_seq & 0x580) == 0x580){
+		smartcfg_t->seq_crc = smartcfg_t->data_section[j] & 0x7f;
+		j = (j+1) % 6;
+		smartcfg_t->seq_index = smartcfg_t->data_section[j] & 0x7f;
+		j = (j+1) % 6;
+		smartcfg_t->ordered_data_section[0] = smartcfg_t->data_section[j];
+		j = (j+1) % 6;
+		smartcfg_t->ordered_data_section[1] = smartcfg_t->data_section[j];
+		j = (j+1) % 6;
+		smartcfg_t->ordered_data_section[2] = smartcfg_t->data_section[j];
+		j = (j+1) % 6;
+		smartcfg_t->ordered_data_section[3] = smartcfg_t->data_section[j];
+		j = (j+1) % 6;
+
+		if (smartcfg_t->seq_index < smartcfg_t->max_seq_index){
+			crc = CRC8_Table(smartcfg_t->ordered_data_section,4,smartcfg_t->seq_index);
+			smartcfglog(VOS_TRACE_LEVEL_FATAL,"\ndata section: %x %x %x %x %x %x,crc=%x\n",smartcfg_t->seq_crc,
+				smartcfg_t->seq_index,
+				smartcfg_t->ordered_data_section[0],
+				smartcfg_t->ordered_data_section[1],
+				smartcfg_t->ordered_data_section[2],
+				smartcfg_t->ordered_data_section[3],
+				crc);
+		}
+		else if (smartcfg_t->seq_index == smartcfg_t->max_seq_index){
+			crc = CRC8_Table(smartcfg_t->ordered_data_section,
+				(smartcfg_t->total_length - smartcfg_t->seq_index * 4),
+					smartcfg_t->seq_index);
+		}
+		else
+			return;
+
+		if (smartcfg_t->seq_crc == (crc & 0x7f)){
+			smartcfg_t->data_seq_bitmap |= 1 << smartcfg_t->seq_index;
+			smartcfglog(VOS_TRACE_LEVEL_FATAL,"found data section : %x %x %x %x %x %x,seq bitmap=%x\n",
+				smartcfg_t->seq_crc,smartcfg_t->seq_index,
+				smartcfg_t->ordered_data_section[0],
+				smartcfg_t->ordered_data_section[1],
+				smartcfg_t->ordered_data_section[2],
+				smartcfg_t->ordered_data_section[3],
+				smartcfg_t->data_seq_bitmap);
+			vos_mem_copy(&smartcfg_t->seq_data[smartcfg_t->seq_index * 4],
+				smartcfg_t->ordered_data_section,4);
+		}
+	}
+}
+
+void process_magic(struct smartcfg *smartcfg_t,int data)
+{
+	int index = ((data & 0x1f0) >> 4);
+	int delta = index - smartcfg_t->old_magic;
+
+	smartcfg_t->old_magic = index;
+	if ( index < 4 ){
+		if (delta == 1){
+			smartcfg_t->magic_seq_found++;
+			smartcfg_t->magic_disorder++;
+		}
+		else if (delta == -3 && smartcfg_t->magic_seq_found == 3){
+			smartcfg_t->magic_found_cnt++;
+			smartcfg_t->magic_seq_found = 0;
+			smartcfg_t->magic_disorder++;
+			smartcfg_t->total_length = (smartcfg_t->magic_data & 0x7f00) >> 8;
+			smartcfg_t->ssid_crc = smartcfg_t->magic_data & 0xff;
+
+			//find at least 1 sequences and at least 10 continue vliad data
+			if ((smartcfg_t->magic_found_cnt >= 1) 
+				&& (smartcfg_t->magic_disorder > 10)){
+				smartcfg_t->found_magic = true;
+				smartcfg_t->max_seq_index = (smartcfg_t->total_length+3)/4 - 1;
+				smartcfg_t->seq_bitmap_pattern = (1 << (smartcfg_t->max_seq_index + 1)) - 1;
+				smartcfglog(VOS_TRACE_LEVEL_FATAL,"found magic: total_length=%x,ssid_crc=%x\n",smartcfg_t->total_length,
+						smartcfg_t->ssid_crc);
+			}
+		}
+		else if (delta < 4 && delta > -4){
+			smartcfg_t->magic_seq_found = 0;
+			smartcfg_t->magic_disorder++;
+		}
+		else {
+			smartcfg_t->magic_seq_found = 0;
+			smartcfg_t->magic_disorder = 0;
+			smartcfg_t->magic_found_cnt = 0;
+		}
+	}
+	else {
+		//no magic data found
+		smartcfg_t->magic_seq_found = 0;
+		smartcfg_t->magic_disorder = 0;
+		smartcfg_t->magic_found_cnt = 0;
+	}
+	smartcfg_t->magic_data = (smartcfg_t->magic_data << 4)|(data & 0xf);
+
+	return;
+}
+
+
+void process_prefix(struct smartcfg *smartcfg_t,int data)
+	{
+		int index = (data & 0x1f0) >> 4;
+		int delta = index - smartcfg_t->old_prefix;
+	
+		smartcfg_t->old_prefix = index;
+	
+		smartcfg_t->prefix_data = (smartcfg_t->prefix_data << 4) | (data & 0xf);
+		//only check index 4~7
+		if (index < 8 && index > 3){
+			if (delta == 1){
+				smartcfg_t->preamble_seq_found++;
+				if (smartcfg_t->preamble_seq_found ==4 ){
+					smartcfg_t->pswd_length = (smartcfg_t->prefix_data & 0xff00) >> 8;
+					smartcfg_t->pswd_crc = smartcfg_t->prefix_data & 0xff;
+					smartcfg_t->found_prefix = true;
+					smartcfglog(VOS_TRACE_LEVEL_FATAL,"found prefix: pswd_len=%x,pswd_crc=%x\n",smartcfg_t->pswd_length,
+							smartcfg_t->pswd_crc);
+				}			
+			}
+		}
+		else {
+			smartcfg_t->preamble_seq_found = 0;
+		}
+	
+		return;
+	}
+
+
+void seek_preamble(struct smartcfg *smartcfg_t,int data)
+{
+	int delta = data - smartcfg_t->old_preamble;
+
+	smartcfg_t->old_preamble = data;
+
+	if (delta == 1){		
+		smartcfg_t->preamble_seq_found++;
+		smartcfg_t->preamble_disorder++;
+		//smartcfglog(VOS_TRACE_LEVEL_FATAL,"preamble_seq_found=%d\n",smartcfg_t->preamble_seq_found);
+		//smartcfglog(VOS_TRACE_LEVEL_FATAL,"preamble_disorder=%d\n",smartcfg_t->preamble_disorder);
+	}
+	else if (delta == -3 && smartcfg_t->preamble_seq_found == 3){
+		smartcfg_t->preamble_found_cnt++;
+		smartcfg_t->preamble_seq_found = 0;
+		smartcfg_t->preamble_disorder++;
+		smartcfg_t->base_length = data - 1;
+		//smartcfglog(VOS_TRACE_LEVEL_FATAL,"preamble_found_cnt=%d\n",smartcfg_t->preamble_found_cnt);
+		//smartcfglog(VOS_TRACE_LEVEL_FATAL,"preamble_disorder=%d\n",smartcfg_t->preamble_disorder);
+		if (smartcfg_t->preamble_found_cnt > 5 
+			&& smartcfg_t->preamble_disorder > 40){
+			smartcfg_t->found_base_len = true;
+			smartcfglog(VOS_TRACE_LEVEL_FATAL,"found base lenght=%d\n",smartcfg_t->base_length);
+		}
+	}
+	else if ( delta < 4 && delta > -4 ){
+		smartcfg_t->preamble_seq_found = 0;
+		smartcfg_t->preamble_disorder++;
+	}
+	else {
+		smartcfg_t->preamble_seq_found = 0;
+		smartcfg_t->preamble_disorder = 0;
+		smartcfg_t->preamble_found_cnt = 0;
+	}
+
+	return;
+}
+
+smartcfg_state_t protocol_process(struct smartcfg *smartcfg_t,int data)
+{
+	int n = 0;
+	int passwd_len = 0;
+	int ssid_len = 0;
+	char random_num = 0;
+	smartcfg_state_t ret = SMARTCGF_STATE_INPROGRESS;
+
+	if(!smartcfg_t->found_base_len){
+		seek_preamble(smartcfg_t,data);
+		return SMARTCGF_STATE_FIND_BASE;
+	}
+	data -= smartcfg_t->base_length;
+	//ignor all great than 512 data,olny use 9 bits data
+	if (data > 512)
+		return SMARTCGF_STATE_INVALID_DATA;
+	if (!smartcfg_t->found_prefix){
+		process_prefix(smartcfg_t,data);
+		return SMARTCGF_STATE_FIND_PREFIX;
+	}
+	if (!smartcfg_t->found_magic)
+		process_magic(smartcfg_t,data);
+	else {
+		process_data_seq(smartcfg_t,data);
+		if (smartcfg_t->found_prefix){
+			if (smartcfg_t->data_seq_bitmap == smartcfg_t->seq_bitmap_pattern){
+				smartcfglog(VOS_TRACE_LEVEL_FATAL,"data_seq_bitmap=%x\n",smartcfg_t->data_seq_bitmap);
+				smartcfglog(VOS_TRACE_LEVEL_FATAL,"total length:%d,passwd length=%d\n",smartcfg_t->total_length,
+					smartcfg_t->pswd_length);
+
+				passwd_len = smartcfg_t->pswd_length;
+				ssid_len = smartcfg_t->total_length - smartcfg_t->pswd_length - 1;
+				if (ssid_len <= 0){
+					return SMARTCGF_STATE_ERROR;
+				}
+				VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,"passwd:");
+				for(n = 0; n < smartcfg_t->pswd_length; n++)
+					VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,"0x%02x ",smartcfg_t->seq_data[n]);
+
+				random_num = smartcfg_t->seq_data[smartcfg_t->pswd_length];
+				smartcfglog(VOS_TRACE_LEVEL_FATAL,"\nrandom number=0x%02x\n",random_num);
+
+				strncpy((char *)(smartcfg_t->ssid_str),(char *)(smartcfg_t->seq_data) + smartcfg_t->pswd_length+ 1,
+					smartcfg_t->total_length - smartcfg_t->pswd_length - 1);
+
+				VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,"ssid:%s\n",smartcfg_t->ssid_str);
+
+				passwd_len = smartcfg_t->pswd_length;
+				ssid_len = smartcfg_t->total_length - smartcfg_t->pswd_length - 1;
+				//smartcfg_t->seq_data not only passwd.
+				
+				smartcfg_write_result(smartcfg_t->ssid_str,ssid_len, 
+					smartcfg_t->seq_data,passwd_len,random_num,1);
+
+				ret = SMARTCGF_STATE_DONE;
+			}
+		}
+	}
+	return ret;
+}
+
+
+void smartcfg_promiscuous_handler(struct sk_buff *skb)
+{
+	int length;
+	u8 *pdata;
+	int i = 0;
+	smartcfg_state_t ret;
+
+	if (!g_smartcfg_t.ready){
+		//VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,"%s:Not initialized.\n",__func__);
+		return;
+	}
+	if(g_smartcfg_t.done){
+		return;
+	}
+	//frame header ocupy 16 bytes,analysis data section here.
+	length = skb->len;
+	pdata = &skb->data[16];
+	//judge data section
+	if ((pdata[0] & IEEE80211_FC0_TYPE_MASK) == IEEE80211_FC0_TYPE_DATA){
+		//check AP to sniffer
+		if ((pdata[1] & 0xf) == IEEE80211_FC1_DIR_FROMDS){
+			for (i = 4; i < 10; i++){
+				//check broadcast address ff:ff:ff:ff:ff:ff
+				if (pdata[i] != 0xff)
+					return;
+			}
+		}
+		smartcfglog(VOS_TRACE_LEVEL_FATAL,"length=%d.\n",length);
+		ret = protocol_process(&g_smartcfg_t,length);
+		if (!g_smartcfg_t.found_base_len){
+			if (time_after(jiffies,g_smartcfg_t.timeout)){
+				smartcfglog(VOS_TRACE_LEVEL_FATAL,"request switch channel.\n");
+				_gpVosSchedContext->SmartEventFlag = true;
+				wake_up_interruptible(&(_gpVosSchedContext->SmartWaitQueue));
+				g_smartcfg_t.timeout =  jiffies + msecs_to_jiffies(SMART_TIME_OUT);
+			}
+		}
+		if (SMARTCGF_STATE_DONE == ret){
+			smartcfglog(VOS_TRACE_LEVEL_FATAL,"smart done.\n");
+			smartcfg_task_stop();
+			g_smartcfg_t.done = true;
+		}
+		else if (SMARTCGF_STATE_ERROR == ret){
+			//occur error when parse data, restore initialization state, and re-run again;
+			smartcfglog(VOS_TRACE_LEVEL_FATAL,"smart error,re-run.\n");
+			smartcfg_task_stop();
+			g_smartcfg_t.ready = true;
+		}
+	}
+
+	return;
+}
+
+EXPORT_SYMBOL(smartcfg_promiscuous_handler);
+
+VOS_STATUS smartcfg_task_stop(void)
+{
+	smartcfglog(VOS_TRACE_LEVEL_FATAL,"smart stop.\n");
+	smartcfg_para_init(&g_smartcfg_t);
+
+	return VOS_STATUS_SUCCESS;
+}
+
+EXPORT_SYMBOL(smartcfg_task_stop);
+
+VOS_STATUS smartcfg_task_init(pVosSchedContext pSchedContext,hdd_adapter_t *pAdapter,struct channel_list *channel_list_t)
+{
+	u8 default_channel[14] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14};
+	int i = 0;
+
+	/*initialize smartcfg instruct.*/
+	pSchedContext->smartcfg_t = &g_smartcfg_t;
+	smartcfg_para_init(&g_smartcfg_t);
+	_gpVosSchedContext = pSchedContext;
+
+	//get channel list length which AP work on.
+	pAdapter->ak_chan_list[1] = 157;
+	while(pAdapter->ak_chan_list[i]){
+		smartcfglog(VOS_TRACE_LEVEL_FATAL,"channel list %d: %d.\n",i,pAdapter->ak_chan_list[i]);
+		i++;
+	}
+
+	channel_list_t->length = i;
+	smartcfglog(VOS_TRACE_LEVEL_FATAL,"channel list count: %d\n",channel_list_t->length);
+	channel_list_t->list= pAdapter->ak_chan_list;
+	//can't scan any AP,use default channel list:from channel 1 to channel 14.
+	if(channel_list_t->length == 0){
+		channel_list_t->list = default_channel;
+	}
+	g_smartcfg_t.ready = true;
+	return VOS_STATUS_SUCCESS;
+}
+EXPORT_SYMBOL(smartcfg_task_init);
+
+
diff -uNr qcacld-2.0/CORE/HDD/src/wlan_hdd_cfg80211.c qcacld-2.0-new/CORE/HDD/src/wlan_hdd_cfg80211.c
--- qcacld-2.0/CORE/HDD/src/wlan_hdd_cfg80211.c	2015-10-20 10:18:50.000000000 +0800
+++ qcacld-2.0-new/CORE/HDD/src/wlan_hdd_cfg80211.c	2015-10-28 19:24:39.000000000 +0800
@@ -414,6 +414,10 @@
             BIT(SIR_MAC_MGMT_DEAUTH) |
             BIT(SIR_MAC_MGMT_ACTION),
     },
+	[NL80211_IFTYPE_MONITOR] = {
+		.tx = 0x0,
+		.rx = 0xffff,
+	},
 };
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0))
@@ -1253,7 +1257,8 @@
                              | BIT(NL80211_IFTYPE_ADHOC)
                              | BIT(NL80211_IFTYPE_P2P_CLIENT)
                              | BIT(NL80211_IFTYPE_P2P_GO)
-                             | BIT(NL80211_IFTYPE_AP);
+                             | BIT(NL80211_IFTYPE_AP)
+							 | BIT(NL80211_IFTYPE_MONITOR);
 
     if( pCfg->advertiseConcurrentOperation )
     {
@@ -10847,6 +10852,71 @@
      return 0;
 }
 
+static int wlan_hdd_cfg80211_set_monitor_channel(struct wiphy *wiphy,
+		                       struct cfg80211_chan_def *chandef)
+{
+	v_U32_t num_ch = 0;
+	int channel = 0;
+	hdd_adapter_t *pAdapter = NULL;
+	int freq = chandef->chan->center_freq;
+	hdd_context_t *pHddCtx = (hdd_context_t*) wiphy_priv(wiphy);
+	tHalHandle hHal = NULL;
+	int status;
+
+	ENTER();
+
+	status = wlan_hdd_validate_context(pHddCtx);
+	if (0 != status)
+	{
+		VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+				"%s: HDD context is not valid", __func__);
+		return status;
+	}
+
+	pAdapter = hdd_get_adapter(pHddCtx, WLAN_HDD_SNIFFER);
+	if (NULL == pAdapter)
+	{
+		hddLog(VOS_TRACE_LEVEL_FATAL, "%s: Not in station context " ,__func__);
+		return -ENOENT;
+	}
+
+	hHal = WLAN_HDD_GET_HAL_CTX(pAdapter);
+
+	channel = ieee80211_frequency_to_channel(freq);
+
+	/* Check freq range */
+	if ((WNI_CFG_CURRENT_CHANNEL_STAMIN > channel) ||
+			(WNI_CFG_CURRENT_CHANNEL_STAMAX < channel))
+	{
+		hddLog(VOS_TRACE_LEVEL_ERROR,
+				"%s: Channel [%d] is outside valid range from %d to %d",
+				__func__, channel, WNI_CFG_CURRENT_CHANNEL_STAMIN,
+				WNI_CFG_CURRENT_CHANNEL_STAMAX);
+		return -EINVAL;
+	}
+
+	num_ch = WNI_CFG_VALID_CHANNEL_LIST_LEN;
+
+	if(WLAN_HDD_SNIFFER != pAdapter->device_mode) {
+		hddLog(VOS_TRACE_LEVEL_ERROR,
+				"%s: not in sniffer mode", __func__);
+		return -EINVAL;
+	}
+
+	/* okkwon todo : set the channel using WDA */
+	printk(KERN_ERR"okkwon %s : freq %u width %d center1 %u center2 %u\n",
+			__func__, chandef->chan->center_freq, chandef->width, chandef->center_freq1, 
+			chandef->center_freq2);
+
+	if (channel > 15) {
+	   	sme_RoamChannelChangeReq(hHal, 0, channel, eCSR_DOT11_MODE_11ac);
+	} else {
+	   	sme_RoamChannelChangeReq(hHal, 0, channel, eCSR_DOT11_MODE_11n);
+	}
+
+	return 0;
+}
+
 static int wlan_hdd_cfg80211_dump_survey(struct wiphy *wiphy,
                                          struct net_device *dev,
                                          int idx, struct survey_info *survey)
@@ -11222,4 +11292,5 @@
      .testmode_cmd = wlan_hdd_cfg80211_testmode,
 #endif
      .dump_survey = wlan_hdd_cfg80211_dump_survey,
+	 .set_monitor_channel = wlan_hdd_cfg80211_set_monitor_channel,
 };
diff -uNr qcacld-2.0/CORE/HDD/src/wlan_hdd_main.c qcacld-2.0-new/CORE/HDD/src/wlan_hdd_main.c
--- qcacld-2.0/CORE/HDD/src/wlan_hdd_main.c	2015-10-20 10:18:50.000000000 +0800
+++ qcacld-2.0-new/CORE/HDD/src/wlan_hdd_main.c	2015-10-28 19:43:45.000000000 +0800
@@ -68,6 +68,7 @@
 #include <wlan_hdd_tx_rx.h>
 #include <palTimer.h>
 #include <wniApi.h>
+#include <limApi.h>
 #include <wlan_nlink_srv.h>
 #include <wlan_btc_svc.h>
 #include <wlan_hdd_cfg.h>
@@ -298,7 +299,8 @@
 
    //Make sure that this callback corresponds to our device.
    if ((strncmp(dev->name, "wlan", 4)) &&
-      (strncmp(dev->name, "p2p", 3)))
+      (strncmp(dev->name, "p2p", 3)) &&
+	  (strncmp(dev->name, "mon", 3)))
       return NOTIFY_DONE;
 
    if (isWDresetInProgress())
@@ -6666,9 +6668,24 @@
                 "%s: pAdapter context is Null", __func__);
       return -ENODEV;
    }
+   pHddCtx = (hdd_context_t*)pAdapter->pHddCtx;
+   if(pAdapter->device_mode == WLAN_HDD_SNIFFER)
+   {
+   	tHalHandle hHal = WLAN_HDD_GET_HAL_CTX(pAdapter);
+   	tpAniSirGlobal pMac = (tpAniSirGlobal) hHal;
+	tpPESession psessionEntry;
+	tANI_U8 sessionId;
+	hdd_station_ctx_t* pHddStaCtx = WLAN_HDD_GET_STATION_CTX_PTR(pAdapter);
+	psessionEntry = peFindSessionByBssid(pMac, pAdapter->macAddressCurrent.bytes, &sessionId);
+	if(psessionEntry)
+	{
+		WLANTL_ClearSTAClient(pHddCtx->pvosContext, pHddStaCtx->conn_info.staId[0]);
+		printk("hangtian: delete pe session\n");
+		peDeleteSession(pMac, psessionEntry);
+	}
+   }
    MTRACE(vos_trace(VOS_MODULE_ID_HDD, TRACE_CODE_HDD_OPEN_REQUEST,
                     pAdapter->sessionId, pAdapter->device_mode));
-   pHddCtx = (hdd_context_t*)pAdapter->pHddCtx;
    if (NULL == pHddCtx)
    {
       VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
@@ -7107,6 +7124,152 @@
    return;
 }
 
+int hdd_sniffer_start(struct net_device *dev)
+{
+	hdd_adapter_t *pAdapter = WLAN_HDD_GET_PRIV_PTR(dev);
+	tHalHandle hHal = WLAN_HDD_GET_HAL_CTX(pAdapter);
+	hdd_context_t *pHddCtx = WLAN_HDD_GET_CTX(pAdapter);
+	WLAN_STADescType staDesc = {0};
+	hdd_station_ctx_t *pHddStaCtx = WLAN_HDD_GET_STATION_CTX_PTR(pAdapter);
+	VOS_STATUS vosStatus = VOS_STATUS_E_FAILURE;
+	int status;
+	
+	staDesc.ucSTAId = pHddStaCtx->conn_info.staId[0];
+        staDesc.wSTAType = WLAN_STA_SNIFFER;
+        vos_copy_macaddr( &staDesc.vSelfMACAddress, &pAdapter->macAddressCurrent );
+        staDesc.ucQosEnabled = 0;
+        staDesc.ucProtectedFrame = 0;
+#ifdef FEATURE_WLAN_ESE
+        staDesc.ucIsEseSta = 0;
+#endif
+        staDesc.ucIsReplayCheckValid = VOS_FALSE;
+        staDesc.ucSwFrameTXXlation = 1;
+        staDesc.ucSwFrameRXXlation = 1;
+        staDesc.ucAddRmvLLC = 1;
+
+        /* okkwon todo : what values -_-? */
+        staDesc.ucUcastSig = 0;
+        staDesc.ucBcastSig = 0;
+        staDesc.ucInitState = WLANTL_STA_AUTHENTICATED;
+
+        /* -_-;;; */
+        pHddCtx->sta_to_adapter[staDesc.ucSTAId] = pAdapter;	
+	vosStatus = WLANTL_RegisterSTAClient( pHddCtx->pvosContext,
+                        hdd_rx_sniffer_cbk,
+                        hdd_tx_complete_cbk,
+                        hdd_tx_fetch_packet_cbk, &staDesc,
+                        0 );
+	sme_StartSniffer(hHal, pAdapter->sessionId);
+
+
+	if(pAdapter == NULL) {
+		VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
+				"%s: HDD adapter context is Null", __func__);
+		return -EINVAL;
+	}
+
+	hdd_prevent_suspend();
+
+	/* vdev start */
+	/* okkwon todo : why pAdapter->sessionId does not work -_-? */
+	sme_RoamChannelChangeReq(hHal, 0, 149, eCSR_DOT11_MODE_11ac);
+
+	/* carrier on */
+	INIT_COMPLETION(pAdapter->linkup_event_var);
+	netif_carrier_on(dev);
+	status = wait_for_completion_interruptible_timeout(&pAdapter->linkup_event_var,
+			msecs_to_jiffies(ASSOC_LINKUP_TIMEOUT));
+	netif_tx_start_all_queues(dev);
+	if(!status)
+	{
+		hddLog(VOS_TRACE_LEVEL_WARN, "%s: Warning:ASSOC_LINKUP_TIMEOUT", __func__);
+	}
+
+	return 0;
+}
+
+int hdd_sniffer_stop(struct net_device *dev)
+{
+	/* carrier off */
+	netif_tx_disable(dev);
+	netif_carrier_off(dev);
+
+	/* okkwon todo : vdev down / stop*/
+
+	hdd_allow_suspend();
+
+	return 0;
+}
+
+VOS_STATUS null_rx_mgmt_cbk ( v_PVOID_t pvosGCtx, v_PVOID_t vosBuff)
+{
+	vos_pkt_t *pVosPkt;
+
+	pVosPkt = (vos_pkt_t *)vosBuff;
+
+	vos_pkt_return_packet(pVosPkt);
+	pVosPkt = NULL;
+
+	return VOS_STATUS_SUCCESS;
+}
+
+int hdd_sniffer_open (struct net_device *dev)
+{
+	hdd_adapter_t *pAdapter = WLAN_HDD_GET_PRIV_PTR(dev);
+    	hdd_context_t *pHddCtx = WLAN_HDD_GET_CTX(pAdapter);
+	//VOS_STATUS vosStatus = VOS_STATUS_E_FAILURE;
+	WLAN_STADescType staDesc = {0};
+	hdd_station_ctx_t *pHddStaCtx = WLAN_HDD_GET_STATION_CTX_PTR(pAdapter);
+
+	if (VOS_STATUS_SUCCESS != wlan_hdd_exit_lowpower(pHddCtx, pAdapter))
+	{
+		hddLog(VOS_TRACE_LEVEL_ERROR, "%s: Failed to bring "
+				"wlan out of power save", __func__);
+		return -EINVAL;
+	}
+	staDesc.ucSTAId = pHddStaCtx->conn_info.staId[0];
+#if 0
+	staDesc.wSTAType = WLAN_STA_SNIFFER;
+	vos_copy_macaddr( &staDesc.vSelfMACAddress, &pAdapter->macAddressCurrent );
+	staDesc.ucQosEnabled = 0;
+	staDesc.ucProtectedFrame = 0;
+#ifdef FEATURE_WLAN_ESE
+	staDesc.ucIsEseSta = 0;
+#endif
+	staDesc.ucIsReplayCheckValid = VOS_FALSE;
+	staDesc.ucSwFrameTXXlation = 1;
+	staDesc.ucSwFrameRXXlation = 1;
+	staDesc.ucAddRmvLLC = 1;
+	
+	/* okkwon todo : what values -_-? */
+	staDesc.ucUcastSig = 0;
+	staDesc.ucBcastSig = 0;
+	staDesc.ucInitState = WLANTL_STA_AUTHENTICATED;
+#endif
+	/* -_-;;; */
+	pHddCtx->sta_to_adapter[staDesc.ucSTAId] = pAdapter;
+
+	/*vosStatus = WLANTL_RegisterSTAClient( pHddCtx->pvosContext,
+			hdd_rx_sniffer_cbk,
+			hdd_tx_complete_cbk,
+			hdd_tx_fetch_packet_cbk, &staDesc,
+			0 );*/
+
+	/*vosStatus = WLANTL_DeRegisterMgmtFrmClient(pHddCtx->pvosContext);
+	vosStatus = WLANTL_RegisterMgmtFrmClient(pHddCtx->pvosContext,
+			null_rx_mgmt_cbk);*/
+
+	set_bit(DEVICE_IFACE_OPENED, &pAdapter->event_flags);
+
+	netif_start_queue(dev);
+
+	//sme_StartSniffer(pHddCtx->hHal, pAdapter->sessionId);
+
+	//hdd_sniffer_start(dev);
+
+	return 0;
+}
+
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,29))
   static struct net_device_ops wlan_drv_ops = {
       .ndo_open = hdd_open,
@@ -7136,7 +7299,17 @@
       .ndo_do_ioctl = hdd_ioctl,
       .ndo_set_mac_address = hdd_set_mac_address,
  };
-
+static struct net_device_ops wlan_sniffer_drv_ops = {
+	.ndo_open = hdd_sniffer_open,
+	.ndo_stop = hdd_stop,
+	.ndo_uninit = hdd_uninit,
+	.ndo_start_xmit = hdd_hard_start_xmit,
+	.ndo_tx_timeout = hdd_tx_timeout,
+	.ndo_get_stats = hdd_stats,
+	.ndo_do_ioctl = hdd_ioctl,
+	.ndo_set_mac_address = hdd_set_mac_address,
+	.ndo_select_queue    = hdd_select_queue,
+};
 #endif
 
 void hdd_set_station_ops( struct net_device *pWlanDev )
@@ -7155,6 +7328,22 @@
 #endif
 }
 
+void hdd_set_sniffer_ops( struct net_device *pWlanDev )
+{
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,29))
+      pWlanDev->netdev_ops = &wlan_sniffer_drv_ops;
+#else
+      pWlanDev->open = hdd_sniffer_open;
+      pWlanDev->stop = hdd_stop;
+      pWlanDev->uninit = hdd_uninit;
+      pWlanDev->hard_start_xmit = hdd_hard_start_xmit;
+      pWlanDev->tx_timeout = hdd_tx_timeout;
+      pWlanDev->get_stats = hdd_stats;
+      pWlanDev->do_ioctl = hdd_ioctl;
+      pWlanDev->set_mac_address = hdd_set_mac_address;
+#endif
+}
+
 static hdd_adapter_t* hdd_alloc_station_adapter( hdd_context_t *pHddCtx, tSirMacAddr macAddr, const char* name )
 {
    struct net_device *pWlanDev = NULL;
@@ -7743,6 +7932,10 @@
 
    switch(session_type)
    {
+	   case WLAN_HDD_SNIFFER:
+		   sme_DisablePowerSave (pHddCtx->hHal, ePMC_IDLE_MODE_POWER_SAVE);
+		   sme_DisablePowerSave(pHddCtx->hHal, ePMC_BEACON_MODE_POWER_SAVE);
+		   break;
        case WLAN_HDD_INFRA_STATION:
        case WLAN_HDD_SOFTAP:
        case WLAN_HDD_P2P_CLIENT:
@@ -7996,7 +8189,7 @@
                    session_type);
             return NULL;
          }
-
+printk("enter monitor mode\n");
          pAdapter->wdev.iftype = NL80211_IFTYPE_MONITOR;
          pAdapter->device_mode = session_type;
          status = hdd_register_interface( pAdapter, rtnl_held );
@@ -8052,6 +8245,31 @@
          netif_carrier_off(pAdapter->dev);
       }
          break;
+	  case WLAN_HDD_SNIFFER:
+		 {
+			 pAdapter = hdd_alloc_station_adapter(pHddCtx, macAddr, iface_name);
+
+			 if( NULL == pAdapter )
+				 return NULL;
+
+			 hdd_set_sniffer_ops(pAdapter->dev);
+
+			 pAdapter->wdev.iftype = NL80211_IFTYPE_MONITOR;
+			 pAdapter->device_mode = session_type;
+			 /* okkwon todo : add radiotap info */
+			 pAdapter->dev->type = ARPHRD_IEEE80211_RADIOTAP;
+
+			 status = hdd_init_station_mode(pAdapter);
+			 if( VOS_STATUS_SUCCESS != status )
+				 goto err_free_netdev;
+
+			 status = hdd_register_interface( pAdapter, rtnl_held );
+
+			 //stop the interface TX queue
+			 netif_tx_disable(pAdapter->dev);
+			 netif_carrier_off(pAdapter->dev);
+		 }
+		 break;
       default:
       {
          hddLog(VOS_TRACE_LEVEL_FATAL,"%s Invalid session type %d",
@@ -8154,7 +8372,8 @@
 #undef HDD_SMPS_PARAM_VALUE_S
    }
 
-  if (VOS_FTM_MODE != vos_get_conparam())
+  if (VOS_FTM_MODE != vos_get_conparam() &&
+		  VOS_SNIFFER_MODE != vos_get_conparam())
   {
        ret = process_wma_set_command((int)pAdapter->sessionId,
                          (int)WMI_PDEV_PARAM_HYST_EN,
@@ -8332,6 +8551,7 @@
       status = hdd_remove_front_adapter( pHddCtx, &pHddAdapterNode );
       if( pHddAdapterNode && VOS_STATUS_SUCCESS == status )
       {
+	     printk("close adapter\n");
          hdd_cleanup_adapter( pHddCtx, pHddAdapterNode->pAdapter, FALSE );
          vos_mem_free( pHddAdapterNode );
       }
@@ -8380,6 +8600,15 @@
 
    ENTER();
 
+   rtnl_lock();
+   dev_change_flags(pAdapter->dev, pAdapter->dev->flags & ~IFF_UP);
+   rtnl_unlock();
+   if(pAdapter->device_mode==WLAN_HDD_SNIFFER)
+   {
+	printk("hangtian: stop sniffer timer and destroy\n");
+	vos_timer_stop(&pAdapter->ak_timer);
+	vos_timer_destroy(&pAdapter->ak_timer);
+   }
    netif_tx_disable(pAdapter->dev);
    netif_carrier_off(pAdapter->dev);
    switch(pAdapter->device_mode)
@@ -10417,6 +10646,39 @@
     return eHAL_STATUS_SUCCESS;
 }
 
+
+void ak_timeout_handler(void* pAdapter)
+{
+	hdd_adapter_t* adapter = (hdd_adapter_t*)pAdapter;
+	if(adapter->ak_done){
+		printk("hangtian: airkiss done,stop timer.\n");
+		vos_timer_stop(&adapter->ak_timer);
+		return;
+	}
+
+	if (adapter->ak_found_base){
+		printk("hangtian: found base length,no need scan again.\n");
+		vos_timer_stop(&adapter->ak_timer);
+		return;
+	}
+	hdd_stop(adapter->dev);
+/*
+	rtnl_lock();
+	dev_change_flags(adapter->dev, adapter->dev->flags & ~(IFF_UP | IFF_RUNNING));
+	rtnl_unlock();*/
+
+	hdd_sniffer_open(adapter->dev);
+
+/*	rtnl_lock();
+	dev_change_flags(adapter->dev, IFF_UP | IFF_RUNNING);
+	rtnl_unlock();*/
+
+	printk("hangtian: airkiss timeout happened, restart scan\n");
+	adapter->ak_not_1st = false;
+	memset(adapter->ak_chan_list, 0, sizeof(adapter->ak_chan_list));
+	hdd_wlan_initial_scan(adapter);
+	vos_timer_start(&adapter->ak_timer, HDD_AK_TIMEOUT);
+}
 /**---------------------------------------------------------------------------
 
   \brief hdd_wlan_startup() - HDD init function
@@ -10436,6 +10698,7 @@
 #ifdef WLAN_OPEN_P2P_INTERFACE
    hdd_adapter_t *pP2pAdapter = NULL;
 #endif
+   hdd_adapter_t *pSnifferAdapter = NULL;
    hdd_context_t *pHddCtx = NULL;
    v_CONTEXT_t pVosContext= NULL;
 #ifdef WLAN_BTAMP_FEATURE
@@ -10662,7 +10925,7 @@
    hdd_wdi_trace_enable(eWLAN_MODULE_PAL,
                         pHddCtx->cfg_ini->wdiTraceEnablePAL);
 
-
+printk("conparam=%d\n", hdd_get_conparam());
    if (VOS_FTM_MODE == hdd_get_conparam())
        goto ftm_processing;
 
@@ -10964,8 +11227,38 @@
      pAdapter = hdd_open_adapter( pHddCtx, WLAN_HDD_SOFTAP, "softap.%d",
          wlan_hdd_get_intf_addr(pHddCtx), FALSE );
    }
-   else
+   else if (VOS_SNIFFER_MODE == hdd_get_conparam())
    {
+	   v_BYTE_t mon_addr[VOS_MAC_ADDR_SIZE] = {0x00, 0x90, 0x3c, 0x00, 0x00, 0x00};
+	   pAdapter = hdd_open_adapter( pHddCtx, WLAN_HDD_INFRA_STATION, "wlan%d",
+			   wlan_hdd_get_intf_addr(pHddCtx), FALSE );
+
+	   if (pAdapter != NULL) {
+		   pSnifferAdapter = hdd_open_adapter(pHddCtx, WLAN_HDD_SNIFFER, "mon%d",
+				   mon_addr, FALSE);
+		   if ( NULL == pSnifferAdapter )
+		   {
+			   hddLog(VOS_TRACE_LEVEL_FATAL,
+					   "%s: Failed to do hdd_open_adapter for Sniffer Interface",
+					   __func__);
+			   goto err_close_adapter;
+		   }
+			else
+			{
+				printk("hangtian: ifup mon0\n");
+				if(pSnifferAdapter->dev->netdev_ops->ndo_open(pSnifferAdapter->dev) == 0)
+				{
+					rtnl_lock();
+					dev_change_flags(pSnifferAdapter->dev, IFF_UP | IFF_RUNNING);
+					rtnl_unlock();
+					printk("hangtian: scan start\n");
+					hdd_wlan_initial_scan(pSnifferAdapter);
+					vos_timer_init(&pSnifferAdapter->ak_timer, VOS_TIMER_TYPE_SW, ak_timeout_handler, pSnifferAdapter);
+					//vos_timer_start(&pSnifferAdapter->ak_timer, HDD_AK_TIMEOUT);
+				}
+			}
+	   }
+   } else {
      pAdapter = hdd_open_adapter( pHddCtx, WLAN_HDD_INFRA_STATION, "wlan%d",
          wlan_hdd_get_intf_addr(pHddCtx), FALSE );
 
diff -uNr qcacld-2.0/CORE/HDD/src/wlan_hdd_tx_rx.c qcacld-2.0-new/CORE/HDD/src/wlan_hdd_tx_rx.c
--- qcacld-2.0/CORE/HDD/src/wlan_hdd_tx_rx.c	2015-10-20 10:18:50.000000000 +0800
+++ qcacld-2.0-new/CORE/HDD/src/wlan_hdd_tx_rx.c	2015-10-28 19:27:30.000000000 +0800
@@ -49,7 +49,8 @@
 #include <net/cfg80211.h>
 #include <net/ieee80211_radiotap.h>
 #include "sapApi.h"
-
+//airkiss feature
+#include "smart_cfg.h"
 #ifdef FEATURE_WLAN_TDLS
 #include "wlan_hdd_tdls.h"
 #endif
@@ -627,6 +628,11 @@
    hdd_station_ctx_t *pHddStaCtx = &pAdapter->sessionCtx.station;
    v_BOOL_t txSuspended = VOS_FALSE;
 
+   if (hdd_get_conparam() == VOS_SNIFFER_MODE) {
+	   kfree_skb(skb);
+	   return NETDEV_TX_OK;
+   }
+
    ++pAdapter->hdd_stats.hddTxRxStats.txXmitCalled;
 
    if (unlikely(netif_subqueue_stopped(dev, skb))) {
@@ -1834,7 +1840,7 @@
 
 
 #ifndef QCA_WIFI_2_0
-/**============================================================================
+**============================================================================
   @brief hdd_rx_packet_cbk() - Receive callback registered with TL.
   TL will call this to notify the HDD when one or more packets were
   received for a registered STA.
@@ -2119,7 +2125,85 @@
     return;
 }
 #else
+VOS_STATUS hdd_rx_sniffer_cbk(v_VOID_t *vosContext,
+		adf_nbuf_t rxBuf, v_U8_t staId)
+{
+	hdd_adapter_t *pAdapter = NULL;
+	hdd_context_t *pHddCtx = NULL;
+	int rxstat;
+	struct sk_buff *skb = NULL;
+	hdd_station_ctx_t *pHddStaCtx = NULL;
+
+	if ((NULL == vosContext) || (NULL == rxBuf))
+	{
+		VOS_TRACE( VOS_MODULE_ID_HDD_DATA, VOS_TRACE_LEVEL_ERROR,"%s: Null params being passed", __func__);
+		return VOS_STATUS_E_FAILURE;
+	}
+
+	pHddCtx = (hdd_context_t *)vos_get_context( VOS_MODULE_ID_HDD, vosContext );
+	if ( NULL == pHddCtx )
+	{
+		VOS_TRACE( VOS_MODULE_ID_HDD_DATA, VOS_TRACE_LEVEL_ERROR,"%s: HDD adapter context is Null", __func__);
+		return VOS_STATUS_E_FAILURE;
+	}
+
+	pAdapter = pHddCtx->sta_to_adapter[staId];
+	if( NULL == pAdapter )
+	{
+		return VOS_STATUS_E_FAILURE;
+	}
+	++pAdapter->hdd_stats.hddTxRxStats.rxChains;
+
+	skb = (struct sk_buff *) rxBuf;
+
+	//airkiss feature
+	smartcfg_promiscuous_handler(skb);
+	if (WLAN_HDD_ADAPTER_MAGIC != pAdapter->magic)
+	{
+		VOS_TRACE(VOS_MODULE_ID_HDD_DATA, VOS_TRACE_LEVEL_FATAL,
+				"Magic cookie(%x) for adapter sanity verification is invalid", pAdapter->magic);
+		return eHAL_STATUS_FAILURE;
+	}
+
+	pHddStaCtx = WLAN_HDD_GET_STATION_CTX_PTR(pAdapter);
+	if ((pHddStaCtx->conn_info.proxyARPService) &&
+			cfg80211_is_gratuitous_arp_unsolicited_na(skb))
+	{
+		++pAdapter->hdd_stats.hddTxRxStats.rxDropped;
+		VOS_TRACE(VOS_MODULE_ID_HDD_DATA, VOS_TRACE_LEVEL_INFO,
+				"%s: Dropping HS 2.0 Gratuitous ARP or Unsolicited NA", __func__);
+		kfree_skb(skb);
+		return VOS_STATUS_SUCCESS;
+	}
+
+	skb->dev = pAdapter->dev;
+	skb_reset_mac_header(skb);
+	skb->ip_summed = CHECKSUM_UNNECESSARY;
+	skb->pkt_type = PACKET_OTHERHOST;
+	skb->protocol = htons(ETH_P_802_2);
+	++pAdapter->hdd_stats.hddTxRxStats.rxPackets;
+	++pAdapter->stats.rx_packets;
+	pAdapter->stats.rx_bytes += skb->len;
+#ifdef WLAN_FEATURE_HOLD_RX_WAKELOCK
+	vos_wake_lock_timeout_acquire(&pHddCtx->rx_wake_lock,
+			HDD_WAKE_LOCK_DURATION);
+#endif
+	rxstat = netif_rx_ni(skb);
+	//rxstat = netif_receive_skb(skb);
+	if (NET_RX_SUCCESS == rxstat)
+	{
+		++pAdapter->hdd_stats.hddTxRxStats.rxDelivered;
+	}
+	else
+	{
+		++pAdapter->hdd_stats.hddTxRxStats.rxRefused;
+	}
+
+	pAdapter->dev->last_rx = jiffies;
 
+	return VOS_STATUS_SUCCESS;
+
+}
 /**============================================================================
   @brief hdd_rx_packet_cbk() - Receive callback registered with TL.
   TL will call this to notify the HDD when one or more packets were
diff -uNr qcacld-2.0/CORE/MAC/inc/sirApi.h qcacld-2.0-new/CORE/MAC/inc/sirApi.h
--- qcacld-2.0/CORE/MAC/inc/sirApi.h	2015-10-20 10:18:50.000000000 +0800
+++ qcacld-2.0-new/CORE/MAC/inc/sirApi.h	2015-10-28 19:28:28.000000000 +0800
@@ -1022,6 +1022,18 @@
     tSirSupChnl         supportedChannels;
 } tJoinReassocInfo, *tpJoinReassocInfo;
 
+typedef struct sSirSmeSnifferReq
+{
+	tANI_U16            messageType;            // eWNI_SME_REQ
+	tANI_U16            length;
+	tANI_U8             sessionId;
+	tANI_U16            transactionId;
+	tSirMacAddr         selfMacAddr;
+	tANI_U8             dot11mode;
+	tVOS_CON_MODE       staPersona;
+	ePhyChanBondState   cbMode;
+} tSirSmeSnifferReq, *tpSirSmeSnifferReq;
+
 /// Definition for join request
 /// ---> MAC
 /// WARNING! If you add a field in JOIN REQ.
@@ -1113,6 +1125,15 @@
 
 } tSirSmeJoinReq, *tpSirSmeJoinReq;
 
+typedef struct sSirSmeSnifferRsp
+{
+	tANI_U16                messageType;
+	tANI_U16                length;
+	tANI_U8                 sessionId;
+	tANI_U16                transactionId;
+	tSirResultCodes    statusCode;
+} tSirSmeSnifferRsp, *tpSirSmeSnifferRsp;
+
 /// Definition for reponse message to previously issued join request
 /// MAC --->
 typedef struct sSirSmeJoinRsp
diff -uNr qcacld-2.0/CORE/MAC/inc/wniApi.h qcacld-2.0-new/CORE/MAC/inc/wniApi.h
--- qcacld-2.0/CORE/MAC/inc/wniApi.h	2015-10-20 10:18:50.000000000 +0800
+++ qcacld-2.0-new/CORE/MAC/inc/wniApi.h	2015-10-28 19:28:38.000000000 +0800
@@ -395,6 +395,8 @@
     eWNI_SME_STATS_EXT_EVENT,
     eWNI_SME_LINK_SPEED_IND,//Indicate linkspeed response from WMA
     eWNI_SME_CSA_OFFLOAD_EVENT,
+    eWNI_SME_SNIFFER_REQ,
+    eWNI_SME_SNIFFER_RSP,
     eWNI_SME_MSG_TYPES_END
 };
 
diff -uNr qcacld-2.0/CORE/MAC/src/pe/lim/limProcessMessageQueue.c qcacld-2.0-new/CORE/MAC/src/pe/lim/limProcessMessageQueue.c
--- qcacld-2.0/CORE/MAC/src/pe/lim/limProcessMessageQueue.c	2015-10-20 10:18:50.000000000 +0800
+++ qcacld-2.0-new/CORE/MAC/src/pe/lim/limProcessMessageQueue.c	2015-10-28 19:39:52.000000000 +0800
@@ -2161,6 +2161,12 @@
         limMsg->bodyptr = NULL;
         break;
 
+	case eWNI_SME_SNIFFER_REQ:
+		limProcessSmeReqMessages(pMac, limMsg);
+		vos_mem_free((v_VOID_t*)limMsg->bodyptr);
+		limMsg->bodyptr = NULL;
+		break;
+
     case eWNI_SME_START_BEACON_REQ:
         limProcessSmeReqMessages(pMac, limMsg);
         vos_mem_free((v_VOID_t*)limMsg->bodyptr);
diff -uNr qcacld-2.0/CORE/MAC/src/pe/lim/limProcessMlmReqMessages.c qcacld-2.0-new/CORE/MAC/src/pe/lim/limProcessMlmReqMessages.c
--- qcacld-2.0/CORE/MAC/src/pe/lim/limProcessMlmReqMessages.c	2015-10-20 10:18:50.000000000 +0800
+++ qcacld-2.0-new/CORE/MAC/src/pe/lim/limProcessMlmReqMessages.c	2015-10-28 19:40:00.000000000 +0800
@@ -4980,7 +4980,19 @@
 #ifdef WLAN_FEATURE_11AC
     if ( peSession->vhtCapability )
     {
-        limSendSwitchChnlParams( pMac, channel, limGet11ACPhyCBState( pMac,channel,secChannelOffset,peSession->apCenterChan, peSession), maxTxPower, peSessionId);
+		if (peSession->operMode != BSS_OPERATIONAL_MODE_SNIFFER) {
+			/* non sniffer mode */
+			printk(KERN_ERR"okkwon : AP mode? apCenterChan %d\n", peSession->apCenterChan);
+		   	limSendSwitchChnlParams( pMac, channel, limGet11ACPhyCBState( pMac,channel,secChannelOffset,peSession->apCenterChan, peSession), maxTxPower, peSessionId);
+		} else {
+			printk(KERN_ERR"okkwon : non AP mode?\n");
+			/* okkwon todo : not a good way to distinguish channel width -_-;;*/
+			if (channel < 15) {
+			   	limSendSwitchChnlParams( pMac, channel, 0, maxTxPower, peSessionId);
+			} else {
+			   	limSendSwitchChnlParams( pMac, channel, secChannelOffset, maxTxPower, peSessionId);
+			}
+		}
     }
     else
 #endif
diff -uNr qcacld-2.0/CORE/MAC/src/pe/lim/limProcessSmeReqMessages.c qcacld-2.0-new/CORE/MAC/src/pe/lim/limProcessSmeReqMessages.c
--- qcacld-2.0/CORE/MAC/src/pe/lim/limProcessSmeReqMessages.c	2015-10-20 10:18:50.000000000 +0800
+++ qcacld-2.0-new/CORE/MAC/src/pe/lim/limProcessSmeReqMessages.c	2015-10-28 19:40:39.000000000 +0800
@@ -89,6 +89,7 @@
 static tANI_BOOLEAN __limProcessSmeStartBssReq(tpAniSirGlobal, tpSirMsgQ pMsg);
 static void __limProcessSmeScanReq(tpAniSirGlobal, tANI_U32 *);
 static void __limProcessSmeJoinReq(tpAniSirGlobal, tANI_U32 *);
+static void __limProcessSmeSnifferReq(tpAniSirGlobal, tANI_U32 *);
 static void __limProcessSmeReassocReq(tpAniSirGlobal, tANI_U32 *);
 static void __limProcessSmeDisassocReq(tpAniSirGlobal, tANI_U32 *);
 static void __limProcessSmeDisassocCnf(tpAniSirGlobal, tANI_U32 *);
@@ -211,6 +212,17 @@
         return true;
 } /*** end __limIsSmeAssocCnfValid() ***/
 
+static tANI_U16 __limGetSmeSnifferReqSizeForAlloc(tANI_U8 *pBuf)
+{
+	tANI_U16 len = 0;
+
+	if (!pBuf)
+		return len;
+
+	pBuf += sizeof(tANI_U16);
+	len = limGetU16( pBuf );
+	return (len + sizeof( tANI_U16 ));
+}
 
 /**
  * __limGetSmeJoinReqSizeForAlloc()
@@ -1215,7 +1227,7 @@
 #endif //FEATURE_WLAN_DIAG_SUPPORT
 
     pScanReq = (tpSirSmeScanReq) pMsgBuf;
-    limLog(pMac, LOG1, FL("SME SCAN REQ numChan %d min %d max %d IELen %d first %d fresh %d unique %d type %d mode %d rsp %d"),
+    limLog(pMac, LOGE, FL("SME SCAN REQ numChan %d min %d max %d IELen %d first %d fresh %d unique %d type %d mode %d rsp %d"),
            pScanReq->channelList.numChannels,
            pScanReq->minChannelTime,
            pScanReq->maxChannelTime,
@@ -1608,6 +1620,107 @@
                   sizeof(tSirDFSChannelList), 0);
 }
 
+static void __limProcessSmeSnifferReq(tpAniSirGlobal pMac, tANI_U32 *pMsgBuf)
+{
+	tpSirSmeSnifferReq pSmeSnifferReq = NULL;
+	tpPESession psessionEntry;
+	tANI_U8 sessionId;
+	tANI_U16 nSize;
+	tSirResultCodes     retCode = eSIR_SME_SUCCESS;
+	tANI_U16            smetransactionId;
+	tANI_U8             smesessionId;
+	
+	printk(KERN_ERR"okkwon : %s\n", __func__);
+
+	nSize = __limGetSmeSnifferReqSizeForAlloc((tANI_U8*) pMsgBuf);
+
+	pSmeSnifferReq = vos_mem_malloc(nSize);
+	if ( NULL == pSmeSnifferReq )
+	{
+		limLog(pMac, LOGP, FL("call to AllocateMemory failed for "
+					"pSmeJoinReq"));
+		retCode = eSIR_SME_RESOURCES_UNAVAILABLE;
+		goto end;
+	}
+	(void) vos_mem_set((void *) pSmeSnifferReq, nSize, 0);
+
+	if (limSnifferReqSerDes(pMac, pSmeSnifferReq, (tANI_U8 *)pMsgBuf) == eSIR_FAILURE)
+	{
+		limLog(pMac, LOGW, FL("received SME_SNIFFER_REQ with invalid data"));
+		retCode = eSIR_SME_INVALID_PARAMETERS;
+		goto end;
+	}
+
+	if((psessionEntry = peFindSessionByBssid(pMac, pSmeSnifferReq->selfMacAddr, &sessionId)) != NULL)
+	{
+		limLog(pMac, LOGE, FL("Session(%d) Already exists for selfmac: "
+					MAC_ADDRESS_STR),sessionId,
+				MAC_ADDR_ARRAY(pSmeSnifferReq->selfMacAddr));
+		retCode = eSIR_SME_REFUSED;
+		psessionEntry = NULL;
+		goto end;
+	} else {
+		/* Try to Create a new session */
+		if((psessionEntry = peCreateSession(pMac,pSmeSnifferReq->selfMacAddr,&sessionId, pMac->lim.maxStation)) == NULL)
+		{
+			limLog(pMac, LOGE, FL("Session Can not be created "));
+			retCode = eSIR_SME_RESOURCES_UNAVAILABLE;
+			goto end;
+		}
+	}
+
+	handleHTCapabilityandHTInfo(pMac, psessionEntry);
+	psessionEntry->isAmsduSupportInAMPDU = TRUE;
+	psessionEntry->peSessionId = sessionId;
+	psessionEntry->smeSessionId = pSmeSnifferReq->sessionId;
+	psessionEntry->transactionId = pSmeSnifferReq->transactionId;
+	psessionEntry->beaconParams.beaconInterval = 0;
+	sirCopyMacAddr(psessionEntry->selfMacAddr,pSmeSnifferReq->selfMacAddr);
+	psessionEntry->statypeForBss = STA_ENTRY_SELF;
+	psessionEntry->dot11mode  = pSmeSnifferReq->dot11mode;
+	psessionEntry->pePersona = pSmeSnifferReq->staPersona;
+	psessionEntry->vhtCapability = TRUE;
+	psessionEntry->txBFIniFeatureEnabled = TRUE;
+	psessionEntry->txMuBformee = FALSE;
+	psessionEntry->currentOperChannel = 1;
+	psessionEntry->htSupportedChannelWidthSet = (pSmeSnifferReq->cbMode)?1:0;
+	psessionEntry->htSecondaryChannelOffset = pSmeSnifferReq->cbMode;
+	psessionEntry->limRmfEnabled = 0;
+	psessionEntry->isFastTransitionEnabled = FALSE;
+	psessionEntry->isFastRoamIniFeatureEnabled = FALSE;
+	psessionEntry->txLdpcIniFeatureEnabled = TRUE;
+	psessionEntry->lim11hEnable = FALSE;
+	psessionEntry->operMode = BSS_OPERATIONAL_MODE_SNIFFER;	/* sniffer mode ?*/
+
+end:
+	limGetSessionInfo(pMac,(tANI_U8*)pMsgBuf,&smesessionId,&smetransactionId);
+
+	printk(KERN_ERR"okkwon smesessionId %u, transactionId %u\n", smesessionId, smetransactionId);
+	printk(KERN_ERR"okkwon sessionid %u\n", sessionId);
+
+	if(pSmeSnifferReq)
+	{
+		vos_mem_free(pSmeSnifferReq);
+		pSmeSnifferReq = NULL;
+		if (NULL != psessionEntry)
+		{
+			psessionEntry->pLimJoinReq = NULL;
+		}
+	}
+
+	if(retCode != eSIR_SME_SUCCESS)
+	{
+		if(NULL != psessionEntry)
+		{
+			peDeleteSession(pMac,psessionEntry);
+			psessionEntry = NULL;
+		}
+	}
+	limLog(pMac, LOG1, FL("Sending failure status limSendSmeJoinReassocRsp"
+				"on sessionid: %d with retCode = %d"),smesessionId, retCode);
+	limSendSmeSnifferRsp(pMac, eWNI_SME_SNIFFER_RSP, retCode, psessionEntry,smesessionId,smetransactionId);
+} /*** end __limProcessSmeJoinReq() ***/
+
 /**
  * __limProcessSmeJoinReq()
  *
@@ -5715,6 +5828,10 @@
             __limProcessSmeJoinReq(pMac, pMsgBuf);
             break;
 
+		case eWNI_SME_SNIFFER_REQ:
+			__limProcessSmeSnifferReq(pMac, pMsgBuf);
+			break;
+
         case eWNI_SME_AUTH_REQ:
            // __limProcessSmeAuthReq(pMac, pMsgBuf);
 
@@ -6038,7 +6155,8 @@
 
         /* Store the New Channel Params in psessionEntry */
         if (psessionEntry->currentOperChannel !=
-                              pChannelChangeReq->targetChannel)
+                              pChannelChangeReq->targetChannel ||
+							  psessionEntry->pePersona == VOS_SNIFFER_MODE)
         {
             limLog(pMac, LOGW,FL("switch old chnl %d --> new chnl %d "),
                                  psessionEntry->currentOperChannel,
diff -uNr qcacld-2.0/CORE/MAC/src/pe/lim/limSendMessages.c qcacld-2.0-new/CORE/MAC/src/pe/lim/limSendMessages.c
--- qcacld-2.0/CORE/MAC/src/pe/lim/limSendMessages.c	2015-10-20 10:18:50.000000000 +0800
+++ qcacld-2.0-new/CORE/MAC/src/pe/lim/limSendMessages.c	2015-10-28 19:40:56.000000000 +0800
@@ -248,6 +248,7 @@
     }
     vos_mem_set((tANI_U8 *) pChnlParams, sizeof(tSwitchChannelParams), 0);
     pChnlParams->secondaryChannelOffset = secondaryChnlOffset;
+	printk(KERN_ERR"okkwon %s : seconchan %d\n", __func__, secondaryChnlOffset);
     pChnlParams->channelNumber= chnlNumber;
     vos_mem_copy( pChnlParams->selfStaMacAddr, pSessionEntry->selfMacAddr, sizeof(tSirMacAddr) );
 #if defined WLAN_FEATURE_VOWIFI
diff -uNr qcacld-2.0/CORE/MAC/src/pe/lim/limSendSmeRspMessages.c qcacld-2.0-new/CORE/MAC/src/pe/lim/limSendSmeRspMessages.c
--- qcacld-2.0/CORE/MAC/src/pe/lim/limSendSmeRspMessages.c	2015-10-20 10:18:50.000000000 +0800
+++ qcacld-2.0-new/CORE/MAC/src/pe/lim/limSendSmeRspMessages.c	2015-10-28 19:41:06.000000000 +0800
@@ -233,6 +233,48 @@
     limSysProcessMmhMsgApi(pMac, &mmhMsg,  ePROT);
 } /*** end limSendSmeRsp() ***/
 
+static void limSendSmeSnifferRspInternal( tpAniSirGlobal pMac,
+		eHalStatus status, tANI_U32 *ctx)
+{
+	tSirMsgQ         mmhMsg;
+	tpSirSmeSnifferRsp  pSirSmeSnifferRsp = (tpSirSmeSnifferRsp) ctx;
+
+	mmhMsg.type = pSirSmeSnifferRsp->messageType;
+	mmhMsg.bodyptr = pSirSmeSnifferRsp;
+	mmhMsg.bodyval = 0;
+	MTRACE(macTraceMsgTx(pMac, NO_SESSION, mmhMsg.type));
+	limSysProcessMmhMsgApi(pMac, &mmhMsg,  ePROT);
+}
+
+void
+limSendSmeSnifferRsp(tpAniSirGlobal pMac, tANI_U16 msgType,
+		tSirResultCodes resultCode,
+		tpPESession psessionEntry,tANI_U8 smesessionId,tANI_U16 smetransactionId)
+{
+	tpSirSmeSnifferRsp  pSirSmeSnifferRsp;
+	tANI_U32 rspLen;
+
+	rspLen = sizeof(tSirSmeSnifferRsp);
+
+	pSirSmeSnifferRsp = vos_mem_malloc(rspLen);
+	if ( NULL == pSirSmeSnifferRsp )
+	{
+		/// Buffer not available. Log error
+		limLog(pMac, LOGP, FL("call to AllocateMemory failed for JOIN/REASSOC_RSP"));
+		return;
+	}
+	vos_mem_set((tANI_U8*)pSirSmeSnifferRsp, rspLen, 0);
+
+	if(psessionEntry) {
+		pSirSmeSnifferRsp->messageType = msgType;
+		pSirSmeSnifferRsp->length = (tANI_U16) rspLen;
+		pSirSmeSnifferRsp->statusCode = resultCode;
+		pSirSmeSnifferRsp->sessionId = smesessionId;
+		pSirSmeSnifferRsp->transactionId = smetransactionId;
+	}
+
+	limSendSmeSnifferRspInternal(pMac, eHAL_STATUS_SUCCESS, (tANI_U32*) pSirSmeSnifferRsp );
+}
 
 /**
  * limSendSmeJoinReassocRspAfterResume()
diff -uNr qcacld-2.0/CORE/MAC/src/pe/lim/limSendSmeRspMessages.h qcacld-2.0-new/CORE/MAC/src/pe/lim/limSendSmeRspMessages.h
--- qcacld-2.0/CORE/MAC/src/pe/lim/limSendSmeRspMessages.h	2015-10-20 10:18:50.000000000 +0800
+++ qcacld-2.0-new/CORE/MAC/src/pe/lim/limSendSmeRspMessages.h	2015-10-28 19:41:16.000000000 +0800
@@ -56,6 +56,7 @@
                        tSirMacAddr, tAniAuthType, tANI_U16,tpPESession,tANI_U8,tANI_U16);
 
 void limSendSmeJoinReassocRsp(tpAniSirGlobal, tANI_U16, tSirResultCodes, tANI_U16,tpPESession,tANI_U8,tANI_U16);
+void limSendSmeSnifferRsp(tpAniSirGlobal, tANI_U16, tSirResultCodes, tpPESession,tANI_U8,tANI_U16);
 void limSendSmeDisassocNtf(tpAniSirGlobal, tSirMacAddr, tSirResultCodes, tANI_U16, tANI_U16,tANI_U8,tANI_U16,tpPESession);
 void limSendSmeDeauthNtf(tpAniSirGlobal, tSirMacAddr, tSirResultCodes, tANI_U16, tANI_U16, tANI_U8, tANI_U16);
 void limSendSmeDisassocInd(tpAniSirGlobal, tpDphHashNode,tpPESession);
diff -uNr qcacld-2.0/CORE/MAC/src/pe/lim/limSerDesUtils.c qcacld-2.0-new/CORE/MAC/src/pe/lim/limSerDesUtils.c
--- qcacld-2.0/CORE/MAC/src/pe/lim/limSerDesUtils.c	2015-10-20 10:18:50.000000000 +0800
+++ qcacld-2.0-new/CORE/MAC/src/pe/lim/limSerDesUtils.c	2015-10-28 19:41:44.000000000 +0800
@@ -835,6 +835,89 @@
 
 } /*** end limStopBssReqSerDes() ***/
 
+tSirRetStatus
+limSnifferReqSerDes(tpAniSirGlobal pMac, tpSirSmeSnifferReq pSnifferReq, tANI_U8 *pBuf)
+{
+	tANI_S16 len = 0;
+
+	if (!pSnifferReq || !pBuf)
+	{
+		PELOGE(limLog(pMac, LOGE, FL("pSnifferReq or pBuf is NULL"));)
+			return eSIR_FAILURE;
+	}
+
+	pSnifferReq->messageType = limGetU16(pBuf);
+	pBuf += sizeof(tANI_U16);
+
+	len = pSnifferReq->length = limGetU16(pBuf);
+	pBuf += sizeof(tANI_U16);
+
+	len -= sizeof(tANI_U32);
+	if (limCheckRemainingLength(pMac, len) == eSIR_FAILURE)
+	{
+		limLog(pMac, LOGE, FL("remaining len %d is too short"), len);
+		return eSIR_FAILURE;
+	}
+
+	/* extrace sessionId */
+	pSnifferReq->sessionId = *pBuf++;
+	len--;
+	if (limCheckRemainingLength(pMac, len) == eSIR_FAILURE)
+	{
+		limLog(pMac, LOGE, FL("remaining len %d is too short"), len);
+		return eSIR_FAILURE;
+	}
+
+	/* extract transactionId */
+	pSnifferReq->transactionId = limGetU16(pBuf);
+	pBuf += sizeof(tANI_U16);
+	len  -= sizeof(tANI_U16);
+	if (limCheckRemainingLength(pMac, len) == eSIR_FAILURE)
+	{
+		limLog(pMac, LOGE, FL("remaining len %d is too short"), len);
+		return eSIR_FAILURE;
+	}
+	
+	/* extract selfMacAddr */
+	vos_mem_copy( pSnifferReq->selfMacAddr, pBuf, sizeof(tSirMacAddr));
+	pBuf += sizeof(tSirMacAddr);
+	len -= sizeof(tSirMacAddr);
+	if (limCheckRemainingLength(pMac, len) == eSIR_FAILURE)
+	{
+		limLog(pMac, LOGE, FL("remaining len %d is too short"), len);
+		return eSIR_FAILURE;
+	}
+
+	/* extract dot11mode */
+	pSnifferReq->dot11mode= *pBuf++;
+	len--;
+	if (limCheckRemainingLength(pMac, len) == eSIR_FAILURE)
+	{
+		limLog(pMac, LOGE, FL("remaining len %d is too short"), len);
+		return eSIR_FAILURE;
+	}
+
+	/* bsspersona */
+	pSnifferReq->staPersona = *pBuf++;
+	len--;
+	if (limCheckRemainingLength(pMac, len) == eSIR_FAILURE)
+	{
+		limLog(pMac, LOGE, FL("remaining len %d is too short"), len);
+		return eSIR_FAILURE;
+	}
+
+	/* cbmode */
+	pSnifferReq->cbMode = *pBuf++;
+	len--;
+	if (limCheckRemainingLength(pMac, len) == eSIR_FAILURE)
+	{
+		limLog(pMac, LOGE, FL("remaining len %d is too short"), len);
+		return eSIR_FAILURE;
+	}
+
+	return eSIR_SUCCESS;
+}
+
 
 
 /**
diff -uNr qcacld-2.0/CORE/MAC/src/pe/lim/limSerDesUtils.h qcacld-2.0-new/CORE/MAC/src/pe/lim/limSerDesUtils.h
--- qcacld-2.0/CORE/MAC/src/pe/lim/limSerDesUtils.h	2015-10-20 10:18:50.000000000 +0800
+++ qcacld-2.0-new/CORE/MAC/src/pe/lim/limSerDesUtils.h	2015-10-28 19:41:52.000000000 +0800
@@ -49,6 +49,7 @@
 tSirRetStatus   limStartBssReqSerDes(tpAniSirGlobal, tpSirSmeStartBssReq, tANI_U8 *);
 tSirRetStatus   limStopBssReqSerDes(tpAniSirGlobal, tpSirSmeStopBssReq, tANI_U8 *);
 tSirRetStatus   limJoinReqSerDes(tpAniSirGlobal, tpSirSmeJoinReq, tANI_U8 *);
+tSirRetStatus   limSnifferReqSerDes(tpAniSirGlobal, tpSirSmeSnifferReq, tANI_U8 *);
 void            limAssocIndSerDes(tpAniSirGlobal, tpLimMlmAssocInd, tANI_U8 *, tpPESession);
 void            limReassocIndSerDes(tpAniSirGlobal, tpLimMlmReassocInd, tANI_U8 *, tpPESession psessionEntry);
 tSirRetStatus   limAssocCnfSerDes(tpAniSirGlobal, tpSirSmeAssocCnf, tANI_U8 *);
diff -uNr qcacld-2.0/CORE/SERVICES/COMMON/_ieee80211_common.h qcacld-2.0-new/CORE/SERVICES/COMMON/_ieee80211_common.h
--- qcacld-2.0/CORE/SERVICES/COMMON/_ieee80211_common.h	2015-10-20 10:18:50.000000000 +0800
+++ qcacld-2.0-new/CORE/SERVICES/COMMON/_ieee80211_common.h	2015-10-28 19:29:11.000000000 +0800
@@ -184,6 +184,8 @@
 
 #define IEEE80211_2GCSA_TBTTCOUNT        3
 
+/* okkwon add for test */
+#ifndef IEEE80211_CHAN_TURBO
 /* bits 0-3 are for private use by drivers */
 /* channel attributes */
 #define IEEE80211_CHAN_TURBO            0x00000010 /* Turbo channel */
@@ -196,6 +198,9 @@
 #define IEEE80211_CHAN_GFSK             0x00000800 /* GFSK channel (FHSS PHY) */
 #define IEEE80211_CHAN_RADAR_DFS        0x00001000 /* Radar found on channel */
 #define IEEE80211_CHAN_STURBO           0x00002000 /* 11a static turbo channel only */
+#endif
+/* okkwon add for test */
+
 #define IEEE80211_CHAN_HALF             0x00004000 /* Half rate channel */
 #define IEEE80211_CHAN_QUARTER          0x00008000 /* Quarter rate channel */
 #define IEEE80211_CHAN_HT20             0x00010000 /* HT 20 channel */
diff -uNr qcacld-2.0/CORE/SERVICES/COMMON/ol_htt_api.h qcacld-2.0-new/CORE/SERVICES/COMMON/ol_htt_api.h
--- qcacld-2.0/CORE/SERVICES/COMMON/ol_htt_api.h	2015-10-20 10:18:50.000000000 +0800
+++ qcacld-2.0-new/CORE/SERVICES/COMMON/ol_htt_api.h	2015-10-28 19:29:28.000000000 +0800
@@ -107,6 +107,9 @@
    htt_op_mode_monitor,
 };
 
+void htt_pdev_set_sniffer_channel(htt_pdev_handle htt_pdev,
+		unsigned char channel, int freq);
+
 #ifdef QCA_WIFI_ISOC
 /**
  * @brief Notify HTT of a new virtual device, and specify the operating mode
diff -uNr qcacld-2.0/CORE/SERVICES/COMMON/ol_htt_rx_api.h qcacld-2.0-new/CORE/SERVICES/COMMON/ol_htt_rx_api.h
--- qcacld-2.0/CORE/SERVICES/COMMON/ol_htt_rx_api.h	2015-10-20 10:18:50.000000000 +0800
+++ qcacld-2.0-new/CORE/SERVICES/COMMON/ol_htt_rx_api.h	2015-10-28 19:29:45.000000000 +0800
@@ -551,7 +551,14 @@
 (*htt_rx_msdu_desc_key_id)(
     htt_pdev_handle pdev,
     void *mpdu_desc,
-    u_int8_t *key_id);
+	u_int8_t *key_id);
+
+extern int
+(*htt_rx_sniffer_amsdu_pop)(
+    htt_pdev_handle pdev,
+    adf_nbuf_t rx_ind_msg,
+    adf_nbuf_t *head_msdu,
+    adf_nbuf_t *tail_msdu);
 
 /*====================== rx MSDU + descriptor delivery ======================*/
 
diff -uNr qcacld-2.0/CORE/SERVICES/COMMON/ol_txrx_ctrl_api.h qcacld-2.0-new/CORE/SERVICES/COMMON/ol_txrx_ctrl_api.h
--- qcacld-2.0/CORE/SERVICES/COMMON/ol_txrx_ctrl_api.h	2015-10-20 10:18:50.000000000 +0800
+++ qcacld-2.0-new/CORE/SERVICES/COMMON/ol_txrx_ctrl_api.h	2015-10-28 19:29:54.000000000 +0800
@@ -104,6 +104,8 @@
 A_STATUS
 ol_txrx_pdev_attach_target(ol_txrx_pdev_handle data_pdev);
 
+void ol_txrx_pdev_set_sniffer_channel(ol_txrx_pdev_handle data_pdev,
+		unsigned char channel, int freq);
 
 /**
  * @brief Allocate and initialize the data object for a new virtual device.
diff -uNr qcacld-2.0/CORE/SERVICES/HIF/PCIe/if_pci.c qcacld-2.0-new/CORE/SERVICES/HIF/PCIe/if_pci.c
--- qcacld-2.0/CORE/SERVICES/HIF/PCIe/if_pci.c	2015-10-20 10:18:50.000000000 +0800
+++ qcacld-2.0-new/CORE/SERVICES/HIF/PCIe/if_pci.c	2015-10-28 19:30:53.000000000 +0800
@@ -1792,6 +1792,13 @@
         }
     }
 
+	if (hdd_get_conparam() == VOS_SNIFFER_MODE) {
+		printk(KERN_ERR"okkwon : prevent suspend\n");
+		goto out;
+	}
+
+	printk(KERN_ERR"okkwon : should not see this in sniffer mode\n");
+
     /* No need to send WMI_PDEV_SUSPEND_CMDID to FW if WOW is enabled */
     temp_module = vos_get_context(VOS_MODULE_ID_WDA, vos);
     if (!temp_module) {
diff -uNr qcacld-2.0/CORE/SERVICES/WMA/wma.c qcacld-2.0-new/CORE/SERVICES/WMA/wma.c
--- qcacld-2.0/CORE/SERVICES/WMA/wma.c	2015-10-20 10:18:50.000000000 +0800
+++ qcacld-2.0-new/CORE/SERVICES/WMA/wma.c	2015-10-28 19:32:33.000000000 +0800
@@ -873,7 +873,20 @@
 				wma->interfaces[resp_event->vdev_id].vdev_up =
 									TRUE;
 			}
-                }
+		}
+		else if (iface->type == WMI_VDEV_TYPE_MONITOR) {
+			if (wmi_unified_vdev_up_send(wma->wmi_handle,
+						resp_event->vdev_id, 0,
+						iface->addr)) {
+				WMA_LOGE("%s:vdev_up failed vdev_id %d",
+						__func__, resp_event->vdev_id);
+				wma->interfaces[resp_event->vdev_id].vdev_up =
+					FALSE;
+			} else {
+				wma->interfaces[resp_event->vdev_id].vdev_up =
+					TRUE;
+			}
+		}
 
 		wma_send_msg(wma, WDA_SWITCH_CHANNEL_RSP, (void *)params, 0);
 	} else if (req_msg->msg_type == WDA_ADD_BSS_REQ) {
@@ -3881,6 +3894,8 @@
                         break;
 #endif
 		case WMI_VDEV_TYPE_MONITOR:
+                        vdev_type = wlan_op_mode_monitor;
+                        break;
 		default:
 			WMA_LOGE("Invalid vdev type %u", type);
 			vdev_type = wlan_op_mode_unknown;
@@ -3917,10 +3932,10 @@
 	cmd->vdev_type = type;
 	cmd->vdev_subtype = subtype;
 	WMI_CHAR_ARRAY_TO_MAC_ADDR(macaddr, &cmd->vdev_macaddr);
-	WMA_LOGE("%s: ID = %d VAP Addr = %02x:%02x:%02x:%02x:%02x:%02x",
+	WMA_LOGE("%s: ID = %d VAP Addr = %02x:%02x:%02x:%02x:%02x:%02x type = %d",
 		 __func__, if_id,
 		 macaddr[0], macaddr[1], macaddr[2],
-		 macaddr[3], macaddr[4], macaddr[5]);
+		 macaddr[3], macaddr[4], macaddr[5], type);
 	ret = wmi_unified_cmd_send(wmi_handle, buf, len, WMI_VDEV_CREATE_CMDID);
 	if (ret != EOK) {
 		WMA_LOGE("Failed to send WMI_VDEV_CREATE_CMDID");
@@ -4019,8 +4034,9 @@
 	struct wma_txrx_node *iface = &wma_handle->interfaces[vdev_id];
 	struct wma_target_req *msg;
 
-	if ((iface->type == WMI_VDEV_TYPE_AP) &&
-	    (iface->sub_type == WMI_UNIFIED_VDEV_SUBTYPE_P2P_DEVICE)) {
+	if (((iface->type == WMI_VDEV_TYPE_AP) &&
+	    (iface->sub_type == WMI_UNIFIED_VDEV_SUBTYPE_P2P_DEVICE)) ||
+			(iface->type == WMI_VDEV_TYPE_MONITOR)) {
 
 		WMA_LOGA("P2P Device: removing self peer %pM",
 				pdel_sta_self_req_param->selfMacAddr);
@@ -4147,6 +4163,9 @@
 {
 	ol_txrx_peer_handle peer;
 
+	printk(KERN_ERR"okkwon peer mac : "MAC_ADDRESS_STR"\n",
+			MAC_ADDR_ARRAY(peer_addr));
+
 	if (++wma->peer_count > wma->wlan_resource_config.num_peers) {
 		WMA_LOGP("%s, the peer count exceeds the limit %d",
 			 __func__, wma->peer_count - 1);
@@ -4709,10 +4728,10 @@
 	adf_os_atomic_init(&wma_handle->interfaces
 			   [self_sta_req->sessionId].bss_status);
 
-	if ((self_sta_req->type == WMI_VDEV_TYPE_AP) &&
+	if (((self_sta_req->type == WMI_VDEV_TYPE_AP) &&
 			(self_sta_req->subType ==
-			 WMI_UNIFIED_VDEV_SUBTYPE_P2P_DEVICE)) {
-		WMA_LOGA("P2P Device: creating self peer %pM, vdev_id %hu",
+			 WMI_UNIFIED_VDEV_SUBTYPE_P2P_DEVICE))) {
+		WMA_LOGA("P2P or sniffer Device: creating self peer %pM, vdev_id %hu",
 				self_sta_req->selfMacAddr,
 				self_sta_req->sessionId);
 		status = wma_create_peer(wma_handle, txrx_pdev,
@@ -4727,6 +4746,12 @@
 		}
 	}
 
+	/* add dummy peer for sniffer -_-;; */
+	if (self_sta_req->type == WMI_VDEV_TYPE_MONITOR) {
+		ol_txrx_peer_attach(txrx_pdev, txrx_vdev_handle,
+				self_sta_req->selfMacAddr);
+	}
+
 	if (wlan_cfgGetInt(mac, WNI_CFG_RTS_THRESHOLD,
 			&cfg_val) == eSIR_SUCCESS) {
 		ret = wmi_unified_vdev_set_param_send(wma_handle->wmi_handle,
@@ -7205,6 +7230,8 @@
 	WLAN_PHY_MODE chanmode;
 	u_int8_t *buf_ptr;
 	struct wma_txrx_node *intr = wma->interfaces;
+	ol_txrx_pdev_handle txrx_pdev = vos_get_context(VOS_MODULE_ID_TXRX,
+						wma->vos_context);
 
 	WMA_LOGD("%s: Enter isRestart=%d vdev=%d", __func__, isRestart,req->vdev_id);
 	len = sizeof(*cmd) + sizeof(wmi_channel) +
@@ -7226,11 +7253,13 @@
 		       WMITLV_GET_STRUCT_TLVLEN(wmi_channel));
 	cmd->vdev_id = req->vdev_id;
 
+
 	/* Fill channel info */
 	chan->mhz = vos_chan_to_freq(req->chan);
 	chanmode = wma_chan_to_mode(req->chan, req->chan_offset,
 				req->vht_capable);
 
+
 	intr[cmd->vdev_id].chanmode = chanmode; /* save channel mode */
 	intr[cmd->vdev_id].ht_capable = req->ht_capable;
 	intr[cmd->vdev_id].vht_capable = req->vht_capable;
@@ -7247,6 +7276,9 @@
 	WMI_SET_CHANNEL_MODE(chan, chanmode);
 	chan->band_center_freq1 = chan->mhz;
 
+	/* set monitor channel */
+	ol_txrx_pdev_set_sniffer_channel(txrx_pdev, req->chan, chan->band_center_freq1);
+
 	if (chanmode == MODE_11AC_VHT80)
 		chan->band_center_freq1 = vos_chan_to_freq(wma_getCenterChannel
 			(req->chan, req->chan_offset));
@@ -7259,6 +7291,7 @@
 			chan->band_center_freq1 -= 10;
 	}
 	chan->band_center_freq2 = 0;
+
 	/*
 	 * If the channel has DFS set, flip on radar reporting.
 	 *
@@ -7872,6 +7905,8 @@
 	req.chan = params->channelNumber;
 	req.chan_offset = params->secondaryChannelOffset;
 	req.vht_capable = params->vhtCapable;
+	printk(KERN_ERR"okkwon : chan %u, offset %u, mode %u\n",
+			req.chan, req.chan_offset, req.oper_mode);
 #ifdef WLAN_FEATURE_VOWIFI
 	req.max_txpow = params->maxTxPower;
 #else
@@ -7885,8 +7920,9 @@
 	 * issuse VDEV RESTART, so we making is_channel_switch as
 	 * TRUE
 	 */
-	if((wma->interfaces[req.vdev_id].type == WMI_VDEV_TYPE_AP ) &&
-			(wma->interfaces[req.vdev_id].sub_type == 0))
+	if(((wma->interfaces[req.vdev_id].type == WMI_VDEV_TYPE_AP ) &&
+			(wma->interfaces[req.vdev_id].sub_type == 0)) ||
+			wma->interfaces[req.vdev_id].type == WMI_VDEV_TYPE_MONITOR)
 		wma->interfaces[req.vdev_id].is_channel_switch = VOS_TRUE;
 
 	status = wma_vdev_start(wma, &req,
diff -uNr qcacld-2.0/CORE/SME/inc/sme_Api.h qcacld-2.0-new/CORE/SME/inc/sme_Api.h
--- qcacld-2.0/CORE/SME/inc/sme_Api.h	2015-10-20 10:18:50.000000000 +0800
+++ qcacld-2.0-new/CORE/SME/inc/sme_Api.h	2015-10-28 19:33:06.000000000 +0800
@@ -335,6 +335,11 @@
                            tANI_U8 *pbSessionId, tANI_U32 type,
                            tANI_U32 subType);
 
+eHalStatus sme_OpenSnifferSession(tHalHandle hHal, csrRoamCompleteCallback callback,
+                           void *pContext, tANI_U8 *pSelfMacAddr,
+                           tANI_U8 *pbSessionId, tANI_U32 type,
+                           tANI_U32 subType);
+
 /*--------------------------------------------------------------------------
 
   \brief sme_SetCurrDeviceMode() - Sets the current operating device mode.
@@ -537,6 +542,8 @@
 
 v_VOID_t sme_FreeMsg( tHalHandle hHal, vos_msg_t* pMsg );
 
+eHalStatus sme_StartSniffer(tHalHandle hHal, tANI_U8 sessionId);
+
 /* ---------------------------------------------------------------------------
     \fn sme_ScanRequest
     \brief a wrapper function to Request a 11d or full scan from CSR.
@@ -650,10 +657,8 @@
 
   \return eHalStatus
 -----------------------------------------------------------------------------*/
-eHalStatus sme_RoamRegisterLinkQualityIndCallback(tHalHandle hHal, tANI_U8 sessionId,
-                                                  csrRoamLinkQualityIndCallback   callback,
-                                                  void                           *pContext);
 
+eHalStatus sme_RoamIssueSniffer(tHalHandle hHal, tANI_U8 sessionId);
 
 /* ---------------------------------------------------------------------------
     \fn sme_RoamConnect
diff -uNr qcacld-2.0/CORE/SME/inc/smeInside.h qcacld-2.0-new/CORE/SME/inc/smeInside.h
--- qcacld-2.0/CORE/SME/inc/smeInside.h	2015-10-20 10:18:50.000000000 +0800
+++ qcacld-2.0-new/CORE/SME/inc/smeInside.h	2015-10-28 19:33:18.000000000 +0800
@@ -241,6 +241,7 @@
 
 tANI_BOOLEAN qosProcessCommand( tpAniSirGlobal pMac, tSmeCmd *pCommand );
 
+eHalStatus csrProcessSnifferCommand( tpAniSirGlobal pMac, tSmeCmd *pCommand );
 eHalStatus csrProcessScanCommand( tpAniSirGlobal pMac, tSmeCmd *pCommand );
 eHalStatus csrRoamProcessCommand( tpAniSirGlobal pMac, tSmeCmd *pCommand );
 void csrRoamProcessWmStatusChangeCommand( tpAniSirGlobal pMac, tSmeCmd *pCommand );
diff -uNr qcacld-2.0/CORE/SME/inc/smeInternal.h qcacld-2.0-new/CORE/SME/inc/smeInternal.h
--- qcacld-2.0/CORE/SME/inc/smeInternal.h	2015-10-20 10:18:50.000000000 +0800
+++ qcacld-2.0-new/CORE/SME/inc/smeInternal.h	2015-10-28 19:33:27.000000000 +0800
@@ -105,6 +105,7 @@
 #endif
     eSmeCommandRemainOnChannel,
     eSmeCommandNoAUpdate,
+	eSmeCommandSniffer,
 } eSmeCommandType;
 
 
diff -uNr qcacld-2.0/CORE/SME/src/csr/csrApiRoam.c qcacld-2.0-new/CORE/SME/src/csr/csrApiRoam.c
--- qcacld-2.0/CORE/SME/src/csr/csrApiRoam.c	2015-10-20 10:18:50.000000000 +0800
+++ qcacld-2.0-new/CORE/SME/src/csr/csrApiRoam.c	2015-10-28 19:34:07.000000000 +0800
@@ -7420,6 +7420,20 @@
     } /*else: ( eSIR_SME_SUCCESS == pSmeJoinRsp->statusCode ) */
 }
 
+eHalStatus csrRoamIssueSniffer( tpAniSirGlobal pMac, tANI_U32 sessionId)
+{
+	return csrSendSnifferReqMsg(pMac, sessionId, eWNI_SME_SNIFFER_REQ);
+}
+
+eHalStatus csrProcessSnifferCommand( tpAniSirGlobal pMac, tSmeCmd *pCommand )
+{
+	eHalStatus status = eHAL_STATUS_SUCCESS;
+
+	status = csrRoamIssueSniffer(pMac, pCommand->sessionId);
+
+	return status;
+}
+
 eHalStatus csrRoamIssueJoin( tpAniSirGlobal pMac, tANI_U32 sessionId, tSirBssDescription *pSirBssDesc,
                              tDot11fBeaconIEs *pIes,
                              tCsrRoamProfile *pProfile, tANI_U32 roamId )
@@ -12555,6 +12569,63 @@
     pBuf += pBssDescription->length + sizeof( pBssDescription->length );   // update to new location
 }
 
+eHalStatus csrSendSnifferReqMsg(tpAniSirGlobal pMac, tANI_U32 sessionId, tANI_U16 messageType)
+{
+	eHalStatus status = eHAL_STATUS_SUCCESS;
+	tSirSmeSnifferReq *pMsg;
+	tANI_U8 *pBuf;
+	tANI_U16 msgLen;
+	tCsrRoamSession *pSession = CSR_GET_SESSION( pMac, sessionId );
+	tANI_U32 ucDot11Mode = 0;
+
+	if(!pSession)
+	{
+		smsLog(pMac, LOGE, FL("  session %d not found "), sessionId);
+		return eHAL_STATUS_FAILURE;
+	}
+
+	pSession->joinFailStatusCode.statusCode = eSIR_SME_SUCCESS;
+   	pSession->joinFailStatusCode.reasonCode = 0;
+
+	msgLen = sizeof(tSirSmeSnifferReq);
+	pMsg = vos_mem_malloc(msgLen);
+	if (NULL == pMsg)
+		status = eHAL_STATUS_FAILURE;
+	else
+		status = eHAL_STATUS_SUCCESS;
+	if ( !HAL_STATUS_SUCCESS(status) ) return eHAL_STATUS_FAILURE;
+	vos_mem_set(pMsg, msgLen , 0);
+	pMsg->messageType = pal_cpu_to_be16((tANI_U16)messageType);
+	pMsg->length = pal_cpu_to_be16(msgLen);
+	pBuf = &pMsg->sessionId;
+
+	/*sessionid*/
+	*pBuf = (tANI_U8)sessionId;
+	pBuf++;
+	/*transacitonid*/
+	*pBuf = 0;
+	*( pBuf + 1 ) = 0;
+	pBuf += sizeof(tANI_U16);
+	// selfMacAddr
+	vos_mem_copy((tSirMacAddr *)pBuf, &pSession->selfMacAddr,
+			sizeof(tSirMacAddr));
+	pBuf += sizeof(tSirMacAddr);
+	/*dot11mode*/
+	ucDot11Mode = csrTranslateToWNICfgDot11Mode( pMac, pSession->bssParams.uCfgDot11Mode );
+	*pBuf = (tANI_U8)ucDot11Mode;
+	pBuf++;
+	/*persona*/
+	*pBuf = VOS_SNIFFER_MODE;
+	pBuf++;
+	/*cbmode*/
+	*pBuf = (tANI_U8)pSession->bssParams.cbMode;
+	pBuf++;
+
+	status = palSendMBMessage(pMac->hHdd, pMsg);
+
+	return status;
+}
+
 /*
   * The communication between HDD and LIM is thru mailbox (MB).
   * Both sides will access the data structure "tSirSmeJoinReq".
diff -uNr qcacld-2.0/CORE/SME/src/csr/csrInsideApi.h qcacld-2.0-new/CORE/SME/src/csr/csrInsideApi.h
--- qcacld-2.0/CORE/SME/src/csr/csrInsideApi.h	2015-10-20 10:18:50.000000000 +0800
+++ qcacld-2.0-new/CORE/SME/src/csr/csrInsideApi.h	2015-10-28 19:34:25.000000000 +0800
@@ -305,6 +305,7 @@
 
 eHalStatus csrRoamCallCallback(tpAniSirGlobal pMac, tANI_U32 sessionId, tCsrRoamInfo *pRoamInfo,
                                tANI_U32 roamId, eRoamCmdStatus u1, eCsrRoamResult u2);
+eHalStatus csrRoamIssueSniffer(tpAniSirGlobal pMac, tANI_U32 sessionId);
 eHalStatus csrRoamIssueConnect(tpAniSirGlobal pMac, tANI_U32 sessionId, tCsrRoamProfile *pProfile,
                                tScanResultHandle hBSSList,
                                eCsrRoamReason reason, tANI_U32 roamId,
@@ -340,6 +341,7 @@
 //pCommand may be NULL
 void csrRoamRemoveDuplicateCommand(tpAniSirGlobal pMac, tANI_U32 sessionId, tSmeCmd *pCommand, eCsrRoamReason eRoamReason);
 
+eHalStatus csrSendSnifferReqMsg( tpAniSirGlobal pMac, tANI_U32 sessionId, tANI_U16 messageType);
 eHalStatus csrSendJoinReqMsg( tpAniSirGlobal pMac, tANI_U32 sessionId, tSirBssDescription *pBssDescription,
                               tCsrRoamProfile *pProfile, tDot11fBeaconIEs *pIes, tANI_U16 messageType );
 eHalStatus csrSendMBDisassocReqMsg( tpAniSirGlobal pMac, tANI_U32 sessionId, tSirMacAddr bssId, tANI_U16 reasonCode );
diff -uNr qcacld-2.0/CORE/SME/src/sme_common/sme_Api.c qcacld-2.0-new/CORE/SME/src/sme_common/sme_Api.c
--- qcacld-2.0/CORE/SME/src/sme_common/sme_Api.c	2015-10-20 10:18:50.000000000 +0800
+++ qcacld-2.0-new/CORE/SME/src/sme_common/sme_Api.c	2015-10-28 19:34:49.000000000 +0800
@@ -889,6 +889,10 @@
                        TRACE_CODE_SME_COMMAND, pCommand->sessionId, pCommand->command));
                     switch ( pCommand->command )
                     {
+						case eSmeCommandSniffer:
+							 csrLLUnlock( &pMac->sme.smeCmdActiveList );
+							 status = csrProcessSnifferCommand( pMac, pCommand );
+							 break;
 
                         case eSmeCommandScan:
                             csrLLUnlock( &pMac->sme.smeCmdActiveList );
@@ -3300,6 +3304,33 @@
     return smeConfig.csrConfig.channelBondingMode5GHz;
 }
 
+eHalStatus sme_StartSniffer(tHalHandle hHal, tANI_U8 sessionId)
+{
+	eHalStatus status = eHAL_STATUS_FAILURE;
+	tpAniSirGlobal pMac = PMAC_STRUCT( hHal );
+
+	if (!pMac)
+	{
+		return eHAL_STATUS_FAILURE;
+	}
+
+	printk(KERN_ERR"okkwon : %s\n", __func__);
+	smsLog(pMac, LOG2, FL("enter"));
+	status = sme_AcquireGlobalLock( &pMac->sme );
+	if ( HAL_STATUS_SUCCESS( status ) )
+	{
+		status = csrRoamIssueSniffer( pMac, sessionId );
+		sme_ReleaseGlobalLock( &pMac->sme );
+	}
+	else
+	{
+		smsLog(pMac, LOGE, FL("sme_AcquireGlobalLock failed"));
+	}
+	printk(KERN_ERR"okkwon : %s exit\n", __func__);
+
+	return (status);
+}
+
 /* ---------------------------------------------------------------------------
     \fn sme_GetChannelBondingMode24G
     \brief get the channel bonding mode for 2.4G band
@@ -11723,6 +11754,9 @@
         status = csrRoamChannelChangeReq( pMac, sessionId, targetChannel,
                        pMac->roam.configParam.channelBondingMode5GHz);
 
+		printk(KERN_ERR"okkwon : phymode %d bondingmode %d\n",
+				phyMode,  pMac->roam.configParam.channelBondingMode5GHz);
+
         sme_ReleaseGlobalLock( &pMac->sme );
     }
     return (status);
diff -uNr qcacld-2.0/CORE/TL/inc/wlan_qct_tl.h qcacld-2.0-new/CORE/TL/inc/wlan_qct_tl.h
--- qcacld-2.0/CORE/TL/inc/wlan_qct_tl.h	2015-10-20 10:18:50.000000000 +0800
+++ qcacld-2.0-new/CORE/TL/inc/wlan_qct_tl.h	2015-10-28 19:35:06.000000000 +0800
@@ -175,6 +175,8 @@
   WLAN_STA_TDLS,    /* 4 */
 #endif
 
+  WLAN_STA_SNIFFER,
+
 
   /* Invalid link*/
   WLAN_STA_MAX
diff -uNr qcacld-2.0/CORE/VOSS/inc/vos_types.h qcacld-2.0-new/CORE/VOSS/inc/vos_types.h
--- qcacld-2.0/CORE/VOSS/inc/vos_types.h	2015-10-20 10:18:50.000000000 +0800
+++ qcacld-2.0-new/CORE/VOSS/inc/vos_types.h	2015-10-28 19:35:24.000000000 +0800
@@ -146,6 +146,7 @@
     VOS_FTM_MODE = 5,
     VOS_IBSS_MODE,
     VOS_P2P_DEVICE_MODE,
+	VOS_SNIFFER_MODE = 8,
     VOS_MAX_NO_OF_MODE
 } tVOS_CON_MODE;
 
diff -uNr qcacld-2.0/CORE/VOSS/src/vos_api.c qcacld-2.0-new/CORE/VOSS/src/vos_api.c
--- qcacld-2.0/CORE/VOSS/src/vos_api.c	2015-10-20 10:18:50.000000000 +0800
+++ qcacld-2.0-new/CORE/VOSS/src/vos_api.c	2015-10-28 19:35:53.000000000 +0800
@@ -1426,12 +1426,14 @@
     }
     gpVosContext->isLoadUnloadInProgress = value;
 
+#if 0
 #ifdef CONFIG_CNSS
     if (value)
         cnss_set_driver_status(CNSS_LOAD_UNLOAD);
     else
         cnss_set_driver_status(CNSS_INITIALIZED);
 #endif
+#endif
 }
 
 v_U8_t vos_is_reinit_in_progress(VOS_MODULE_ID moduleId, v_VOID_t *moduleContext)
@@ -2536,6 +2538,12 @@
             *type = WMI_VDEV_TYPE_AP;
             *sub_type = WMI_UNIFIED_VDEV_SUBTYPE_P2P_GO;
             break;
+        case VOS_MONITOR_MODE:
+            *type = WMI_VDEV_TYPE_MONITOR;
+            break;
+		case VOS_SNIFFER_MODE:
+			*type = WMI_VDEV_TYPE_MONITOR;
+			break;
         default:
             hddLog(VOS_TRACE_LEVEL_ERROR, "Invalid device mode %d", mode);
             status = VOS_STATUS_E_INVAL;
diff -uNr qcacld-2.0/CORE/VOSS/src/vos_sched.c qcacld-2.0-new/CORE/VOSS/src/vos_sched.c
--- qcacld-2.0/CORE/VOSS/src/vos_sched.c	2015-10-20 10:18:50.000000000 +0800
+++ qcacld-2.0-new/CORE/VOSS/src/vos_sched.c	2015-10-28 19:36:30.000000000 +0800
@@ -67,6 +67,9 @@
 #include <net/cnss.h>
 #endif
 #endif
+//airkiss feature.
+#include "smart_cfg.h"
+
 /*---------------------------------------------------------------------------
  * Preprocessor Definitions and Constants
  * ------------------------------------------------------------------------*/
@@ -93,6 +96,9 @@
  * Forward declaration
  * ------------------------------------------------------------------------*/
 static int VosMCThread(void *Arg);
+//airkiss feature
+static int VosSmartcfgThread(void *Arg);
+
 static int VosWDThread(void *Arg);
 static int VosTXThread(void *Arg);
 static int VosRXThread(void *Arg);
@@ -243,14 +249,16 @@
   init_completion(&pSchedContext->ResumeMcEvent);
   init_completion(&pSchedContext->ResumeTxEvent);
   init_completion(&pSchedContext->ResumeRxEvent);
-
+  //airkiss feature
+  init_completion(&pSchedContext->SmartStartEvent);
   spin_lock_init(&pSchedContext->McThreadLock);
   spin_lock_init(&pSchedContext->TxThreadLock);
   spin_lock_init(&pSchedContext->RxThreadLock);
 #ifdef QCA_CONFIG_SMP
   spin_lock_init(&pSchedContext->TlshimRxThreadLock);
 #endif
-
+   //airkiss feature
+  init_waitqueue_head(&pSchedContext->SmartWaitQueue);
   init_waitqueue_head(&pSchedContext->mcWaitQueue);
   pSchedContext->mcEventFlag = 0;
   init_waitqueue_head(&pSchedContext->txWaitQueue);
@@ -344,6 +352,17 @@
   wake_up_process(pSchedContext->TlshimRxThread);
   VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_INFO_HIGH,
              ("VOSS Tlshim RX thread Created"));
+  //airkiss feature
+	pSchedContext->SmartcfgThread= kthread_create(VosSmartcfgThread, pSchedContext,
+											   "VosMCThread");
+	  if (IS_ERR(pSchedContext->SmartcfgThread))
+	  {
+		 VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_FATAL,
+				   "%s: Could not Create VOSS smartcfg Thread Controller",__func__);
+	  }
+	  wake_up_process(pSchedContext->SmartcfgThread);
+	  VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_INFO_HIGH,
+				"%s: VOSS smartcfg thread Created",__func__);
 #endif
   /*
   ** Now make sure all threads have started before we exit.
@@ -358,6 +377,10 @@
   wait_for_completion_interruptible(&pSchedContext->RxStartEvent);
   VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_INFO_HIGH,
                "%s: VOSS Rx Thread has started",__func__);
+  //airkiss feature
+  wait_for_completion_interruptible(&pSchedContext->SmartStartEvent);
+  VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_INFO_HIGH,
+               "%s: VOSS smartcfg Thread has started",__func__);
 #ifdef QCA_CONFIG_SMP
   wait_for_completion_interruptible(&pSchedContext->TlshimRxStartEvent);
   VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_INFO_HIGH,
@@ -460,6 +483,138 @@
                "%s: VOSS Watchdog Thread has started",__func__);
   return VOS_STATUS_SUCCESS;
 } /* vos_watchdog_open() */
+
+void VosAddChannelListIfNotExist(hdd_adapter_t* pAdapter, unsigned char channelId)
+{
+	int i=0;
+	v_BOOL_t is_exist = false;
+	int last_pos = 0;
+	if(channelId == 0)
+	{
+		printk("hangtian: fault channel id\n");
+		return;
+	}
+	//check if already exist
+	for(i = 0; i < HDD_AK_MAX_BSS_NUM; i++)
+	{
+		if(pAdapter->ak_chan_list[i] == channelId)
+			is_exist = true;
+		if(pAdapter->ak_chan_list[i] == 0)
+		{
+			last_pos = i;
+			break;
+		}
+	}
+	if(is_exist)
+	{
+		return;
+	}
+	pAdapter->ak_chan_list[last_pos] = channelId;
+	printk("hangtian: added channel %d\n", channelId);
+}
+
+static int VosSmartcfgThread(void * Arg)
+{
+	pVosSchedContext pSchedContext = (pVosSchedContext)Arg;
+	VOS_STATUS vStatus			 = VOS_STATUS_SUCCESS;
+	hdd_context_t *pHddCtx		 = NULL;
+	v_CONTEXT_t pVosContext		 = NULL;
+	hdd_adapter_t* pAdapter = NULL;
+	tHalHandle hHal;
+	struct smartcfg *smartcfg_t	= NULL;
+	struct channel_list *channel_list_t = NULL;
+	int channel_id = 1;
+	int waitstatus = 0;
+
+	if (Arg == NULL)
+	{
+		VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_ERROR,
+			"%s: Bad Args passed", __func__);
+		return 0;
+	}
+	//wait VosMCThread initialize smartcfg.
+	complete(&pSchedContext->SmartStartEvent);
+	/* Get the Global VOSS Context */
+	pVosContext = vos_get_global_context(VOS_MODULE_ID_SYS, NULL);
+	if(!pVosContext) {
+		hddLog(VOS_TRACE_LEVEL_FATAL,"%s: Global VOS context is Null", __func__);
+		return 0;
+	}
+	/* Get the HDD context */
+	pHddCtx = (hdd_context_t *)vos_get_context(VOS_MODULE_ID_HDD, pVosContext );
+	if(!pHddCtx) {
+		hddLog(VOS_TRACE_LEVEL_FATAL,"%s: HDD context is Null",__func__);
+		return 0;
+	}
+	VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_FATAL,
+               "%s: VOSS Smartcfg Thread has started",__func__);
+	/*
+	*	wait VosMCThread initialize smartcfg.
+	*/
+	waitstatus = wait_event_interruptible(pSchedContext->SmartWaitQueue,pSchedContext->SmartEventFlag);
+	if(waitstatus == -ERESTARTSYS){
+		VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_ERROR,
+				"%s: wait_event_interruptible returned -ERESTARTSYS", __func__);
+		return 0;
+	}
+	pSchedContext->SmartEventFlag = false;
+
+	if (pSchedContext->smartcfg_t){
+		smartcfg_t = pSchedContext->smartcfg_t;
+		channel_list_t = &(pSchedContext->channel_list_t);
+		VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_FATAL,
+               "%s: VOSS Smartcfg has been initialized.",__func__);
+	}
+	else{
+		VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_ERROR,"%s: smartcfg is null", __func__);
+		return 0;
+	}
+	pAdapter = hdd_get_adapter(pHddCtx, WLAN_HDD_SNIFFER);
+	if(!pAdapter){
+		VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_ERROR,
+               "%s: pAdapter is NULL",__func__);
+		return 0;
+	}
+	hHal = WLAN_HDD_GET_HAL_CTX(pAdapter);
+
+	while (1){
+		//wait protocol process result to decide switch channel or not.
+		waitstatus = wait_event_interruptible(pSchedContext->SmartWaitQueue,pSchedContext->SmartEventFlag);
+		if(waitstatus == -ERESTARTSYS){
+			VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_ERROR,
+					"%s: wait_event_interruptible returned -ERESTARTSYS", __func__);
+			break;
+		}
+		
+		do{
+				channel_id = *(channel_list_t->list + smartcfg_t->count);
+				smartcfglog(VOS_TRACE_LEVEL_FATAL,"%s set channel %d.\n",__func__,channel_id);
+				if(channel_id != 157){
+					if (channel_id > 15) {
+						sme_RoamChannelChangeReq(hHal, 0, channel_id, eCSR_DOT11_MODE_11ac);
+					}
+					else {
+						sme_RoamChannelChangeReq(hHal, 0, channel_id, eCSR_DOT11_MODE_11n);
+					}
+				}
+				else
+					smartcfglog(VOS_TRACE_LEVEL_FATAL,"%s skip channel %d.\n",__func__,channel_id);
+				smartcfg_t->count++;
+				if(channel_list_t->length == 0)
+					smartcfg_t->count %= 14;
+				else
+					smartcfg_t->count %= channel_list_t->length;
+				smartcfglog(VOS_TRACE_LEVEL_FATAL,"%s next channel: channel[%d]=%d.\n",__func__,smartcfg_t->count,
+					*(channel_list_t->list + smartcfg_t->count));
+				
+		}while(0);
+		pSchedContext->SmartEventFlag = false;
+	}
+
+	return vStatus;
+
+}
+
 /*---------------------------------------------------------------------------
   \brief VosMcThread() - The VOSS Main Controller thread
   The \a VosMcThread() is the VOSS main controller thread:
@@ -482,6 +637,12 @@
   v_BOOL_t shutdown              = VOS_FALSE;
   hdd_context_t *pHddCtx         = NULL;
   v_CONTEXT_t pVosContext        = NULL;
+  tScanResultHandle pResult;
+  tCsrScanResultInfo* pScanResult;
+  hdd_adapter_t* pAdapter = NULL;
+  tHalHandle hHal;
+  //airkiss feature
+  struct channel_list *pchannel_list_t = &(pSchedContext->channel_list_t);
 
   if (Arg == NULL)
   {
@@ -550,6 +711,39 @@
         }
         break;
       }
+	/* 
+	* For Tencent Airkiss
+	*/
+	pAdapter = hdd_get_adapter(pHddCtx, WLAN_HDD_SNIFFER);
+	if((pAdapter) && (!pAdapter->ak_not_1st))
+	{
+		hHal = WLAN_HDD_GET_HAL_CTX(pAdapter);
+		sme_ScanGetResult(hHal, pAdapter->sessionId, NULL, &pResult);
+		if(pResult)
+		{
+			pAdapter->ak_not_1st = true;
+			pScanResult = sme_ScanResultGetFirst(hHal, pResult);	
+			while(pScanResult)
+			{
+				VosAddChannelListIfNotExist(pAdapter, pScanResult->BssDescriptor.channelId);
+				pScanResult = sme_ScanResultGetNext(hHal, pResult);
+			}
+			printk("hangtian: start sniffer mode\n");
+			hdd_sniffer_start(pAdapter->dev);
+			//airkiss feature
+			smartcfg_task_init(pSchedContext,pAdapter,pchannel_list_t);
+			if (pSchedContext->smartcfg_t != NULL){
+				//pSchedContext->SmartEventFlag = true;
+				//wake_up_interruptible(&(pSchedContext->SmartWaitQueue));
+				smartcfglog(VOS_TRACE_LEVEL_FATAL,"%s:smartcfg initialized!!--%d.\n",__func__,pSchedContext->smartcfg_t->ready);
+			}
+			else{
+				smartcfglog(VOS_TRACE_LEVEL_FATAL,"%s:smartcfg null.\n",__func__);
+			}
+		}
+		sme_ScanResultPurge(hHal, pResult);
+	}
+	
       /*
       ** Check the WDI queue
       ** Service it till the entire queue is empty
@@ -1657,8 +1851,7 @@
     //Wait for MC to exit
     wait_for_completion(&gpVosSchedContext->McShutdown);
     gpVosSchedContext->McThread = 0;
-
-    // shut down TX Thread
+	// shut down TX Thread
     set_bit(TX_SHUTDOWN_EVENT_MASK, &gpVosSchedContext->txEventFlag);
     set_bit(TX_POST_EVENT_MASK, &gpVosSchedContext->txEventFlag);
     wake_up_interruptible(&gpVosSchedContext->txWaitQueue);
diff -uNr qcacld-2.0/CORE/VOSS/src/vos_sched.h qcacld-2.0-new/CORE/VOSS/src/vos_sched.h
--- qcacld-2.0/CORE/VOSS/src/vos_sched.h	2015-10-20 10:18:50.000000000 +0800
+++ qcacld-2.0-new/CORE/VOSS/src/vos_sched.h	2015-10-28 19:36:45.000000000 +0800
@@ -149,6 +149,52 @@
 
 } *pVosTlshimPkt;
 #endif
+//airkiss feature
+typedef struct smartcfg{
+	unsigned long timeout;
+	int count;
+	bool ready;
+	bool done;
+
+	u16 found_base_len;
+	int old_preamble;
+	int preamble_seq_found;
+	int preamble_disorder;
+	int preamble_found_cnt;
+	int base_length;
+	
+	int prefix_data;
+	int old_prefix;
+	int prefix_seq_found;
+	u8 pswd_length;
+	u8 pswd_crc;
+	int found_prefix;
+
+	int old_magic;
+	int magic_seq_found;
+	int magic_disorder;
+	int magic_found_cnt;
+	int magic_data;
+	u8 total_length;
+	u8 ssid_crc;
+	int found_magic;
+	u8 max_seq_index;
+	unsigned long long seq_bitmap_pattern;
+
+	int data_seq;
+	u8 data_section[6];
+	u8 data_index;
+	u8 seq_crc;
+	u8 seq_index;
+	u8 ordered_data_section[6];
+	u8 data_seq_bitmap;
+	u8 seq_data[256];
+	u8 ssid_str[33];
+}*psmartcfg;
+struct channel_list{
+	u8 *list;
+	int length;
+};
 
 /*
 ** vOSS Scheduler context
@@ -208,6 +254,13 @@
 
    /* Handle of Event for Rx thread to signal startup */
    struct completion   RxStartEvent;
+   //airkiss feature
+   struct task_struct* SmartcfgThread;
+   struct completion   SmartStartEvent;
+   wait_queue_head_t SmartWaitQueue;
+   unsigned long     SmartEventFlag;
+   struct smartcfg *smartcfg_t;
+   struct channel_list channel_list_t;
 
    struct task_struct* McThread;
 
@@ -218,7 +271,6 @@
    /* RX Thread handle */
    struct task_struct*   RxThread;
 
-
    /* completion object for MC thread shutdown */
    struct completion   McShutdown;
 
diff -uNr qcacld-2.0/CORE/WDA/inc/legacy/halMsgApi.h qcacld-2.0-new/CORE/WDA/inc/legacy/halMsgApi.h
--- qcacld-2.0/CORE/WDA/inc/legacy/halMsgApi.h	2015-10-20 10:18:50.000000000 +0800
+++ qcacld-2.0-new/CORE/WDA/inc/legacy/halMsgApi.h	2015-10-28 19:37:08.000000000 +0800
@@ -38,6 +38,7 @@
 #define BSS_OPERATIONAL_MODE_AP     0
 #define BSS_OPERATIONAL_MODE_STA    1
 #define BSS_OPERATIONAL_MODE_IBSS   2
+#define BSS_OPERATIONAL_MODE_SNIFFER   3
 
 /* STA entry type in add sta message */
 #define STA_ENTRY_SELF              0
diff -uNr qcacld-2.0/Kbuild qcacld-2.0-new/Kbuild
--- qcacld-2.0/Kbuild	2015-10-20 10:18:50.000000000 +0800
+++ qcacld-2.0-new/Kbuild	2015-10-28 19:37:22.000000000 +0800
@@ -272,7 +272,8 @@
 		$(HDD_SRC_DIR)/wlan_hdd_trace.o \
 		$(HDD_SRC_DIR)/wlan_hdd_wext.o \
 		$(HDD_SRC_DIR)/wlan_hdd_wmm.o \
-		$(HDD_SRC_DIR)/wlan_hdd_wowl.o
+		$(HDD_SRC_DIR)/wlan_hdd_wowl.o \
+		$(HDD_SRC_DIR)/smart_cfg.o \
 
 ifeq ($(CONFIG_IPA_OFFLOAD), 1)
 HDD_OBJS +=	$(HDD_SRC_DIR)/wlan_hdd_ipa.o
