diff -Nuar qcacld-new.orig/CORE/SERVICES/BMI/ol_fw.c qcacld-new/CORE/SERVICES/BMI/ol_fw.c
--- qcacld-new.orig/CORE/SERVICES/BMI/ol_fw.c	2016-06-23 17:43:13.493177754 +0800
+++ qcacld-new/CORE/SERVICES/BMI/ol_fw.c	2016-07-07 04:09:25.380242049 +0800
@@ -1010,44 +1010,59 @@
 }
 
 #ifdef CONFIG_CRASH_DUMP_CLD
-#define DUMP_BUF_SIZE 20000 //backtrace + stack size is around 20K
-#define MAX_DUMP_FW_SIZE 100000
+#define DUMP_BUF_SIZE 1024*1024
 
 #define CRASH_DUMP_FILE "/opt/var/log/cld_fwcrash.log"
 
+static char* gRegStackBuf;
+static unsigned int gRegStackLen;
+static char* gRamBuf[FW_RAM_SEG_CNT];
+static unsigned int gRamLen[FW_RAM_SEG_CNT];
 
-int check_dump_file_size(void)
+static void writefile_work(struct work_struct *work)
 {
-	int status = 0, size = 0;
-	size = _readwrite_file(CRASH_DUMP_FILE, NULL, NULL, 0, O_RDONLY);
-	if (size > (MAX_DUMP_FW_SIZE - DUMP_BUF_SIZE)) {
-
-		printk(KERN_ERR "clean big log 0x%x\n", size);
-		status = _readwrite_file(CRASH_DUMP_FILE, NULL, NULL,
-			0, (O_WRONLY | O_TRUNC));
-	}
-
-	return status;
+    int status, i;
+    status = _readwrite_file(CRASH_DUMP_FILE, NULL, NULL,
+        0, (O_WRONLY | O_TRUNC));
+    if(gRegStackBuf) {
+        status = _readwrite_file(CRASH_DUMP_FILE, NULL,
+            gRegStackBuf, gRegStackLen, (O_RDWR|O_CREAT));
+        vos_mem_free(gRegStackBuf);
+        gRegStackBuf = NULL;
+        gRegStackLen = 0;
+        if (status < 0) {
+            printk(KERN_ERR "write failed with status code 0x%x\n", status);
+            return;
+        }
+    }
+    for(i = 0; i < FW_RAM_SEG_CNT; i++) {
+        if(gRamBuf[i]) {
+            printk("RAM dump string size = %d\n", gRamLen[i]);
+            status = _readwrite_file(CRASH_DUMP_FILE, NULL,
+                gRamBuf[i], gRamLen[i], (O_RDWR|O_APPEND));
+            vos_mem_free(gRamBuf[i]);
+            gRamBuf[i] = NULL;
+            gRamLen[i] = 0;
+            if (status < 0) {
+                printk(KERN_ERR "write failed with status code 0x%x\n", status);
+                return;
+            }
+        }
+    }
 }
 
-static int dump_fw_crash_to_file(struct ol_softc *scn)
+static DECLARE_WORK(ramdump_usb_work, writefile_work);
+
+static void dump_fw_crash_to_file(struct ol_softc *scn)
 {
 	A_UINT32 *reg, pattern, i, start_addr = 0;
 	A_UINT32 MSPId = 0, mSPId = 0, SIId = 0, CRMId = 0, len;
 	A_UINT8 *data;
-	A_UINT32 remaining;
-	char *buf;
-	unsigned int str_len = 0, buf_len = DUMP_BUF_SIZE;
-	int status = 0, dumpcomplete = 0;
-
-	buf = vos_mem_malloc(buf_len);
-
-	if (buf == NULL) {
-		printk(KERN_ERR "No buffer available for crash log\n");
-		return -ENOMEM;
-	}
-
-	memset(buf, 0, buf_len);
+    A_UINT8 temp_buf[36];
+	A_UINT8 *ram_ptr = NULL;
+	char *fw_ram_seg_name[FW_RAM_SEG_CNT] = {"DRAM", "IRAM", "AXI"};
+	unsigned int buf_len = DUMP_BUF_SIZE;
+	int j, dumpcomplete = 0;
 
 	data = scn->hif_sc->fw_data;
 	len = scn->hif_sc->fw_data_len;
@@ -1055,30 +1070,39 @@
 
 
 	if (pattern == FW_ASSERT_PATTERN) {
+        if(gRegStackBuf == NULL){
+            gRegStackBuf = vos_mem_malloc(buf_len);
+            if(gRegStackBuf == NULL) {
+                printk(KERN_ERR "No buffer available for crash log\n");
+                return;
+            }
+            memset(gRegStackBuf, 0, buf_len);
+        }
 		MSPId = (scn->target_fw_version & 0xf0000000) >> 28;
 		mSPId = (scn->target_fw_version & 0xf000000) >> 24;
 		SIId = (scn->target_fw_version & 0xf00000) >> 20;
 		CRMId = scn->target_fw_version & 0x7fff;
-		status = check_dump_file_size();
-		if (status)
-			printk(KERN_ERR "crash log file check status code 0x%x\n", status);
-		str_len = scnprintf(buf + str_len, buf_len - str_len, "Host SW version: %s\n", hdd_get_version_string());
-		str_len += scnprintf(buf + str_len, buf_len - str_len, "FW version: %d.%d.%d.%d\n", MSPId, mSPId, SIId, CRMId);
+		gRegStackLen = scnprintf(gRegStackBuf + gRegStackLen, buf_len - gRegStackLen, "Firmware crash detected...\n");
+		gRegStackLen += scnprintf(gRegStackBuf + gRegStackLen, buf_len - gRegStackLen, "Host SW version: %s\n", hdd_get_version_string());
+		gRegStackLen += scnprintf(gRegStackBuf + gRegStackLen, buf_len - gRegStackLen, "FW version: %d.%d.%d.%d\n", MSPId, mSPId, SIId, CRMId);
+		pr_err("Firmware crash detected...\n");
 		pr_err("Host SW version: %s\n", hdd_get_version_string());
 		pr_err("FW version: %d.%d.%d.%d", MSPId, mSPId, SIId, CRMId);
+
 		if (vos_is_load_unload_in_progress(VOS_MODULE_ID_VOSS, NULL)) {
 			printk(KERN_INFO "%s: Loading/Unloading is in progress, ignore!\n",
 				__func__);
-			vos_mem_free(buf);
-			return 0;
+			vos_mem_free(gRegStackBuf);
+            gRegStackBuf = NULL;
+			return;
 		}
 		reg = (A_UINT32 *) (data + 4);
 		for (i = 0; i < min_t(A_UINT32, len - 4, FW_REG_DUMP_CNT); i += 4) {
-			A_UINT8 temp_buf[128];
+            memset(temp_buf, 0, sizeof(temp_buf));
 			hex_dump_to_buffer(reg+i, 16, 16, 4, temp_buf, sizeof(temp_buf), false);
-			str_len += snprintf(buf + str_len, buf_len - str_len, "%#08x: %s\n", i*4, temp_buf);
+			gRegStackLen += scnprintf(gRegStackBuf + gRegStackLen, buf_len - gRegStackLen, "%#08x: %s\n", i*4, temp_buf);
 		}
-		print_hex_dump(KERN_DEBUG, " ", DUMP_PREFIX_OFFSET, 16, 4, reg,
+		print_hex_dump(KERN_CRIT, " ", DUMP_PREFIX_OFFSET, 16, 4, reg,
 				min_t(A_UINT32, len - 4, FW_REG_DUMP_CNT * 4),
 				false);
 		scn->fw_ram_dumping = 0;
@@ -1088,42 +1112,104 @@
 	}
 #ifdef CONFIG_CRASH_DUMP_STACK
 	else if (pattern == FW_REG_PATTERN) {
+        if(gRegStackBuf == NULL){
+            return;
+        }
 		reg = (A_UINT32 *) (data + 4);
 		start_addr = *reg++;
 		if (scn->fw_ram_dumping == 0) {
-			str_len += scnprintf(buf + str_len, buf_len - str_len, "Firmware stack dump:\n");
+			gRegStackLen += scnprintf(gRegStackBuf + gRegStackLen, buf_len - gRegStackLen, "Firmware stack dump:\n");
 			pr_err("Firmware stack dump:");
 			scn->fw_ram_dumping = 1;
 			fw_stack_addr = start_addr;
 		}
-		remaining = len - 8;
 		/* len is in byte, but it's printed in double-word. */
 		for (i = 0; i < (len - 8); i += 16) {
-			A_UINT8 temp_buf[128];
+            memset(temp_buf, 0, sizeof(temp_buf));
 			if ((*reg == FW_REG_END_PATTERN) && (i == len - 12)) {
 				scn->fw_ram_dumping = 0;
-				str_len += scnprintf(buf + str_len, buf_len - str_len, "Stack start address = %#08x\n",
+				gRegStackLen += scnprintf(gRegStackBuf + gRegStackLen, buf_len - gRegStackLen, "Stack start address = %#08x\n",
 					fw_stack_addr);
 				pr_err("Stack start address = %#08x\n",
 					fw_stack_addr);
-				dumpcomplete = 1;
-                          	pr_err("F/W crash log dump completed\n");
 				break;
-			}
-			hex_dump_to_buffer(reg, remaining, 16, 4, temp_buf,
+            }
+			hex_dump_to_buffer(reg, 16, 16, 4, temp_buf,
 						sizeof(temp_buf), false);
-			str_len += scnprintf(buf + str_len, buf_len - str_len, "%#08x: %s\n", start_addr + i, temp_buf);
+			gRegStackLen += scnprintf(gRegStackBuf + gRegStackLen, buf_len - gRegStackLen, "%#08x: %s\n", start_addr + i, temp_buf);
 			pr_err("%#08x: %s\n", start_addr + i, temp_buf);
-			remaining -= 16;
 			reg += 4;
 		}
 	}
-#endif
-	status = _readwrite_file(CRASH_DUMP_FILE, NULL,
-			buf, str_len, (O_WRONLY | O_APPEND | O_CREAT));
-	if (status < 0)
-		printk(KERN_ERR "write failed with status code 0x%x\n", status);
+	else if((pattern & FW_RAMDUMP_PATTERN_MASK) ==
+						FW_RAMDUMP_PATTERN) {
+		VOS_ASSERT(scn->ramdump_index < FW_RAM_SEG_CNT);
+		i = scn->ramdump_index;
+		reg = (A_UINT32 *) (data + 4);
+		if (scn->fw_ram_dumping == 0) {
+			scn->fw_ram_dumping = 1;
+            if(gRamBuf[i] == NULL) {
+                gRamBuf[i] = vos_mem_malloc(buf_len);
+                if(gRamBuf[i] == NULL) {
+                    printk(KERN_ERR "No buffer available for crash log\n");
+                    return;
+                }
+                memset(gRamBuf[i], 0, buf_len);
+            }
+            gRamLen[i] += scnprintf(gRamBuf[i] + gRamLen[i], buf_len - gRamLen[i], "Firmware %s dump:\n", fw_ram_seg_name[i]);
+			pr_err("Firmware %s dump:\n", fw_ram_seg_name[i]);
+			scn->ramdump[i] = vos_mem_malloc(sizeof(struct fw_ramdump) +
+							FW_RAMDUMP_SEG_SIZE);
+			if (!scn->ramdump[i]) {
+				pr_err("Fail to allocate memory for ram dump");
+				VOS_BUG(0);
+			}
+			(scn->ramdump[i])->mem =
+				(A_UINT8 *) (scn->ramdump[i] + 1);
+			fw_ram_seg_addr[i] = (scn->ramdump[i])->mem;
+            gRamLen[i] += scnprintf(gRamBuf[i] + gRamLen[i], buf_len - gRamLen[i],
+                    "FW %s start addr = %#08x\n",
+                    fw_ram_seg_name[i], *reg);
+            gRamLen[i] += scnprintf(gRamBuf[i] + gRamLen[i], buf_len - gRamLen[i], 
+                    "Memory addr for %s = %#08x\n",
+                    fw_ram_seg_name[i],
+                    (A_UINT32) (scn->ramdump[i])->mem);
+			pr_err("FW %s start addr = %#08x\n",
+				fw_ram_seg_name[i], *reg);
+			pr_err("Memory addr for %s = %#08x\n",
+				fw_ram_seg_name[i],
+				(A_UINT32) (scn->ramdump[i])->mem);
+			(scn->ramdump[i])->start_addr = *reg;
+			(scn->ramdump[i])->length = 0;
+		}
+		reg++;
+		ram_ptr = (scn->ramdump[i])->mem + (scn->ramdump[i])->length;
+		(scn->ramdump[i])->length += (len - 8);
+		memcpy(ram_ptr, (A_UINT8 *) reg, len - 8);
+
+		if (pattern == FW_RAMDUMP_END_PATTERN) {
+			pr_err("%s memory size = %d\n", fw_ram_seg_name[i],
+					(scn->ramdump[i])->length);
+		    for (j = 0; j < scn->ramdump[i]->length; j += 16) {
+                memset(temp_buf, 0, sizeof(temp_buf));
+			    hex_dump_to_buffer(scn->ramdump[i]->mem + j, 16, 16, 4, temp_buf, sizeof(temp_buf), false);
+			    gRamLen[i] += scnprintf(gRamBuf[i] + gRamLen[i], buf_len - gRamLen[i], "%#08x: %s\n", j, temp_buf);
+		    }
+		    print_hex_dump(KERN_DEBUG, " ", DUMP_PREFIX_OFFSET, 16, 4, scn->ramdump[i]->mem, scn->ramdump[i]->length, false);
+            vos_mem_free(scn->ramdump[i]);
+            scn->ramdump[i] = NULL;
+			if (i == (FW_RAM_SEG_CNT - 1)) {
+                if(gRamBuf[i])
+                    schedule_work(&ramdump_usb_work);
+                dumpcomplete = 1;
+                pr_err("F/W crash log dump completed\n");
+			}
 
+			scn->ramdump_index++;
+			scn->fw_ram_dumping = 0;
+		}
+	}
+#endif
 	if (dumpcomplete) {
 		if (vos_is_logp_in_progress(VOS_MODULE_ID_VOSS, NULL)) {
 				/* dispatch 'offline' uevent after FWDump */
@@ -1132,9 +1218,6 @@
 				vos_set_logp_in_progress(VOS_MODULE_ID_VOSS, FALSE);
 		}
 	}
-
-	vos_mem_free(buf);
-	return status;
 }
 #endif
 #endif
diff -Nuar qcacld-new.orig/CORE/VOSS/src/vos_memory.c qcacld-new/CORE/VOSS/src/vos_memory.c
--- qcacld-new.orig/CORE/VOSS/src/vos_memory.c	2016-06-16 11:38:46.822426305 +0800
+++ qcacld-new/CORE/VOSS/src/vos_memory.c	2016-06-16 15:10:17.734867313 +0800
@@ -97,7 +97,7 @@
 /* pre-alloced at load time
  * following three definition must fit
  * to avoid memory corruption */
-#define TOTOTAL_PRELOCATE (32*10 + 64*2 + 128*1 + 256*1)*1024
+#define TOTOTAL_PRELOCATE (32*10 + 64*2 + 128*1 + 256*1 + 385*1 + 1024*4)*1024
 static struct vos_prealloc vos_allocs[] = {
 	{0, 32 * 1024, NULL},
 	{0, 32 * 1024, NULL},
@@ -113,6 +113,11 @@
 	{0, 64 * 1024, NULL},
 	{0, 128 * 1024, NULL},
 	{0, 256 * 1024, NULL},
+	{0, 385 * 1024, NULL},
+	{0, 1024 * 1024, NULL},
+	{0, 1024 * 1024, NULL},
+	{0, 1024 * 1024, NULL},
+	{0, 1024 * 1024, NULL},
 };
 
 v_BYTE_t pre_alloc_pool[TOTOTAL_PRELOCATE];
@@ -138,7 +143,6 @@
 {
 	v_UINT_t i;
 	v_UINT_t alloc_pos = 0;
-
 	for (i = 0; i < ARRAY_SIZE(vos_allocs); i++) {
 		vos_allocs[i].occupied = 0;
 		vos_allocs[i].ptr = &pre_alloc_pool[alloc_pos];
@@ -155,21 +159,31 @@
 	for (i = 0; i < ARRAY_SIZE(vos_allocs); i++)
 		vos_allocs[i].occupied = 0;
 }
+v_VOID_t vos_trace_prealloc_occupied(v_VOID_t)
+{
+    int i;
+    printk("Memory allocs occupied:");
+	for (i = 0; i < ARRAY_SIZE(vos_allocs); i++) {
+        printk(" %d", vos_allocs[i].occupied);
+    }
+    printk("\n");
+}
 v_VOID_t *vos_prealloc_get(v_UINT_t size)
 {
 	v_UINT_t i = 0;
 
 	if (WLAN_IS_EPPING_ENABLED(vos_get_conparam()))
 		return NULL;
-
+    vos_trace_prealloc_occupied();
 	mutex_lock(&alloc_lock);
 	for (i = 0; i < ARRAY_SIZE(vos_allocs); i++) {
 		if (vos_allocs[i].occupied)
 			continue;
-		if (vos_allocs[i].size > size) {
+		if (vos_allocs[i].size >= size) {
 			/* we found the slot */
 			vos_allocs[i].occupied = 1;
 			mutex_unlock(&alloc_lock);
+            vos_trace_prealloc_occupied();
 			return vos_allocs[i].ptr;
 		}
 	}
