diff -urN qcacld-new.orig/CORE/CLD_TXRX/TLSHIM/tl_shim.c qcacld-new/CORE/CLD_TXRX/TLSHIM/tl_shim.c
--- qcacld-new.orig/CORE/CLD_TXRX/TLSHIM/tl_shim.c	2016-05-16 10:58:08.850298648 +0800
+++ qcacld-new/CORE/CLD_TXRX/TLSHIM/tl_shim.c	2016-05-16 10:58:19.042298648 +0800
@@ -1152,6 +1152,9 @@
 #endif /* QCA_LL_TX_FLOW_CT */
 }
 
+#ifdef CONFIG_CONTX_USB_DEBUG
+extern int txkeeprun;
+#endif
 
 /*
  * TL API to transmit a frame given by HDD. Returns NULL
@@ -1193,10 +1196,19 @@
 		return skb;
 	}
 
+#ifdef CONFIG_CONTX_USB_DEBUG
+	if (!txkeeprun) {
+		if (!tl_shim->sta_info[sta_id].registered) {
+			TLSHIM_LOGW("Staion is not yet registered for data service");
+			return skb;
+		}
+	}
+#else
 	if (!tl_shim->sta_info[sta_id].registered) {
 		TLSHIM_LOGW("Staion is not yet registered for data service");
 		return skb;
 	}
+#endif
 
 	peer = ol_txrx_peer_find_by_local_id(
 			((pVosContextType) vos_ctx)->pdev_txrx_ctx,
diff -urN qcacld-new.orig/CORE/CLD_TXRX/TXRX/ol_tx_queue.c qcacld-new/CORE/CLD_TXRX/TXRX/ol_tx_queue.c
--- qcacld-new.orig/CORE/CLD_TXRX/TXRX/ol_tx_queue.c	2016-05-16 10:58:08.858298648 +0800
+++ qcacld-new/CORE/CLD_TXRX/TXRX/ol_tx_queue.c	2016-05-16 10:58:19.042298648 +0800
@@ -213,6 +213,10 @@
     }
 }
 
+#if defined(CONFIG_CONTX_USB_DEBUG) && defined(DIRECT_AUDIO_SUPPORT)
+extern int txkeeprun;
+extern int txkeepruntoofastseriously;
+#endif
 
 void
 ol_tx_enqueue(
@@ -236,6 +240,16 @@
      */
 #if defined(CONFIG_PER_VDEV_TX_DESC_POOL)
     vdev = tx_desc->vdev;
+#if defined(CONFIG_CONTX_USB_DEBUG) && defined(DIRECT_AUDIO_SUPPORT)
+    if (txkeeprun &&
+		(adf_os_atomic_read(&vdev->tx_desc_count) >
+          ((ol_tx_desc_pool_size_hl(pdev->ctrl_pdev) >> 1)
+		- TXRX_HL_TX_FLOW_CTRL_MGMT_RESERVED)
+		- OL_TX_DESC_POOL_SIZE_MIN_HL/2)){
+			txkeepruntoofastseriously = 1;
+			//pr_err("contx too at ol, slow down\n");
+    }
+#endif
     if (adf_os_atomic_read(&vdev->tx_desc_count) >
           ((ol_tx_desc_pool_size_hl(pdev->ctrl_pdev) >> 1)
            - TXRX_HL_TX_FLOW_CTRL_MGMT_RESERVED)) {
diff -urN qcacld-new.orig/CORE/CLD_TXRX/TXRX/ol_tx_sched.c qcacld-new/CORE/CLD_TXRX/TXRX/ol_tx_sched.c
--- qcacld-new.orig/CORE/CLD_TXRX/TXRX/ol_tx_sched.c	2016-05-16 10:58:08.870298648 +0800
+++ qcacld-new/CORE/CLD_TXRX/TXRX/ol_tx_sched.c	2016-05-16 10:58:19.042298648 +0800
@@ -749,6 +749,10 @@
  * so there is no need to worry about mutex within this function.
  */
 
+#ifdef CONFIG_CONTX_USB_DEBUG
+extern int txkeeprun;
+extern int txkeepruntoofast;
+#endif
 
 static int
 ol_tx_sched_select_batch_wrr_adv(
@@ -811,6 +815,11 @@
          * service this category after all).
          */
         category->state.wrr_count = category->state.wrr_count - 1;
+#ifdef CONFIG_CONTX_USB_DEBUG
+        if (txkeeprun && category->state.frms > 500) {
+                txkeepruntoofast = 1;
+        }
+#endif
         return 0;
     }
     /* enough credit is available - go ahead and send some frames */
@@ -875,7 +884,12 @@
     } else {
         used_credits = 0;
 		/* TODO: find its reason */
+#ifdef CONFIG_CONTX_USB_DEBUG
+        if (!txkeeprun)
+            TX_SCHED_DEBUG_PRINT("ol_tx_sched_select_batch_wrr_adv: error, no TXQ can be popped.");
+#else
         adf_os_print("ol_tx_sched_select_batch_wrr_adv: error, no TXQ can be popped.");
+#endif
     }
     OL_TX_SCHED_WRR_ADV_CAT_STAT_DUMP(scheduler);
     return used_credits;
diff -urN qcacld-new.orig/CORE/HDD/inc/wlan_hdd_direct_audio.h qcacld-new/CORE/HDD/inc/wlan_hdd_direct_audio.h
--- qcacld-new.orig/CORE/HDD/inc/wlan_hdd_direct_audio.h	1970-01-01 08:00:00.000000000 +0800
+++ qcacld-new/CORE/HDD/inc/wlan_hdd_direct_audio.h	2016-05-16 10:58:19.010298648 +0800
@@ -0,0 +1,162 @@
+/*Gerbera - WiFi*/
+#ifdef DIRECT_AUDIO_SUPPORT
+#ifndef SDA_H
+#define SDA_H
+
+/* direct audio prototype */
+
+typedef struct SDA_Descriptor
+{
+	unsigned char m_ReadyToCopy;
+	unsigned int m_PayloadSize;
+	unsigned int m_TimeStamp;
+}__attribute__((packed)) SDA_Descriptor_t;
+
+
+typedef struct SDA_HeadRoom
+{
+	unsigned char m_DestAddress[6];
+	unsigned char m_SourceAddress[6];
+	unsigned short m_PacketType;
+}__attribute__((packed)) SDA_HeadRoom_t;
+
+
+typedef struct
+{
+	SDA_Descriptor_t   m_Descriptor;
+	unsigned char m_Dummy[50 - sizeof(struct SDA_HeadRoom)];
+	SDA_HeadRoom_t  m_Headroom;
+}__attribute__((packed)) SDA_Header_t;
+
+
+
+/**
+ * @brief Retrieve the time stamp value from the p2p0 or wlan0 interface
+ * @remarks
+ * @param vif_id : get time stamp from wlan0/p2p0(0/1)interface
+ * @return time stamp value (64bits)
+ * @see
+ */
+unsigned long long SDA_getTsf (unsigned char vif_id);
+
+
+
+
+/**
+ * @brief Synchronize p2p0s time stamp value with wlan0s
+ * @remarks
+ * @param none
+ * @return 0 : success, - 1 : fail
+ * @see
+ */
+int SDA_syncTsf (void);
+
+
+
+/**
+ * @brief tsf wifi module
+ * @remarks
+ * @param pTsf : tsf
+ * @return none
+ * @see
+ */
+void SDA_GetTSF(unsigned int *pTsf);
+
+
+
+
+/**
+ * @brief send the buffer info to wifi module for tx.
+ * @remarks
+ * @param BufferId is the mazimum 5.
+ * @param pBufferTotal : buffer address
+ * @param BufferTotalSize : buffer size
+ * @param BufferUnitSize : each unit size (descriptor + headroom + audio data size)
+ * @param HeadroomSize : head room size
+ * @return none
+ * @see
+ */
+void SDA_setSharedMemory4Send(unsigned int BufferId, unsigned char *pBufferTotal, unsigned int BufferTotalSize, unsigned int BufferUnitSize, unsigned int HeadroomSize);
+
+
+
+
+
+/**
+ * @brief send the buffer info to wifi module for rx.
+ * @remarks
+ * @param pBufferTotal : buffer address
+ * @param BufferTotalSize : buffer size
+ * @param BufferUnitSize : each unit size (descriptor + headroom + audio data size)
+ * @param HeadroomSize : head room size
+ * @return none
+ * @see
+ */
+void SDA_setSharedMemory4Recv(unsigned char *pBufferTotal, unsigned int BufferTotalSize, unsigned int BufferUnitSize, unsigned int HeadroomSize);
+
+
+
+
+
+
+/*
+ * @send the brief data data to wifi module (dsp --> wifi module)
+ * @remarks
+ * @param on BufferId direct audio system, the maximum of audio input buffer is 5. bufferÀÇ idÀÓ.
+ * @param pBuffer : buffer address
+ * @param BufferSize : buffer size
+ * @return none
+ * @see
+ */
+void SDA_function4Send(unsigned int BufferId, unsigned char *pBuffer, unsigned int BufferSize);
+
+
+
+
+/**
+ * @brief after sending data on wifi module, call the callback(ack) (wifi module --> dsp)
+ * @remarks
+ * @param on BufferId direct audio system, the maximum of audio input buffer is 5.
+ * @param pBuffer : buffer address
+ * @param BufferSize : buffer size
+ * @return none
+ * @see
+ */
+typedef void (*SDA_SendDoneCallBack)(unsigned int BufferId, unsigned char *pBuffer, unsigned int BufferSize);
+
+void SDA_registerCallback4SendDone(SDA_SendDoneCallBack pCallback);
+
+
+
+
+
+
+
+/**
+ * @brief on wifi module, send the receiving data to soc (wifi module --> dsp)
+ * @remarks
+ * @param pBuffer : buffer address
+ * @param BufferSize : buffer size
+ * @return none
+ * @see
+ */
+typedef void (*SDA_RecvCallBack)(unsigned char *pBuffer, unsigned int BufferSize);
+
+void SDA_registerCallback4Recv(SDA_RecvCallBack pCallback);
+
+
+
+
+
+/**
+ * @brief after finishing to received data on soc, notifying to wifi module(ack)
+ * @remarks
+ * @param pBuffer : buffer address
+ * @param BufferSize : buffer size
+ * @return none
+ * @see
+ */
+void SDA_function4RecvDone(unsigned char *pBuffer, unsigned int BufferSize);
+
+#endif // SDA_H
+#endif //DIRECT_AUDIO_SUPPORT
diff -urN qcacld-new.orig/CORE/HDD/inc/wlan_hdd_main.h qcacld-new/CORE/HDD/inc/wlan_hdd_main.h
--- qcacld-new.orig/CORE/HDD/inc/wlan_hdd_main.h	2016-05-16 10:58:08.694298648 +0800
+++ qcacld-new/CORE/HDD/inc/wlan_hdd_main.h	2016-05-16 10:58:19.010298648 +0800
@@ -624,6 +624,9 @@
   vos_timer_t hdd_remain_on_chan_timer;
   action_pkt_buffer_t action_pkt_buff;
   v_BOOL_t hdd_remain_on_chan_cancel_in_progress;
+#ifdef CONFIG_CUST_PLATFORM
+  hdd_adapter_t *pAdapter;
+#endif
 }hdd_remain_on_chan_ctx_t;
 
 /* RoC Request entry */
@@ -1140,6 +1143,9 @@
     struct delayed_work roc_work;
 
 #ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+#ifdef CONFIG_CUST_PLATFORM
+    struct work_struct ext_wow_work;
+#endif
 #endif
 };
 
@@ -1256,6 +1262,10 @@
     v_U8_t dl_loglevel;
     v_U8_t index;
     v_U32_t dl_mod_loglevel[MAX_MOD_LOGLEVEL];
+#ifdef CONFIG_WLAN_FWLOG_FILE
+    v_U8_t dl_fwlog_file;
+    v_U32_t dl_fwlog_file_max_size;
+#endif
 }fw_log_info;
 
 /** Adapter stucture definition */
@@ -1542,9 +1552,18 @@
 
 #ifdef WLAN_FEATURE_EXTWOW_SUPPORT
     v_BOOL_t is_extwow_app_type1_param_set;
+#ifdef WLAN_FEATURE_EXTWOW_OUTDOOR_SUPPORT
+    v_BOOL_t is_extwow_app_type2_param_set;
+#endif
     v_BOOL_t ext_wow_should_suspend;
     struct completion ready_to_extwow;
     tSirAppType1Params app_type1_params;
+#ifdef WLAN_FEATURE_EXTWOW_OUTDOOR_SUPPORT
+    tSirAppType2Params app_type2_params;
+#endif
+#ifdef CONFIG_CUST_PLATFORM
+    v_BOOL_t ext_wow_enable;
+#endif
    struct mutex ext_wow_lock;
 #endif
 
@@ -1767,6 +1786,9 @@
 char *hdd_get_version_string( void );
 
 #ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+#ifdef CONFIG_CUST_PLATFORM
+int wlan_hdd_enable_swol(hdd_adapter_t *pAdapter, boolean enable);
+#endif
 #endif
 
 #endif    // end #if !defined( WLAN_HDD_MAIN_H )
diff -urN qcacld-new.orig/CORE/HDD/src/wlan_hdd_assoc.c qcacld-new/CORE/HDD/src/wlan_hdd_assoc.c
--- qcacld-new.orig/CORE/HDD/src/wlan_hdd_assoc.c	2016-05-16 10:58:08.710298648 +0800
+++ qcacld-new/CORE/HDD/src/wlan_hdd_assoc.c	2016-05-16 10:58:19.010298648 +0800
@@ -988,6 +988,12 @@
                 cfg80211_disconnected(dev, WLAN_REASON_UNSPECIFIED, NULL, 0, GFP_KERNEL);
             }
 #ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+#ifdef CONFIG_CUST_PLATFORM
+            if (pAdapter->device_mode == WLAN_HDD_INFRA_STATION)
+            {
+                wlan_hdd_enable_swol(pAdapter, FALSE);
+            }
+#endif
 #endif
 
             //If the Device Mode is Station
@@ -1607,6 +1613,12 @@
                                             WLAN_STATUS_SUCCESS,
                                             GFP_KERNEL);
 #ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+#ifdef CONFIG_CUST_PLATFORM
+                    if (pAdapter->device_mode == WLAN_HDD_INFRA_STATION)
+                    {
+                        wlan_hdd_enable_swol(pAdapter, TRUE);
+                    }
+#endif
 #endif
                 }
             }
@@ -1642,6 +1654,12 @@
                             WLAN_STATUS_SUCCESS,
                             GFP_KERNEL);
 #ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+#ifdef CONFIG_CUST_PLATFORM
+                    if (pAdapter->device_mode == WLAN_HDD_INFRA_STATION)
+                    {
+                        wlan_hdd_enable_swol(pAdapter, TRUE);
+                    }
+#endif
 #endif
                 }
             }
diff -urN qcacld-new.orig/CORE/HDD/src/wlan_hdd_cfg.c qcacld-new/CORE/HDD/src/wlan_hdd_cfg.c
--- qcacld-new.orig/CORE/HDD/src/wlan_hdd_cfg.c	2016-05-16 10:58:08.726298648 +0800
+++ qcacld-new/CORE/HDD/src/wlan_hdd_cfg.c	2016-05-16 10:58:19.010298648 +0800
@@ -4808,6 +4808,10 @@
 
    memset(macTable, 0, sizeof(macTable));
 
+#ifdef CONFIG_CUST_PLATFORM
+//There is no such file existing in CUST_PLATFORM, return directly to save time
+   return VOS_STATUS_E_FAILURE;
+#endif
 
    status = request_firmware(&fw, WLAN_MAC_FILE, pHddCtx->parent_dev);
 
diff -urN qcacld-new.orig/CORE/HDD/src/wlan_hdd_direct_audio.c qcacld-new/CORE/HDD/src/wlan_hdd_direct_audio.c
--- qcacld-new.orig/CORE/HDD/src/wlan_hdd_direct_audio.c	1970-01-01 08:00:00.000000000 +0800
+++ qcacld-new/CORE/HDD/src/wlan_hdd_direct_audio.c	2016-05-16 10:58:19.010298648 +0800
@@ -0,0 +1,770 @@
+/*Gerbera - WiFi*/
+#include <wlan_hdd_includes.h>
+#include <vos_api.h>
+#include <vos_sched.h>
+#include <linux/etherdevice.h>
+#include <linux/firmware.h>
+#include <wcnss_api.h>
+#include <wlan_hdd_tx_rx.h>
+#include <wlan_hdd_softap_tx_rx.h>
+#include <palTimer.h>
+#include <wniApi.h>
+#include <wlan_nlink_srv.h>
+#include <wlan_btc_svc.h>
+#include <wlan_hdd_cfg.h>
+#include <wlan_ptt_sock_svc.h>
+#include <dbglog_host.h>
+#include <wlan_logging_sock_svc.h>
+#include <wlan_hdd_wowl.h>
+#include <wlan_hdd_misc.h>
+#include <wlan_hdd_wext.h>
+#include "wlan_hdd_trace.h"
+#include "vos_types.h"
+#include "vos_trace.h"
+#include <net/addrconf.h>
+#include <linux/wireless.h>
+#include <net/cfg80211.h>
+#include <linux/inetdevice.h>
+#include <net/addrconf.h>
+#include <wlan_hdd_direct_audio.h>
+#include "ol_if_athvar.h"
+#include "hif.h"
+#if defined(HIF_PCI)
+#include "if_pci.h"
+#elif defined(HIF_USB)
+#include "if_usb.h"
+#elif defined(HIF_SDIO)
+#include "if_ath_sdio.h"
+#endif
+
+
+#ifdef DIRECT_AUDIO_SUPPORT
+#define SDA_DEBUG	1
+#define TSFDATASIZE	4
+
+#define DIRECT_AUDIO_LLC_TYPE 0x43FF
+#if SDA_DEBUG
+#define MAX_BUF_SIZE 1500 // bytes
+#define MAX_SHARE_MEM_ITEM	32
+#endif
+#define MAX_TX_POOL_ID 5
+
+struct Direct_Audio_Context {
+	u32		last_tx_process_time;
+	u32		max_tx_process_time;
+	u32		last_rx_process_time;
+	u32		max_rx_process_time;
+	hdd_context_t *pHddCtx;
+	u8		vif_id;
+};
+
+static struct Direct_Audio_Context	DA_context;
+SDA_SendDoneCallBack SDA_TX_DONE_CB = NULL;
+SDA_RecvCallBack SDA_RX_READY_CB = NULL;
+
+struct Direct_Audio_Setting_str {
+    u8  *pAddr;
+	u32 sizeTotal;
+	u32 lenUnit;
+	u32 lenHeadroom;
+	u8  *current_pAddr;
+}__packed;
+
+static struct Direct_Audio_Setting_str global_TX_DA_Setting[MAX_TX_POOL_ID];
+static struct Direct_Audio_Setting_str global_RX_DA_Setting;
+
+#define TX_DA_INIT_ADDR(id)   global_TX_DA_Setting[id].pAddr
+#define TX_DA_ADDR(id)        global_TX_DA_Setting[id].current_pAddr
+#define TX_DA_POOL_SIZE(id)   global_TX_DA_Setting[id].sizeTotal
+#define TX_DA_UNIT_LEN(id)    global_TX_DA_Setting[id].lenUnit
+#define TX_DA_HEAD_ROOM(id)   global_TX_DA_Setting[id].lenHeadroom
+
+static void Direct_Audio_Tx_Setting(u32 BufferId,
+                                    u8 *pAddr,
+                                    u32 sizeTotal,
+                                    u16 lenUnit,
+                                    u16 lenHeadroom)
+{
+	if(BufferId >= MAX_TX_POOL_ID)
+	{
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+			"%s: BufferId %d excess MAX_TX_POOL_ID %d\n",
+                          __func__,
+                          BufferId,
+                          MAX_TX_POOL_ID);
+		return;
+	}
+	TX_DA_INIT_ADDR(BufferId) = pAddr;
+	TX_DA_ADDR(BufferId) = pAddr;
+	TX_DA_POOL_SIZE(BufferId) = sizeTotal;
+	TX_DA_UNIT_LEN(BufferId) = lenUnit;
+	TX_DA_HEAD_ROOM(BufferId) = lenHeadroom;
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+		"%s[%d]BufferId=%d,pAddr=0%p,sizeTotal=%d,lenUnit=%d,lenHeadroom=%d\r\n",
+	        __func__, __LINE__, BufferId, pAddr, sizeTotal, lenUnit, lenHeadroom);
+}
+
+#define RX_DA_INIT_ADDR   global_RX_DA_Setting.pAddr
+#define RX_DA_ADDR        global_RX_DA_Setting.current_pAddr
+#define RX_DA_POOL_SIZE   global_RX_DA_Setting.sizeTotal
+#define RX_DA_UNIT_LEN    global_RX_DA_Setting.lenUnit
+#define RX_DA_HEAD_ROOM   global_RX_DA_Setting.lenHeadroom
+
+static void Direct_Audio_Rx_Setting(u8 *pAddr, u32 sizeTotal, u32 lenUnit, u32 lenHeadroom)
+{
+	RX_DA_INIT_ADDR = pAddr;
+	RX_DA_ADDR = pAddr;
+	RX_DA_POOL_SIZE = sizeTotal;
+	RX_DA_UNIT_LEN = lenUnit;
+	RX_DA_HEAD_ROOM = lenHeadroom;
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+		"%s[%d] pAddr=0%p,sizeTotal=%d,lenUnit=%d,lenHeadroom=%d\r\n",
+	    __func__, __LINE__, pAddr, sizeTotal, lenUnit, lenHeadroom);
+}
+
+//SDA_SendDoneCallBack  SDA_TX_DONE_CB = NULL;
+#define SDA_BUF_READY(_desc)      	!!_desc->m_ReadyToCopy
+#define TX_SDA_INIT_ADDR			orig_data_p
+#define TX_SDA_ADDR 				descp_p
+#define TX_SDA_POOL_SIZE			BufferSize
+#define TX_SDA_UNIT_LEN(id)				TX_DA_UNIT_LEN(id)
+#define CLR_SDA_BUF_READY(_desc)  	_desc->m_ReadyToCopy = 0
+#define SET_SDA_BUF_READY(_desc)  	_desc->m_ReadyToCopy = 1
+static void SDA_Tx_fun( struct net_device *dev, u32 BufferId, u8 *pBuffer, u32 BufferSize)
+{
+	u8 *orig_data_p = pBuffer;
+	u8 *data_p = pBuffer;
+	u8 *descp_p = pBuffer;
+	struct SDA_Descriptor *tx_desc = (struct SDA_Descriptor *) data_p;
+	hdd_adapter_t * vif;
+	int status = 0;
+	vif = hdd_get_adapter_by_vdev(DA_context.pHddCtx, DA_context.vif_id);
+	if(!vif)
+		return;
+
+	if(BufferId >= MAX_TX_POOL_ID)
+	{
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_WARN,
+			"%s: BufferId excess %d\n", __func__, MAX_TX_POOL_ID);
+		goto tx_fail;
+	}
+	if (!data_p || !SDA_BUF_READY(tx_desc)) {
+		//Should not into here
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_WARN,
+			"%s: descriptor show not ready\n", __func__);
+		goto tx_fail;
+	}
+	/*Check descriptor*/
+	do {
+		struct sk_buff *skb;
+		int send_len = 0;
+		struct ethhdr *eth_hdr;
+		int alloc_size = 0;
+
+		/* point to RAW_Data
+		* Assume offset include Descriptor & Headroom
+		*/
+		data_p += sizeof(SDA_Header_t);
+		/*Create skb, copy data, fill skb header*/
+		alloc_size = tx_desc->m_PayloadSize+sizeof(struct ethhdr);
+		skb = adf_nbuf_alloc(NULL, alloc_size, 0, sizeof(u_int32_t), 0);
+		if (skb == NULL) {
+			//should not happened
+			VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+				"%s: Allocate skb failed\n", __func__);
+			break;
+		}
+
+		skb_put(skb, alloc_size);
+		memset(skb->data, 0, alloc_size);
+		//Copy data from share buf to skb
+		memcpy(skb->data, data_p-sizeof(struct ethhdr),
+                       tx_desc->m_PayloadSize+sizeof(struct ethhdr));
+		send_len += tx_desc->m_PayloadSize+sizeof(struct ethhdr);
+
+		eth_hdr = (struct ethhdr *)(skb->data);
+
+		//copy mac address as source address
+		memcpy(eth_hdr->h_source,vif->dev->dev_addr,6);
+#if 0 //dest mac is filled by upper layer like virutal sound card
+		if (vif->device_mode == WLAN_HDD_INFRA_STATION || vif->device_mode == WLAN_HDD_P2P_CLIENT)
+		{
+			hdd_station_ctx_t *pHddStaCtx = WLAN_HDD_GET_STATION_CTX_PTR(vif);
+			memcpy(eth_hdr->h_dest, pHddStaCtx->conn_info.bssId, 6);
+		}
+		else
+		{
+			u8 broadcastpeer[6] = {0xff,0xff,0xff,0xff,0xff,0xff};
+			memcpy(eth_hdr->h_dest, broadcastpeer, 6);
+		}
+#endif
+		skb->protocol = ntohs(eth_hdr->h_proto);
+		skb->dev = dev;
+		skb->priority = SME_QOS_WMM_UP_VI;
+		skb->queue_mapping = hddLinuxUpToAcMap[skb->priority];
+
+		/*Adjust the length of data before send*/
+		skb_trim(skb, send_len);
+		//Call normal tx path
+		if (vif->device_mode == WLAN_HDD_INFRA_STATION ||
+                    vif->device_mode == WLAN_HDD_P2P_CLIENT)
+			status = hdd_hard_start_xmit(skb, dev);
+		else if (vif->device_mode == WLAN_HDD_SOFTAP ||
+                         vif->device_mode == WLAN_HDD_P2P_GO)
+			status = hdd_softap_hard_start_xmit(skb, dev);
+		else
+			status = hdd_softap_hard_start_xmit(skb, dev);
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_LOW,
+			"%s[%d]BufferId=%d,audio len = %d,status = %d by %d\n",
+		        __func__, __LINE__, BufferId,
+                          tx_desc->m_PayloadSize,
+                          status,
+                          (vif->device_mode));
+		//Clear share buffer Ready flag
+		CLR_SDA_BUF_READY(tx_desc);
+		//To-do: call SS complete routine
+
+		//Next frame & check if need retrun pAddr of DA Share buff
+		if(((TX_SDA_ADDR - TX_SDA_INIT_ADDR)+TX_SDA_UNIT_LEN(BufferId)) >= TX_SDA_POOL_SIZE)
+                {
+			/*Return to Init buf addr*/
+			TX_SDA_ADDR = TX_SDA_INIT_ADDR;
+		} else {
+			/*Go to Next buf*/
+			TX_SDA_ADDR += TX_SDA_UNIT_LEN(BufferId);
+		}
+		data_p = TX_SDA_ADDR;
+		tx_desc = (struct SDA_Descriptor *) data_p;
+	} while(SDA_BUF_READY(tx_desc));//Check if having next
+tx_fail:
+	if (SDA_TX_DONE_CB)
+		SDA_TX_DONE_CB(BufferId,pBuffer,BufferSize);
+}
+
+/*Assume The RX Already to be Packet Mode*/
+void SDA_Rx_fun( struct net_device *dev, struct sk_buff *skb)
+{
+#if (!defined FILE_DEBUG) && (!defined UDPDBG) //call real DA engine
+    u32 tsf_ie=0, tsf_data=0;
+    u8 *data_p = RX_DA_ADDR;
+    struct SDA_Descriptor *rx_desc = (struct SDA_Descriptor *) data_p;
+
+    if (skb == NULL) {
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
+			"%s: input buf should not be NULL\n", __func__);
+		return;
+	}
+#define TSF_IE 0x1234fedc
+	tsf_ie = le32_to_cpu(*((u32 *)(skb->data + skb->len - 2*sizeof(u32))));
+	if (tsf_ie == TSF_IE) {
+		skb_trim(skb, (skb->len - 2*sizeof(u32)));
+
+		tsf_data = le32_to_cpu(*((u32 *)(skb->data + skb->len + sizeof(u32))));
+		//printk("~~current-tsf (%x) \n",tsf_data);
+	}
+
+	if (!data_p) {
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+			"%s: DSP dose not register rx pool\n", __func__);
+		dev_kfree_skb(skb);
+		return;
+	}
+
+	if(SDA_BUF_READY(rx_desc)) {
+	   //the share buf not available. DO NOT PUT PRINT LOG HERE.
+	   goto rx_fail;
+	}
+
+	//Fill derscriptort
+	rx_desc->m_PayloadSize = skb->len;//no ethernet header included and remove TSF_IE
+	rx_desc->m_TimeStamp = 0 ;
+
+	if (skb->len > (RX_DA_UNIT_LEN-sizeof(struct SDA_Descriptor)-RX_DA_HEAD_ROOM)) {
+	    //Should not happen
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+			"%s: Not having enough room for RX DATA\n", __func__);
+		skb->len = RX_DA_UNIT_LEN-sizeof(struct SDA_Descriptor)-RX_DA_HEAD_ROOM;
+	}
+	//copy to share buf & Skip the length of "struct ethhdr"
+	memcpy((data_p + sizeof(struct SDA_Descriptor) + RX_DA_HEAD_ROOM) - sizeof(struct ethhdr),
+		skb->data -sizeof(struct ethhdr),
+		skb->len + sizeof(struct ethhdr));
+
+	// Set rx timestamp
+	memcpy(data_p + sizeof(struct SDA_Descriptor) + RX_DA_HEAD_ROOM +sizeof(u32),
+			&tsf_data, sizeof(u32));
+
+	//To-do: :Call SS Direct Audio RX routine
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+		"%s[%d]audio len=%d\n\r",__func__,__LINE__,rx_desc->m_PayloadSize);
+
+	SET_SDA_BUF_READY(rx_desc);
+	if (SDA_RX_READY_CB)
+		SDA_RX_READY_CB((u8*)rx_desc,RX_DA_UNIT_LEN);
+
+	//Next DA Share buff
+	if(((RX_DA_ADDR - RX_DA_INIT_ADDR)+RX_DA_UNIT_LEN) >= RX_DA_POOL_SIZE ) {
+	    /*Return to Init buf addr*/
+	    RX_DA_ADDR = RX_DA_INIT_ADDR;
+	} else {
+	    /*Go to Next buf*/
+	    RX_DA_ADDR += RX_DA_UNIT_LEN;
+	}
+rx_fail:
+	dev_kfree_skb(skb);
+#endif
+}
+
+#ifdef CONFIG_CONTX_USB_DEBUG
+extern struct timer_list da_timer;
+extern int txkeeprun;
+#endif /* CONFIG_CONTX_USB_DEBUG */
+
+void SDA_function4Send(unsigned int BufferId, unsigned char *pBuffer, unsigned int BufferSize)
+{
+	hdd_adapter_t * vif;
+	hdd_station_ctx_t *pHddStaCtx;
+	hdd_ap_ctx_t *pAPCtx;
+
+	u32	entry_time;
+	if (DA_context.pHddCtx == NULL) {
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_WARN,
+			"%s: DA_context.ar should not be NULL\n", __func__);
+		return;
+	}
+
+	vif = hdd_get_adapter_by_vdev(DA_context.pHddCtx, DA_context.vif_id);
+	if (!vif) {
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_WARN,
+			"%s: Failed to find vif for DA, DA_context.ar=%p, DA_context.vif_id=%d\n"
+			, __func__,
+			DA_context.pHddCtx,
+			DA_context.vif_id);
+		return;
+	}
+	if (vif->device_mode == WLAN_HDD_INFRA_STATION || vif->device_mode == WLAN_HDD_P2P_CLIENT) {
+		pHddStaCtx = WLAN_HDD_GET_STATION_CTX_PTR(vif);
+#ifdef CONFIG_CONTX_USB_DEBUG
+		if (!pHddStaCtx || (!hdd_connIsConnected(pHddStaCtx) && !txkeeprun)) {
+			VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+				"%s: STA %p is not connected\n", __func__, pHddStaCtx);
+			return;
+		}
+#else
+		if (!pHddStaCtx || !hdd_connIsConnected(pHddStaCtx)) {
+			VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+				"%s: STA %p is not connected\n", __func__, pHddStaCtx);
+			return;
+		}
+#endif
+	}
+	if (vif->device_mode == WLAN_HDD_SOFTAP || vif->device_mode == WLAN_HDD_P2P_GO) {
+		pAPCtx = WLAN_HDD_GET_AP_CTX_PTR(vif);
+	}
+	entry_time = jiffies;
+	SDA_Tx_fun(vif->dev,BufferId,pBuffer,BufferSize);
+	DA_context.last_tx_process_time = jiffies - entry_time;
+
+	if (DA_context.max_tx_process_time < DA_context.last_tx_process_time)
+		DA_context.max_tx_process_time = DA_context.last_tx_process_time;
+}
+
+void SDA_function4RecvDone(unsigned char *pBuffer, unsigned int BufferSize)
+{
+	//what should we do in this API
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+		"%s[%d]pBuffer=0x%p,BufferSize=%d\n\r",__func__,__LINE__,pBuffer,BufferSize);
+}
+
+void SDA_setSharedMemory4Send(unsigned int BufferId,
+                                  unsigned char *pBufferTotal,
+                                  unsigned int BufferTotalSize,
+                                  unsigned int BufferUnitSize,
+                                  unsigned int HeadroomSize)
+{
+	Direct_Audio_Tx_Setting(BufferId,
+                                pBufferTotal,
+                                BufferTotalSize,
+                                BufferUnitSize,
+                                HeadroomSize);
+}
+
+void SDA_setSharedMemory4Recv(unsigned char *pBufferTotal,
+                                  unsigned int BufferTotalSize,
+                                  unsigned int BufferUnitSize,
+                                  unsigned int HeadroomSize)
+{
+	Direct_Audio_Rx_Setting(pBufferTotal,
+                                BufferTotalSize,
+                                BufferUnitSize,
+                                HeadroomSize);
+}
+
+//Register callback which CLD notify DSP that CLD has received the audio packet
+void SDA_registerCallback4Recv(SDA_RecvCallBack pCallback)
+{
+	SDA_RX_READY_CB = pCallback;
+}
+
+//Register callback which Mck notify DSP that Mck has sent the audio packet
+void SDA_registerCallback4SendDone(SDA_SendDoneCallBack pCallback)
+{
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+		"%s[%d]\n\r",__func__,__LINE__);
+	SDA_TX_DONE_CB = pCallback;
+}
+
+void Direct_Audio_debug_dump(void)
+{
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,"DA_context.pHddCtx = 0x%x\n\r",(int)DA_context.pHddCtx);
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,"DA_context.last_tx_process_time = %u\n\r",DA_context.last_tx_process_time);
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,"DA_context.max_tx_process_time = %u\n\r",DA_context.max_tx_process_time);
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,"DA_context.last_rx_process_time = %u\n\r",DA_context.last_rx_process_time);
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,"DA_context.max_rx_process_time = %u\n\r",DA_context.max_rx_process_time);
+}
+
+void Direct_Audio_init(hdd_context_t *pHddCtx)
+{
+	int i;
+
+	memset(&global_RX_DA_Setting, 0x0, sizeof(global_RX_DA_Setting));
+	for (i = 0; i < MAX_TX_POOL_ID; i++)
+	    memset(&global_TX_DA_Setting[i], 0x0, sizeof(global_TX_DA_Setting[0]));
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,"%s[%d]\n\r",__func__,__LINE__);
+
+	memset(&DA_context,0x00,sizeof(DA_context));
+	DA_context.pHddCtx = pHddCtx;
+	DA_context.vif_id = 1;//use p2p0 as default
+}
+
+void Direct_Audio_deinit(hdd_context_t *pHddCtx)
+{
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,"%s[%d]\n\r",__func__,__LINE__);
+#ifdef CONFIG_CONTX_USB_DEBUG
+	if (txkeeprun == 1) {
+		txkeeprun = 0;
+		msleep(500);
+	}
+#endif /* CONFIG_CONTX_USB_DEBUG */
+}
+
+#define TSF_TO_TU(_h,_l)    ((((u64)(_h)) << 32) | ((u64)(_l)))
+#define REG_TSF_L 0x1054
+#define REG_TSF_H 0x1058
+#define REG_TSF2_L 0x10d4
+#define REG_TSF2_H 0x10d8
+
+
+void SDA_GetTSF(unsigned int *pTsf)
+{
+	*((u64 *)pTsf) = SDA_getTsf(0);
+}
+
+unsigned long long SDA_getTsf (unsigned char vif_id)
+{
+	A_UINT32 datah = 0, datal = 0;
+	struct hif_usb_softc *sc;
+	struct ol_softc *pOlsc;
+	VosContextType *pHIFContext = NULL;
+	v_CONTEXT_t pVosContext = NULL;
+
+	if (DA_context.pHddCtx == NULL) {
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
+			"%s: DA_context.ar should not be NULL\n", __func__);
+		return 0;
+	}
+
+	pVosContext = DA_context.pHddCtx->pvosContext;
+	pHIFContext = ((VosContextType*)pVosContext)->pHIFContext;
+	pOlsc = (struct ol_softc *)pHIFContext;
+	sc = pOlsc->hif_sc;
+
+	if (vif_id) {
+		HIFDiagReadAccess(sc->hif_device, REG_TSF2_H, &datah);
+		HIFDiagReadAccess(sc->hif_device, REG_TSF2_L, &datal);
+	} else {
+		HIFDiagReadAccess(sc->hif_device, REG_TSF_H, &datah);
+		HIFDiagReadAccess(sc->hif_device, REG_TSF_L, &datal);
+	}
+	return TSF_TO_TU(datah, datal);
+}
+
+int SDA_syncTsf (void)
+{
+	A_UINT32 datah = 0, datal = 0;
+	struct hif_usb_softc *sc;
+	struct ol_softc *pOlsc;
+	VosContextType *pHIFContext = NULL;
+	v_CONTEXT_t pVosContext = NULL;
+
+	if (DA_context.pHddCtx == NULL) {
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
+			"%s: DA_context.ar should not be NULL\n", __func__);
+		return 0;
+	}
+
+	pVosContext = DA_context.pHddCtx->pvosContext;
+	pHIFContext = ((VosContextType*)pVosContext)->pHIFContext;
+	pOlsc = (struct ol_softc *)pHIFContext;
+	sc = pOlsc->hif_sc;
+
+	HIFDiagReadAccess(sc->hif_device, REG_TSF_L, &datal);
+	HIFDiagReadAccess(sc->hif_device, REG_TSF_H, &datah);
+
+	HIFDiagWriteAccess(sc->hif_device, REG_TSF2_L, datal);
+	HIFDiagWriteAccess(sc->hif_device, REG_TSF2_H, datah);
+
+	return 0;
+}
+
+#if SDA_DEBUG//debug use
+struct D_A_SHARE_MEM {
+    SDA_Header_t	desc;
+	u8				data[MAX_BUF_SIZE];
+};
+
+static void debug_tx_done_cb(unsigned int BufferId, unsigned char *pBuffer, unsigned int BufferSize)
+{
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+			"%s[%d]BufferId=%d,pBuffer=0x%p,BufferSize=%d\n\r",
+	        __func__, __LINE__, BufferId, pBuffer, BufferSize);
+}
+#ifdef CONFIG_CONTX_USB_DEBUG
+/* only works with 9378 USB v2.3 only work on with some firmwares */
+static u8 seq_for_contx=0;
+extern int txkeepcountmax;
+int SDA_CONTX_COUNT_RESET(void)
+{
+	struct hif_usb_softc *sc;
+	struct ol_softc *pOlsc;
+	VosContextType *pHIFContext = NULL;
+	v_CONTEXT_t pVosContext = NULL;
+
+	if (DA_context.pHddCtx == NULL) {
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
+			"%s: DA_context.ar should not be NULL\n", __func__);
+		return 0;
+	}
+
+	pVosContext = DA_context.pHddCtx->pvosContext;
+	pHIFContext = ((VosContextType*)pVosContext)->pHIFContext;
+	pOlsc = (struct ol_softc *)pHIFContext;
+	sc = pOlsc->hif_sc;
+
+	seq_for_contx = 0;
+	HIFDiagWriteAccess(sc->hif_device, 0x41c240, 0);
+	HIFDiagWriteAccess(sc->hif_device, 0x41c244, 0);
+	HIFDiagWriteAccess(sc->hif_device, 0x41c248, 0);
+	HIFDiagWriteAccess(sc->hif_device, 0x41c24c, 0);
+	msleep(5);  //wait for write to complete
+	return 0;
+}
+
+int SDA_CONTX_COUNT_RESULT(char * extra, A_UINT8 wait_loop)
+{
+	A_UINT32 seq_error = 0, content_err_count = 0, totalcount =0;
+	struct hif_usb_softc *sc;
+	struct ol_softc *pOlsc;
+	VosContextType *pHIFContext = NULL;
+	v_CONTEXT_t pVosContext = NULL;
+
+	if (DA_context.pHddCtx == NULL) {
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
+			"%s: DA_context.ar should not be NULL\n", __func__);
+		return 0;
+	}
+
+	pVosContext = DA_context.pHddCtx->pvosContext;
+	pHIFContext = ((VosContextType*)pVosContext)->pHIFContext;
+	pOlsc = (struct ol_softc *)pHIFContext;
+	sc = pOlsc->hif_sc;
+
+	HIFDiagReadAccess(sc->hif_device, 0x41c24c, &totalcount);
+	while (wait_loop-- && (totalcount != txkeepcountmax)) {
+		pr_err("bus slow wait %d time, (%d)\n",(10 - wait_loop), totalcount);
+		msleep(200);
+		HIFDiagReadAccess(sc->hif_device, 0x41c24c, &totalcount);
+	}
+
+	HIFDiagReadAccess(sc->hif_device, 0x41c244, &seq_error);
+	HIFDiagReadAccess(sc->hif_device, 0x41c248, &content_err_count);
+
+	pr_err(" total %d seq_err %d content_err %d\n", totalcount, seq_error, content_err_count);
+
+	if (extra)
+		snprintf(extra, WE_MAX_STR_LEN, " total %d seq_err %d content_err %d\n", totalcount, seq_error, content_err_count);
+	return 0;
+}
+
+#endif
+#ifdef CONFIG_VOS_MEM_PRE_ALLOC
+static u8 gtxdebugbuf[(sizeof(SDA_Header_t)+MAX_BUF_SIZE)*MAX_SHARE_MEM_ITEM];
+static u8 grxdebugbuf[sizeof(struct D_A_SHARE_MEM)*MAX_SHARE_MEM_ITEM];
+#endif
+int Direct_Audio_TX_debug(unsigned int usbdbgtxtime)
+{
+	u8	*buf;
+	u32 len,i,BufferSize;
+	u8	*ptr,*eth_ptr;
+	SDA_Descriptor_t *share_mem_ptr;
+	hdd_adapter_t * vif;
+
+	u8	test_peermac[6] = {0xff,0x03,0x7f,0x8b,0x18,0x93};
+	struct ethhdr *eth_hdr;
+	u8 sendcount = 1;
+
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
+		"%s[%d]Simulate TX behavior\n\r",__func__,__LINE__);
+	SDA_registerCallback4SendDone(debug_tx_done_cb);
+
+	len = (sizeof(SDA_Header_t)+MAX_BUF_SIZE)*MAX_SHARE_MEM_ITEM;
+#ifdef CONFIG_VOS_MEM_PRE_ALLOC
+	buf = (u8 *)gtxdebugbuf;
+#else
+	buf = kmalloc(len, GFP_ATOMIC);
+	if (!buf)
+		return -ENOMEM;
+#endif
+	SDA_setSharedMemory4Send(0, buf, len, sizeof(SDA_Header_t)+MAX_BUF_SIZE, 50);
+	ptr	= buf;
+#ifdef CONFIG_CONTX_USB_DEBUG
+	if (txkeeprun != 0) {
+		DA_context.vif_id = 1; //p2p0
+		sendcount = MAX_SHARE_MEM_ITEM;
+	} else {
+		DA_context.vif_id = 1; //p2p0
+		sendcount = 5;
+	}
+#endif /* CONFIG_CONTX_USB_DEBUG */
+	//construct tx share memory
+	vif = hdd_get_adapter_by_vdev(DA_context.pHddCtx, DA_context.vif_id);
+	if(!vif)
+		return -ENOMEM;
+
+
+
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+			"peer %pM mac %pM\n", test_peermac, vif->dev->dev_addr);
+
+	memset(buf,0x00,len);
+	share_mem_ptr = (SDA_Descriptor_t *)buf;
+	BufferSize = 0;
+#ifdef CONFIG_CONTX_USB_DEBUG
+	for (i=0; i < sendcount; i++) {
+		//fill descript
+		share_mem_ptr->m_ReadyToCopy = 1;
+		share_mem_ptr->m_PayloadSize = 1024;
+		share_mem_ptr->m_TimeStamp = 0;
+		//fill ethernet header
+		eth_ptr = ptr+sizeof(SDA_Header_t)-sizeof(struct ethhdr);
+		eth_hdr = (struct ethhdr *)eth_ptr;
+		memcpy(eth_hdr->h_dest,test_peermac,6);
+		memcpy(eth_hdr->h_source,vif->dev->dev_addr,6);
+		eth_hdr->h_proto = htons(DIRECT_AUDIO_LLC_TYPE);
+		if (usbdbgtxtime != 0 ) {
+			memset(ptr+sizeof(SDA_Header_t),0xa5,share_mem_ptr->m_PayloadSize);
+			memset(ptr+sizeof(SDA_Header_t),seq_for_contx,2+1); /* +2 for aligment in fw */
+			seq_for_contx++;
+		} else {
+			memset(ptr+sizeof(SDA_Header_t),0xa5,share_mem_ptr->m_PayloadSize);
+		}
+		BufferSize += sizeof(SDA_Header_t) + MAX_BUF_SIZE;
+		ptr = ptr + sizeof(SDA_Header_t) + MAX_BUF_SIZE;
+		share_mem_ptr = (SDA_Descriptor_t *)ptr;
+	}
+
+#else
+	for (i=0; i < sendcount; i++) {
+		//fill descript
+		share_mem_ptr->m_ReadyToCopy = 1;
+		share_mem_ptr->m_PayloadSize = 1024;
+		share_mem_ptr->m_TimeStamp = 0;
+		//fill ethernet header
+		eth_ptr = ptr+sizeof(SDA_Header_t)-sizeof(struct ethhdr);
+		eth_hdr = (struct ethhdr *)eth_ptr;
+		memcpy(eth_hdr->h_dest,test_peermac,6);
+		memcpy(eth_hdr->h_source,vif->dev->dev_addr,6);
+		eth_hdr->h_proto = htons(DIRECT_AUDIO_LLC_TYPE);
+		memset(ptr+sizeof(SDA_Header_t),0xa5,share_mem_ptr->m_PayloadSize);
+		BufferSize += sizeof(SDA_Header_t) + MAX_BUF_SIZE;
+		ptr = ptr + sizeof(SDA_Header_t) + MAX_BUF_SIZE;
+		share_mem_ptr = (SDA_Descriptor_t *)ptr;
+	}
+#endif /* CONFIG_CONTX_USB_DEBUG */
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+		"%s[%d]BufferId=%d,pBuffer=0x%p,BufferSize=%d\n\r",
+	    __func__, __LINE__, 0, buf, BufferSize);
+	//notify Direct Audio module to send packet
+	SDA_function4Send(0, buf, BufferSize);
+#ifndef CONFIG_VOS_MEM_PRE_ALLOC
+	kfree(buf);
+#endif
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
+		"%s[%d]Simulate TX finish, wlan tsf %llu, p2p tsf %llu\n",
+		__func__,__LINE__, SDA_getTsf(0), SDA_getTsf(1));
+
+	return 0;
+}
+
+static void debug_rx_ready_cb(unsigned char *pBuffer, unsigned int BufferSize)
+{
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
+		"%s[%d]pBuffer=0x%p,BufferSize=%d\n\r",
+		__func__, __LINE__, pBuffer, BufferSize);
+}
+
+int Direct_Audio_RX_debug(void)
+{
+	u8	*buf;
+	u32 len;
+
+	if(RX_DA_INIT_ADDR) {
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_WARN,
+			"%s[%d]already rx debug\n\r",__func__,__LINE__);
+	}
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
+		"%s[%d]SimulateRX behavior\n\r",__func__,__LINE__);
+	len = sizeof(struct D_A_SHARE_MEM)*MAX_SHARE_MEM_ITEM;
+#ifdef CONFIG_VOS_MEM_PRE_ALLOC
+	buf = (u8 *)grxdebugbuf;
+#else
+	buf = kmalloc(len, GFP_ATOMIC);
+	if (!buf)
+		return -ENOMEM;
+#endif
+	//construct rx share memory
+	memset(buf,0x00,len);
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
+		"%s[%d]buf=0x%p\n\r", __func__, __LINE__, buf);
+	SDA_setSharedMemory4Recv(buf, len, sizeof(struct D_A_SHARE_MEM), 50);
+	//Direct_Audio_RxReady_Notify_cb_Reg(debug_rx_ready_cb);
+	SDA_registerCallback4Recv(debug_rx_ready_cb);
+	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
+		"%s[%d]Simulate RX finish\n\r",__func__,__LINE__);
+#ifndef CONFIG_VOS_MEM_PRE_ALLOC
+	kfree(buf);
+#endif
+	return 0;
+}
+#else
+int Direct_Audio_TX_debug(unsigned int usbdbgtxtime)
+{
+	return 0;
+}
+
+int Direct_Audio_RX_debug(void)
+{
+	return 0;
+}
+#endif //if SDA_DEBUG
+
+EXPORT_SYMBOL(SDA_function4Send);
+EXPORT_SYMBOL(SDA_function4RecvDone);
+EXPORT_SYMBOL(SDA_setSharedMemory4Send);
+EXPORT_SYMBOL(SDA_setSharedMemory4Recv);
+EXPORT_SYMBOL(SDA_registerCallback4SendDone);
+EXPORT_SYMBOL(SDA_registerCallback4Recv);
+EXPORT_SYMBOL(SDA_GetTSF);
+EXPORT_SYMBOL(SDA_getTsf);
+EXPORT_SYMBOL(SDA_syncTsf);
+#endif //end DIRECT_AUDIO_SUPPORT
diff -urN qcacld-new.orig/CORE/HDD/src/wlan_hdd_hostapd.c qcacld-new/CORE/HDD/src/wlan_hdd_hostapd.c
--- qcacld-new.orig/CORE/HDD/src/wlan_hdd_hostapd.c	2016-05-16 10:58:08.718298648 +0800
+++ qcacld-new/CORE/HDD/src/wlan_hdd_hostapd.c	2016-05-16 10:58:19.010298648 +0800
@@ -1870,6 +1870,10 @@
     return VOS_STATUS_SUCCESS;
 }
 
+#ifdef DIRECT_AUDIO_SUPPORT
+extern int Direct_Audio_TX_debug(unsigned int usbdbgtxtime);
+extern int Direct_Audio_RX_debug(void);
+#endif
 
 int
 static iw_softap_setparam(struct net_device *dev,
@@ -2142,6 +2146,24 @@
                                                set_value, DBG_CMD);
                   break;
              }
+#ifdef CONFIG_WLAN_FWLOG_FILE
+        case QCSAP_DBGLOG_FWLOG_FILE_ENABLE:
+             {
+                  hddLog(LOG1, "QCSAP_DBGLOG_FWLOG_FILE_ENABLE val %d", set_value);
+                  ret = process_wma_set_command((int)pHostapdAdapter->sessionId,
+                                               (int)WMI_DBGLOG_FWLOG_FILE_ENABLE,
+                                               set_value, DBG_CMD);
+                  break;
+             }
+        case QCSAP_DBGLOG_FWLOG_FILE_MAX_SIZE:
+             {
+                  hddLog(LOG1, "QCSAP_DBGLOG_FWLOG_FILE_MAX_SIZE val %d", set_value);
+                  ret = process_wma_set_command((int)pHostapdAdapter->sessionId,
+                                               (int)WMI_DBGLOG_FWLOG_FILE_MAX_SIZE,
+                                               set_value, DBG_CMD);
+                  break;
+             }
+#endif
 #ifdef DEBUG
          case QCSAP_FW_CRASH_INJECT:
              {
@@ -2625,6 +2647,20 @@
                 }
                 break;
             }
+#ifdef DIRECT_AUDIO_SUPPORT
+	case QCSAP_DIRECT_AUDIO_TEST:
+	    {
+		hddLog(LOGW, "%s: SAP Direct_Audio Test %s\n",
+				  __func__, set_value?"TX":"RX");
+		if (set_value) {
+		  ret = Direct_Audio_TX_debug(0);
+		}
+		else {
+		  ret = Direct_Audio_RX_debug();
+		}
+		break;
+	    }
+#endif
         default:
             hddLog(LOGE, FL("Invalid setparam command %d value %d"),
                     sub_cmd, set_value);
diff -urN qcacld-new.orig/CORE/HDD/src/wlan_hdd_main.c qcacld-new/CORE/HDD/src/wlan_hdd_main.c
--- qcacld-new.orig/CORE/HDD/src/wlan_hdd_main.c	2016-05-16 10:58:08.738298648 +0800
+++ qcacld-new/CORE/HDD/src/wlan_hdd_main.c	2016-05-16 10:58:19.014298648 +0800
@@ -3493,6 +3493,15 @@
    } else if (value == EXT_WOW_TYPE_APP_TYPE1 &&
         pHddCtx->is_extwow_app_type1_param_set)
         params.type = value;
+#ifdef WLAN_FEATURE_EXTWOW_OUTDOOR_SUPPORT
+   else if (value == EXT_WOW_TYPE_APP_TYPE2 &&
+        pHddCtx->is_extwow_app_type2_param_set)
+        params.type = value;
+   else if (value == EXT_WOW_TYPE_APP_TYPE1_2 &&
+        pHddCtx->is_extwow_app_type1_param_set &&
+        pHddCtx->is_extwow_app_type2_param_set)
+        params.type = value;
+#endif
    else {
         hddLog(VOS_TRACE_LEVEL_ERROR,
            FL("Set app params before enable it value %d"),value);
@@ -3566,6 +3575,243 @@
 }
 
 
+#ifdef WLAN_FEATURE_EXTWOW_OUTDOOR_SUPPORT
+static int hdd_set_app_type2_params(tHalHandle hHal,
+                          tpSirAppType2Params arg_params)
+{
+    tSirAppType2Params params;
+    eHalStatus halStatus = eHAL_STATUS_FAILURE;
+
+    vos_mem_copy(&params, arg_params, sizeof(params));
+
+    halStatus = sme_ConfigureAppType2Params(hHal, &params);
+    if (eHAL_STATUS_SUCCESS != halStatus)
+    {
+        hddLog(VOS_TRACE_LEVEL_ERROR,
+             FL("sme_ConfigureAppType2Params returned failure %d"), halStatus);
+        return -EPERM;
+    }
+
+    return 0;
+}
+
+static int hdd_parse_hex_array(u8* arg, int len, u8* array, u16 array_len)
+{
+        u8* pos;
+        int i;
+
+        for (pos = arg, i = 0;
+             ((*pos) != ' ') && (i < array_len) && ( pos < (arg + len));
+             pos += 2, i++) {
+                if (((*pos) >= '0') && ((*pos) <= '9')) {
+                        array[i] = ((*pos) - '0') << 4;
+                } else if (((*pos) >= 'a') && ((*pos) <= 'f')) {
+                        array[i] = ((((*pos) - 'a') + 10) << 4) ;
+                }
+                if (((*(pos+1)) >= '0') && ((*(pos+1)) <= '9')) {
+                        array[i] += *(pos+1) - '0';
+                } else if (((*(pos+1)) >= 'a') && ((*(pos+1)) <= 'f')) {
+                        array[i] += *(pos+1) - 'a' + 10;
+                }
+        }
+        return i;
+}
+
+static int hdd_set_app_type2_parser(hdd_adapter_t *pAdapter,
+                            char *arg, int len)
+{
+    hdd_context_t *pHddCtx = WLAN_HDD_GET_CTX(pAdapter);
+    tHalHandle hHal = WLAN_HDD_GET_HAL_CTX(pAdapter);
+    char mac_addr[20];
+    tANI_U8 rc4_write_sandbox[256], rc4_read_sandbox[256],
+            ssl_write_seq[8], ssl_read_seq[8],
+            ssl_sha1_write_key[64], ssl_sha1_read_key[64],
+            tcp_options[82];
+    tANI_U16 ssl_sha1_write_key_len, ssl_sha1_read_key_len;
+
+    unsigned int gateway_mac[6], i;
+    tSirAppType2Params* params;
+    int ret;
+
+    params = vos_mem_malloc( sizeof( tSirAppType2Params ) );
+    if (!params) {
+        hddLog(VOS_TRACE_LEVEL_ERROR, FL("No memory"));
+        return -ENOMEM;
+    }
+
+    ret = wlan_hdd_validate_context(pHddCtx);
+    if (0 != ret) {
+        hddLog(VOS_TRACE_LEVEL_ERROR, FL("HDD context is not valid"));
+        vos_mem_free(params);
+        return -EINVAL;
+    }
+
+    memset(params, 0, sizeof(tSirAppType2Params));
+
+    ret = hdd_parse_hex_array(arg, len, rc4_write_sandbox, sizeof(rc4_write_sandbox));
+    if (ret != 256) {
+        hddLog(VOS_TRACE_LEVEL_ERROR, FL("invalid sandbox"));
+        vos_mem_free(params);
+        return -EINVAL;
+    }
+    arg += 513;
+    len -= 513;
+
+    ret = hdd_parse_hex_array(arg, len, rc4_read_sandbox, sizeof(rc4_read_sandbox));
+    if (ret != 256) {
+        hddLog(VOS_TRACE_LEVEL_ERROR, FL("Invalid sandbox"));
+        vos_mem_free(params);
+        return -EINVAL;
+    }
+    arg += 513;
+    len -= 513;
+
+    ret = hdd_parse_hex_array(arg, len, ssl_write_seq, sizeof(ssl_write_seq));
+    if (ret != 8) {
+        hddLog(VOS_TRACE_LEVEL_ERROR, FL("Invalid write seq"));
+        vos_mem_free(params);
+        return -EINVAL;
+    }
+    arg += 17;
+    len -= 17;
+
+    ret = hdd_parse_hex_array(arg, len, ssl_read_seq, sizeof(ssl_read_seq));
+    if (ret != 8) {
+        hddLog(VOS_TRACE_LEVEL_ERROR, FL("Invalid read seq"));
+        vos_mem_free(params);
+        return -EINVAL;
+    }
+    arg += 17;
+    len -= 17;
+
+    ret = hdd_parse_hex_array(arg, len, ssl_sha1_write_key, sizeof(ssl_sha1_write_key));
+    ssl_sha1_write_key_len = ret;
+    arg += ret*2 + 1;
+    len -= ret*2 + 1;
+
+    ret = hdd_parse_hex_array(arg, len, ssl_sha1_read_key, sizeof(ssl_sha1_read_key));
+    ssl_sha1_read_key_len = ret;
+    arg += ret*2 + 1;
+    len -= ret*2 + 1;
+
+    ret = hdd_parse_hex_array(arg, len, &params->rc4_write_x, 1);
+    arg += 3;
+    len -= 3;
+
+    ret = hdd_parse_hex_array(arg, len, &params->rc4_write_y, 1);
+    arg += 3;
+    len -= 3;
+
+    ret = hdd_parse_hex_array(arg, len, &params->rc4_read_x, 1);
+    arg += 3;
+    len -= 3;
+
+    ret = hdd_parse_hex_array(arg, len, &params->rc4_read_y, 1);
+    arg += 3;
+    len -= 3;
+
+
+    ret = sscanf(arg, "%17s %x %x %x %u %u %u %u %u %80s %u %u %u %u %u %u %u",
+        mac_addr,
+        (unsigned int*)&params->ip_id,
+        (unsigned int*)&params->ip_device_ip,
+        (unsigned int*)&params->ip_server_ip,
+        (unsigned int*)&params->tcp_src_port,
+        (unsigned int*)&params->tcp_dst_port,
+        (unsigned int*)&params->tcp_seq,
+        (unsigned int*)&params->tcp_ack_seq,
+        (unsigned int*)&params->tcp_options_len,
+        tcp_options,
+        (unsigned int*)&params->asyncId,
+        (unsigned int*)&params->keepalive_init,
+        (unsigned int*)&params->keepalive_min,
+        (unsigned int*)&params->keepalive_max,
+        (unsigned int*)&params->keepalive_inc,
+        (unsigned int*)&params->tcp_tx_timeout_val,
+        (unsigned int*)&params->tcp_rx_timeout_val);
+
+
+    if (ret != 17 && ret != 11) {
+        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+                 "Invalid Number of arguments");
+        vos_mem_free(params);
+        return -EINVAL;
+    }
+
+    if (params->tcp_options_len) {
+        ret = hdd_parse_hex_array(tcp_options, 80, params->tcp_options, 40);
+        if (ret != 40) {
+            VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+                      "Invalid tcp options");
+            vos_mem_free(params);
+            return -EINVAL;
+        }
+    }
+
+    if (6 != sscanf(mac_addr, "%02x:%02x:%02x:%02x:%02x:%02x", &gateway_mac[0],
+             &gateway_mac[1], &gateway_mac[2], &gateway_mac[3],
+             &gateway_mac[4], &gateway_mac[5])) {
+        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+               "Invalid MacAddress Input %s", mac_addr);
+        vos_mem_free(params);
+        return -EINVAL;
+    }
+
+    if (params->tcp_src_port > WLAN_HDD_MAX_TCP_PORT ||
+           params->tcp_dst_port > WLAN_HDD_MAX_TCP_PORT) {
+        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+             "Invalid TCP Port Number");
+        vos_mem_free(params);
+        return -EINVAL;
+    }
+
+    for (i = 0; i < ETHER_ADDR_LEN; i++)
+        params->gateway_mac[i] = (uint8_t) gateway_mac[i];
+
+    vos_mem_copy(params->rc4_write_sandbox, rc4_write_sandbox, sizeof(params->rc4_write_sandbox));
+    vos_mem_copy(params->rc4_read_sandbox, rc4_read_sandbox, sizeof(params->rc4_read_sandbox));
+    vos_mem_copy(params->ssl_write_seq, ssl_write_seq, sizeof(params->ssl_write_seq));
+    vos_mem_copy(params->ssl_read_seq, ssl_read_seq, sizeof(params->ssl_read_seq));
+    vos_mem_copy(params->ssl_sha1_write_key, ssl_sha1_write_key, sizeof(params->ssl_sha1_write_key));
+    params->ssl_sha1_write_key_len = ssl_sha1_write_key_len;
+    vos_mem_copy(params->ssl_sha1_read_key, ssl_sha1_read_key, sizeof(params->ssl_sha1_read_key));
+    params->ssl_sha1_read_key_len = ssl_sha1_read_key_len;
+
+    params->vdev_id = pAdapter->sessionId;
+    params->tcp_src_port = (params->tcp_src_port != 0)?
+        params->tcp_src_port : pHddCtx->cfg_ini->extWowApp2TcpSrcPort;
+    params->tcp_dst_port = (params->tcp_dst_port != 0)?
+        params->tcp_dst_port : pHddCtx->cfg_ini->extWowApp2TcpDstPort;
+    params->keepalive_init = (params->keepalive_init != 0)?
+        params->keepalive_init : pHddCtx->cfg_ini->extWowApp2KAInitPingInterval;
+    params->keepalive_min = (params->keepalive_min != 0)?
+        params->keepalive_min : pHddCtx->cfg_ini->extWowApp2KAMinPingInterval;
+    params->keepalive_max = (params->keepalive_max != 0)?
+        params->keepalive_max : pHddCtx->cfg_ini->extWowApp2KAMaxPingInterval;
+    params->keepalive_inc = (params->keepalive_inc != 0)?
+        params->keepalive_inc : pHddCtx->cfg_ini->extWowApp2KAIncPingInterval;
+    params->tcp_tx_timeout_val = (params->tcp_tx_timeout_val != 0)?
+        params->tcp_tx_timeout_val : pHddCtx->cfg_ini->extWowApp2TcpTxTimeout;
+    params->tcp_rx_timeout_val = (params->tcp_rx_timeout_val != 0)?
+        params->tcp_rx_timeout_val : pHddCtx->cfg_ini->extWowApp2TcpRxTimeout;
+
+    VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
+        "%s: %pM %u %u %u %u %u %u %u %u %u %u %u %u %u",
+        __func__, gateway_mac, params->ip_id, params->ip_device_ip,
+        params->ip_server_ip, params->tcp_seq, params->tcp_ack_seq,
+        params->tcp_src_port, params->tcp_dst_port, params->keepalive_init,
+        params->keepalive_min, params->keepalive_max,
+        params->keepalive_inc, params->tcp_tx_timeout_val,
+        params->tcp_rx_timeout_val);
+
+    ret = hdd_set_app_type2_params(hHal, params);
+    if (ret == 0) {
+        vos_mem_copy(&pHddCtx->app_type2_params, params, sizeof(tSirAppType2Params));
+    }
+    vos_mem_free(params);
+    return ret;
+}
+#endif
 
 static int hdd_get_app_type1_params(hdd_adapter_t *pAdapter,
                                              char *arg, int len)
@@ -3587,6 +3833,144 @@
     return ret;
 }
 
+#ifdef WLAN_FEATURE_EXTWOW_OUTDOOR_SUPPORT
+static int hdd_get_app_type2_params(hdd_adapter_t *pAdapter,
+                            char *arg, int len)
+{
+    hdd_context_t *pHddCtx = WLAN_HDD_GET_CTX(pAdapter);
+    int ret;
+    int i;
+    char tcp_options[82];
+    char* tcp_options_idx;
+    int tcp_options_len;
+
+    ret = wlan_hdd_validate_context(pHddCtx);
+    if (0 != ret) {
+        hddLog(VOS_TRACE_LEVEL_ERROR, FL("HDD context is not valid"));
+        return -EINVAL;
+    }
+
+    if (len < 1529) {
+        return -EINVAL;
+    }
+    for (i = 0; i < 256; i+=8) {
+        ret = snprintf(arg, len, "%02x%02x%02x%02x%02x%02x%02x%02x",
+                       pHddCtx->app_type2_params.rc4_write_sandbox[i],
+                       pHddCtx->app_type2_params.rc4_write_sandbox[i+1],
+                       pHddCtx->app_type2_params.rc4_write_sandbox[i+2],
+                       pHddCtx->app_type2_params.rc4_write_sandbox[i+3],
+                       pHddCtx->app_type2_params.rc4_write_sandbox[i+4],
+                       pHddCtx->app_type2_params.rc4_write_sandbox[i+5],
+                       pHddCtx->app_type2_params.rc4_write_sandbox[i+6],
+                       pHddCtx->app_type2_params.rc4_write_sandbox[i+7]);
+        arg += ret;
+        len -= ret;
+    }
+    arg[0] = ' ';
+    arg++;
+    len--;
+
+
+    for (i = 0; i < 256; i+=8) {
+        ret = snprintf(arg, len, "%02x%02x%02x%02x%02x%02x%02x%02x",
+                       pHddCtx->app_type2_params.rc4_read_sandbox[i],
+                       pHddCtx->app_type2_params.rc4_read_sandbox[i+1],
+                       pHddCtx->app_type2_params.rc4_read_sandbox[i+2],
+                       pHddCtx->app_type2_params.rc4_read_sandbox[i+3],
+                       pHddCtx->app_type2_params.rc4_read_sandbox[i+4],
+                       pHddCtx->app_type2_params.rc4_read_sandbox[i+5],
+                       pHddCtx->app_type2_params.rc4_read_sandbox[i+6],
+                       pHddCtx->app_type2_params.rc4_read_sandbox[i+7]);
+        arg += ret;
+        len -= ret;
+    }
+    arg[0] = ' ';
+    arg++;
+    len--;
+
+
+    ret = snprintf(arg, len, "%02x%02x%02x%02x%02x%02x%02x%02x ",
+                        pHddCtx->app_type2_params.ssl_write_seq[0],
+                        pHddCtx->app_type2_params.ssl_write_seq[1],
+                        pHddCtx->app_type2_params.ssl_write_seq[2],
+                        pHddCtx->app_type2_params.ssl_write_seq[3],
+                        pHddCtx->app_type2_params.ssl_write_seq[4],
+                        pHddCtx->app_type2_params.ssl_write_seq[5],
+                        pHddCtx->app_type2_params.ssl_write_seq[6],
+                        pHddCtx->app_type2_params.ssl_write_seq[7]);
+    arg += ret;
+    len -= ret;
+
+    ret = snprintf(arg, len, "%02x%02x%02x%02x%02x%02x%02x%02x ",
+                        pHddCtx->app_type2_params.ssl_read_seq[0],
+                        pHddCtx->app_type2_params.ssl_read_seq[1],
+                        pHddCtx->app_type2_params.ssl_read_seq[2],
+                        pHddCtx->app_type2_params.ssl_read_seq[3],
+                        pHddCtx->app_type2_params.ssl_read_seq[4],
+                        pHddCtx->app_type2_params.ssl_read_seq[5],
+                        pHddCtx->app_type2_params.ssl_read_seq[6],
+                        pHddCtx->app_type2_params.ssl_read_seq[7]);
+    arg += ret;
+    len -= ret;
+
+    for (i = 0; i < pHddCtx->app_type2_params.ssl_sha1_write_key_len; i++) {
+        ret = snprintf(arg, len, "%02x", pHddCtx->app_type2_params.ssl_sha1_write_key[i]);
+        arg += ret;
+        len -= ret;
+    }
+    arg[0] = ' ';
+    arg++;
+    len--;
+
+    for (i = 0; i < pHddCtx->app_type2_params.ssl_sha1_read_key_len; i++) {
+        ret = snprintf(arg, len, "%02x", pHddCtx->app_type2_params.ssl_sha1_read_key[i]);
+        arg += ret;
+        len -= ret;
+    }
+    arg[0] = ' ';
+    arg++;
+    len--;
+
+    memset(tcp_options, 0, sizeof(tcp_options));
+    tcp_options_idx = tcp_options;
+    tcp_options_len = sizeof(tcp_options);
+    for (i = 0; i <  pHddCtx->app_type2_params.tcp_options_len; i++) {
+        ret = snprintf(tcp_options_idx, tcp_options_len, "%02x", pHddCtx->app_type2_params.tcp_options[i]);
+        tcp_options_idx += ret;
+        tcp_options_len -= ret;
+    }
+
+    ret = snprintf(arg, len, "%02x %02x %02x %02x %02x:%02x:%02x:%02x:%02x:%02x %x %x %x %u %u %u %u %u %s %u %u %u %u %u %u %u",
+             pHddCtx->app_type2_params.rc4_write_x,
+             pHddCtx->app_type2_params.rc4_write_y,
+             pHddCtx->app_type2_params.rc4_read_x,
+             pHddCtx->app_type2_params.rc4_read_y,
+             pHddCtx->app_type2_params.gateway_mac[0],
+             pHddCtx->app_type2_params.gateway_mac[1],
+             pHddCtx->app_type2_params.gateway_mac[2],
+             pHddCtx->app_type2_params.gateway_mac[3],
+             pHddCtx->app_type2_params.gateway_mac[4],
+             pHddCtx->app_type2_params.gateway_mac[5],
+             pHddCtx->app_type2_params.ip_id,
+             pHddCtx->app_type2_params.ip_device_ip,
+             pHddCtx->app_type2_params.ip_server_ip,
+             pHddCtx->app_type2_params.tcp_src_port,
+             pHddCtx->app_type2_params.tcp_dst_port,
+             pHddCtx->app_type2_params.tcp_seq,
+             pHddCtx->app_type2_params.tcp_ack_seq,
+             pHddCtx->app_type2_params.tcp_options_len,
+             tcp_options,
+             pHddCtx->app_type2_params.asyncId,
+             pHddCtx->app_type2_params.keepalive_init,
+             pHddCtx->app_type2_params.keepalive_min,
+             pHddCtx->app_type2_params.keepalive_max,
+             pHddCtx->app_type2_params.keepalive_inc,
+             pHddCtx->app_type2_params.tcp_tx_timeout_val,
+             pHddCtx->app_type2_params.tcp_rx_timeout_val);
+
+    return 0;
+}
+#endif
 #endif
 
 int wlan_hdd_set_mc_rate(hdd_adapter_t *pAdapter, int targetRate)
@@ -5768,6 +6152,17 @@
            if (ret >= 0)
                pHddCtx->is_extwow_app_type1_param_set = TRUE;
 
+#ifdef WLAN_FEATURE_EXTWOW_OUTDOOR_SUPPORT
+       } else if (strncmp(command, "SETAPP2PARAMS", 13) == 0) {
+           tANI_U8 *value = command;
+
+           /* Move pointer to ahead of SETAPP2PARAMS*/
+           value += 13;
+           ret = hdd_set_app_type2_parser(pAdapter,
+                                         value, strlen(value));
+           if (ret >= 0)
+               pHddCtx->is_extwow_app_type2_param_set = TRUE;
+#endif
        } else if (strncmp(command, "GETAPP1PARAMS", 13) == 0) {
            if (pHddCtx->is_extwow_app_type1_param_set == TRUE) {
                ret = hdd_get_app_type1_params(pAdapter,
@@ -5783,6 +6178,23 @@
            } else {
                ret = -EFAULT;
            }
+#ifdef WLAN_FEATURE_EXTWOW_OUTDOOR_SUPPORT
+       } else if (strncmp(command, "GETAPP2PARAMS", 13) == 0) {
+           if (pHddCtx->is_extwow_app_type2_param_set == TRUE) {
+               ret = hdd_get_app_type2_params(pAdapter,
+                                              command + 13, priv_data.total_len - 13);
+               if (ret == 0) {
+                   if (copy_to_user(priv_data.buf, command, strlen(command))) {
+                       VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+                       "%s: failed to copy data to user buffer", __func__);
+                       ret = -EFAULT;
+                       goto exit;
+                   }
+               }
+           } else {
+               ret = -EFAULT;
+           }
+#endif
        }
 
 #endif
@@ -5856,6 +6268,221 @@
 }
 
 #ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+#ifdef CONFIG_CUST_PLATFORM
+static void wlan_hdd_swol_work_item(struct work_struct *work)
+{
+    hdd_adapter_t *pAdapter = container_of(work,
+                                           hdd_adapter_t,
+                                           ext_wow_work);
+    hdd_context_t *pHddCtx = WLAN_HDD_GET_CTX(pAdapter);
+    tHalHandle hHal = WLAN_HDD_GET_HAL_CTX(pAdapter);
+    struct net_device *dev = pAdapter->dev;
+    int ret = 0;
+
+    if (WLAN_HDD_ADAPTER_MAGIC != pAdapter->magic) {
+        hddLog(LOGE, FL("invalid magic"));
+        return;
+    }
+    ret = wlan_hdd_validate_context(pHddCtx);
+    if (0 != ret) {
+        hddLog(LOGE, FL("HDD context is not valid"));
+        return;
+    }
+
+    mutex_lock(&pHddCtx->ext_wow_lock);
+    if (pHddCtx->ext_wow_enable == TRUE) {
+        pHddCtx->app_type1_params.vdev_id = pAdapter->sessionId;
+        pHddCtx->app_type1_params.id_length = 6;
+        vos_mem_zero(pHddCtx->app_type1_params.identification_id, sizeof(pHddCtx->app_type1_params.identification_id));
+        vos_mem_copy(pHddCtx->app_type1_params.identification_id, "SECWOW", 6);
+        vos_mem_copy(pHddCtx->app_type1_params.swol_indoor_wakee, pAdapter->macAddressCurrent.bytes, 6);
+        ret = hdd_set_app_type1_params(hHal, &(pHddCtx->app_type1_params));
+        if (ret >= 0) {
+            pHddCtx->is_extwow_app_type1_param_set = TRUE;
+        }
+        ret = hdd_enable_ext_wow_parser(pAdapter,
+                                        pAdapter->sessionId, EXT_WOW_TYPE_APP_TYPE1);
+        mutex_unlock(&pHddCtx->ext_wow_lock);
+        if (ret == 0) {
+            ret = cfg80211_wowlan_set(pAdapter->dev, TRUE);
+            if (ret != 0) {
+                VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+                           "%s failed to set wowlan:%d\n", netdev_name(dev), ret);
+            }
+        } else {
+            VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+                           "%s failed to enable extwow\n", netdev_name(dev));
+        }
+    } else {
+        ret = hdd_enable_ext_wow_parser(pAdapter,
+                                        pAdapter->sessionId, EXT_WOW_DISABLED);
+        mutex_unlock(&pHddCtx->ext_wow_lock);
+        if (ret != 0) {
+            VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+                           "%s failed to enable extwow\n", netdev_name(dev));
+        } else {
+            ret = cfg80211_wowlan_set(pAdapter->dev, FALSE);
+            if (ret != 0) {
+                VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+                           "%s failed to set wowlan:%d\n", netdev_name(dev), ret);
+            }
+        }
+    }
+    mutex_lock(&pHddCtx->ext_wow_lock);
+    vos_mem_zero(&pHddCtx->app_type1_params, sizeof(pHddCtx->app_type1_params));
+    pHddCtx->is_extwow_app_type1_param_set = FALSE;
+    mutex_unlock(&pHddCtx->ext_wow_lock);
+}
+
+static int _wlan_hdd_enable_swol(hdd_adapter_t *pAdapter, boolean enable)
+{
+    hdd_context_t *pHddCtx = WLAN_HDD_GET_CTX(pAdapter);
+
+    pHddCtx->ext_wow_enable = enable;
+    schedule_work(&pAdapter->ext_wow_work);
+    return 0;
+}
+
+int wlan_hdd_enable_swol(hdd_adapter_t *pAdapter, boolean enable)
+{
+    hdd_context_t *pHddCtx = WLAN_HDD_GET_CTX(pAdapter);
+    int ret;
+
+    mutex_lock(&pHddCtx->ext_wow_lock);
+    ret = _wlan_hdd_enable_swol(pAdapter, enable);
+    mutex_unlock(&pHddCtx->ext_wow_lock);
+    return ret;
+}
+
+int swol_ioctl(hdd_adapter_t *pAdapter, struct ifreq *ifr)
+{
+    hdd_context_t *pHddCtx = WLAN_HDD_GET_CTX(pAdapter);
+    int ret = 0;
+    int i =0, j = 0;
+    struct ioctl_priv_params *data;
+    tSirExtWoWParams params;
+
+    data = kmalloc(sizeof(struct ioctl_priv_params), GFP_KERNEL);
+    if (!data)
+        return -ENOMEM;
+
+    if (copy_from_user(data, ifr->ifr_data, sizeof(struct ioctl_priv_params)))
+    {
+        kfree(data);
+        return -EFAULT;
+    }
+
+    mutex_lock(&pHddCtx->ext_wow_lock);
+    switch (data->cmd_id){
+    case IOCTL_PRIV_SWOW_START:
+        switch(data->params.swow_start.cmd) {
+        case 0:
+            ret = _wlan_hdd_enable_swol(pAdapter, TRUE);
+            break;
+        case 1:
+            // Outdoor, not available now.
+            break;
+        case 9:
+            // Stop
+            ret = _wlan_hdd_enable_swol(pAdapter, FALSE);
+            break;
+        default:
+            break;
+        }
+    break;
+    case IOCTL_PRIV_SWOW_WAKER_W:
+        {
+            struct waker *waker_w = &(data->params.swow_waker_w.write_waker);
+            int index = data->params.swow_waker_w.waker_id;
+            if(index > 7){
+                VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+                             "out of index[0~7] : %d\n", index);
+                ret = -EINVAL;
+                break;
+            }
+
+            for( i=0; i <6; i++)
+                pHddCtx->app_type1_params.swol_indoor_key_mac[index][i] = waker_w->key_mac[i];
+
+            pHddCtx->app_type1_params.swol_indoor_app_mask[index] = waker_w->app_mask;
+            pHddCtx->app_type1_params.swol_indoor_key_len[index] = waker_w->key_len;
+            vos_mem_set( pHddCtx->app_type1_params.swol_indoor_key[index], 0, 16);
+            if(waker_w->key_len > 16){
+                VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+                            "wrong key len\n");
+                ret = -EINVAL;
+                break;
+            }
+            if (waker_w->key_len) {
+                vos_mem_copy(pHddCtx->app_type1_params.swol_indoor_key[index], waker_w->key, waker_w->key_len);
+            }
+            pHddCtx->app_type1_params.pass_length = waker_w->key_len;
+            vos_mem_set(pHddCtx->app_type1_params.password, 0, 16);
+            if (waker_w->key_len) {
+                vos_mem_copy(pHddCtx->app_type1_params.password, waker_w->key, pHddCtx->app_type1_params.pass_length);
+            }
+        }
+    break;
+    case IOCTL_PRIV_SWOW_WAKER_R:
+    {
+        struct waker *waker_r;
+
+        for( j=0; j < 8; j++) {
+            waker_r = &(data->params.swow_waker_r.read_waker[j]);
+                for( i=0; i <6; i++)
+                    waker_r->key_mac[i] = pHddCtx->app_type1_params.swol_indoor_key_mac[j][i];
+                waker_r->app_mask = pHddCtx->app_type1_params.swol_indoor_app_mask[j];
+                waker_r->key_len = pHddCtx->app_type1_params.swol_indoor_key_len[j];
+                vos_mem_set(waker_r->key, 0, 16);
+                if (waker_r->key_len) {
+                    vos_mem_copy(waker_r->key, pHddCtx->app_type1_params.swol_indoor_key[j], waker_r->key_len);
+                }
+            }
+        }
+    break;
+    case IOCTL_PRIV_SWOW_EXCEPTION_W:
+        pHddCtx->app_type1_params.swol_indoor_exception = data->params.swow_exception.exception;
+        pHddCtx->app_type1_params.swol_indoor_exception_app = data->params.swow_exception.exception_app;
+    break;
+    case IOCTL_PRIV_SWOW_EXCEPTION_R:
+        data->params.swow_exception.exception = pHddCtx->app_type1_params.swol_indoor_exception;
+        data->params.swow_exception.exception_app = pHddCtx->app_type1_params.swol_indoor_exception_app;
+    break;
+    case IOCTL_PRIV_SWOW_PATTEN_W:
+        pHddCtx->app_type1_params.swol_indoor_pattern = data->params.swow_pattern.pattern;
+    break;
+    case IOCTL_PRIV_SWOW_PATTEN_R:
+        data->params.swow_pattern.pattern = pHddCtx->app_type1_params.swol_indoor_pattern;
+    break;
+    case IOCTL_PRIV_SWOW_FILTER_W:
+        pHddCtx->app_type1_params.swol_indoor_waker_check = data->params.swow_filter.waker_check;
+        pHddCtx->app_type1_params.swol_indoor_pw_check = data->params.swow_filter.pw_check;
+        if(pHddCtx->app_type1_params.swol_indoor_waker_check == 0 && pHddCtx->app_type1_params.swol_indoor_pw_check == 1)
+            pHddCtx->app_type1_params.swol_indoor_pw_check = 0;
+    break;
+    case IOCTL_PRIV_SWOW_FILTER_R:
+        data->params.swow_filter.waker_check = pHddCtx->app_type1_params.swol_indoor_waker_check;
+        data->params.swow_filter.pw_check = pHddCtx->app_type1_params.swol_indoor_pw_check;
+    break;
+    case IOCTL_PRIV_SWOW_PULSE_TEST:
+        memset(&params, 0, sizeof(params));
+        params.vdev_id = pAdapter->sessionId;
+        params.type = EXT_WOW_TYPE_APP_PULSETEST;
+        params.wakeup_pin_num = pHddCtx->cfg_ini->extWowApp1WakeupPinNumber |
+                      (pHddCtx->cfg_ini->extWowApp2WakeupPinNumber << 8);
+        params.swol_pulsetest_type = data->params.swow_pulse_test.type;
+        params.swol_pulsetest_application = data->params.swow_pulse_test.app;
+        ret = hdd_enable_ext_wow(pAdapter, &params);
+    break;
+    default:
+    break;
+    }
+
+    mutex_unlock(&pHddCtx->ext_wow_lock);
+    kfree(data);
+    return ret;
+}
+#endif
 #endif
 
 int hdd_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
@@ -5905,6 +6532,11 @@
          ret = hdd_driver_ioctl(pAdapter, ifr);
       break;
 #ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+#ifdef CONFIG_CUST_PLATFORM
+   case (SIOCDEVPRIVATE+10):
+         ret = swol_ioctl(pAdapter, ifr);
+      break;
+#endif
 #endif
    default:
       hddLog(VOS_TRACE_LEVEL_ERROR, "%s: unknown ioctl %d",
@@ -7568,6 +8200,10 @@
 
   --------------------------------------------------------------------------*/
 
+#ifdef DIRECT_AUDIO_SUPPORT
+	extern void Direct_Audio_init(hdd_context_t *pHddCtx);
+	extern void Direct_Audio_deinit(hdd_context_t *pHddCtx);
+#endif
 static void hdd_uninit (struct net_device *dev)
 {
    hdd_adapter_t *pAdapter = WLAN_HDD_GET_PRIV_PTR(dev);
@@ -7597,6 +8233,9 @@
          /* we haven't validated all cases so let this go for now */
       }
 
+#ifdef DIRECT_AUDIO_SUPPORT
+		Direct_Audio_deinit(pAdapter->pHddCtx);
+#endif
 
 
       hdd_deinit_adapter(pAdapter->pHddCtx, pAdapter);
@@ -7811,7 +8450,11 @@
       .ndo_stop = hdd_stop,
       .ndo_uninit = hdd_uninit,
       .ndo_start_xmit = hdd_hard_start_xmit,
+#ifdef CONFIG_CUST_PLATFORM
+      .ndo_tx_timeout = NULL,
+#else
       .ndo_tx_timeout = hdd_tx_timeout,
+#endif
       .ndo_get_stats = hdd_stats,
       .ndo_do_ioctl = hdd_ioctl,
       .ndo_set_mac_address = hdd_set_mac_address,
@@ -8964,6 +9607,9 @@
 
 #endif
 #ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+#ifdef CONFIG_CUST_PLATFORM
+    INIT_WORK(&pAdapter->ext_wow_work, wlan_hdd_swol_work_item);
+#endif
 #endif
 
 
@@ -9147,6 +9793,9 @@
    ENTER();
 
 #ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+#ifdef CONFIG_CUST_PLATFORM
+   cancel_work_sync(&pAdapter->ext_wow_work);
+#endif
 #endif
 
    netif_tx_disable(pAdapter->dev);
@@ -9479,6 +10128,11 @@
       {
          case WLAN_HDD_INFRA_STATION:
 #ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+#ifdef CONFIG_CUST_PLATFORM
+            if (pAdapter->device_mode == WLAN_HDD_INFRA_STATION) {
+                wlan_hdd_enable_swol(pAdapter, FALSE);
+            }
+#endif
 #endif
 
          case WLAN_HDD_P2P_CLIENT:
@@ -11422,6 +12076,10 @@
    hdd_list_init( &pHddCtx->hddAdapters, MAX_NUMBER_OF_ADAPTERS );
 
 #ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+#ifdef CONFIG_CUST_PLATFORM
+   pHddCtx->ext_wow_enable = FALSE;
+   mutex_init(&pHddCtx->ext_wow_lock);
+#endif
 #endif
 
 #ifdef FEATURE_WLAN_TDLS
@@ -12378,6 +13036,14 @@
    return -EIO;
 
 success:
+#ifdef DIRECT_AUDIO_SUPPORT
+	Direct_Audio_init(pHddCtx);
+#endif
+#ifdef CONFIG_CUST_PLATFORM
+	rtnl_lock();
+	dev_open(pAdapter->dev);
+	rtnl_unlock();
+#endif
    EXIT();
    return 0;
 }
diff -urN qcacld-new.orig/CORE/HDD/src/wlan_hdd_p2p.c qcacld-new/CORE/HDD/src/wlan_hdd_p2p.c
--- qcacld-new.orig/CORE/HDD/src/wlan_hdd_p2p.c	2016-05-16 10:58:08.738298648 +0800
+++ qcacld-new/CORE/HDD/src/wlan_hdd_p2p.c	2016-05-16 10:58:19.014298648 +0800
@@ -512,6 +512,31 @@
 
 void wlan_hdd_remain_on_chan_timeout(void *data)
 {
+#ifdef CONFIG_CUST_PLATFORM
+    hdd_remain_on_chan_ctx_t *pRemainChanCtx = (hdd_remain_on_chan_ctx_t *)data;
+    hdd_adapter_t *pAdapter = pRemainChanCtx->pAdapter;
+    hdd_cfg80211_state_t *cfgState;
+
+    if (((((unsigned int)pAdapter) & 0x6b6b0000) == 0x6b6b0000) ||
+        (pAdapter == NULL)) {
+        hddLog( LOGE,"%s: No Remain on channel is pending", __func__);
+        return;
+    }
+
+    cfgState = WLAN_HDD_GET_CFG_STATE_PTR( pAdapter );
+    mutex_lock(&cfgState->remain_on_chan_ctx_lock);
+    if (pRemainChanCtx->cookie != (uintptr_t)pRemainChanCtx) {
+        mutex_unlock(&cfgState->remain_on_chan_ctx_lock);
+        hddLog( LOGE,"%s: Remain on channel has been cancel", __func__);
+        return;
+    }
+    if ((FALSE == pRemainChanCtx->hdd_remain_on_chan_cancel_in_progress) &&
+        (cfgState->remain_on_chan_ctx != pRemainChanCtx)) {
+        hddLog( LOGE,"%s: old Remain on channelshould be canceled", __func__);
+        mutex_unlock(&cfgState->remain_on_chan_ctx_lock);
+        return;
+    }
+#else
     hdd_adapter_t *pAdapter = (hdd_adapter_t *)data;
     hdd_remain_on_chan_ctx_t *pRemainChanCtx;
     hdd_cfg80211_state_t *cfgState;
@@ -532,6 +557,7 @@
         hddLog( LOGE,"%s: No Remain on channel is pending", __func__);
         return;
     }
+#endif
 
     if ( TRUE == pRemainChanCtx->hdd_remain_on_chan_cancel_in_progress )
     {
@@ -588,10 +614,17 @@
     pAdapter->is_roc_inprogress = TRUE;
 
     /* Initialize Remain on chan timer */
+#ifdef CONFIG_CUST_PLATFORM
+    vos_status = vos_timer_init(&pRemainChanCtx->hdd_remain_on_chan_timer,
+                                VOS_TIMER_TYPE_SW,
+                                wlan_hdd_remain_on_chan_timeout,
+                                pRemainChanCtx);
+#else
     vos_status = vos_timer_init(&pRemainChanCtx->hdd_remain_on_chan_timer,
                                 VOS_TIMER_TYPE_SW,
                                 wlan_hdd_remain_on_chan_timeout,
                                 pAdapter);
+#endif
     if (vos_status != VOS_STATUS_SUCCESS)
     {
           hddLog(VOS_TRACE_LEVEL_ERROR,
@@ -957,6 +990,9 @@
     pRemainChanCtx->action_pkt_buff.frame_ptr = NULL;
     pRemainChanCtx->action_pkt_buff.frame_length = 0;
     pRemainChanCtx->hdd_remain_on_chan_cancel_in_progress = FALSE;
+#ifdef CONFIG_CUST_PLATFORM
+    pRemainChanCtx->pAdapter = pAdapter;
+#endif
 
     if (REMAIN_ON_CHANNEL_REQUEST == request_type) {
         sta_adapter = hdd_get_adapter(pHddCtx, WLAN_HDD_INFRA_STATION);
@@ -2412,6 +2448,55 @@
      return ;
 }
 
+#ifdef CONFIG_CUST_PLATFORM
+#define NegochktableSize 32
+typedef struct {
+    u32 timestamp;
+    u8 macFrom[6];
+    u16 negoreq_sn;
+} NegoReqchk, *pNegoReqchk;
+
+#define TimeDiff(x,y) (x) > (y) ? ((x)-(y)):(0xFFFFFFFF-(y)+(x)+1)
+NegoReqchk negoreqchktable[NegochktableSize];
+bool hdd_checkNegoReqFrameSN(u8 *macFrom, u16 negoreq_sn)
+{
+    int i = 0;
+    u32 oldesttime = 0xffffffff;
+    u32 oldestidx = 0;
+    u32 currenttime = adf_os_gettimestamp();
+    static int init_done = 0;
+    if (!init_done) {
+        memset(negoreqchktable,0, sizeof(negoreqchktable));
+        init_done = 1;
+    }
+    //search match peer through all table
+    for (i = 0 ; i < NegochktableSize ; i++) {
+        //let nego request pass only if SN is not equal or over 10 seconds
+        if (vos_mem_compare(&negoreqchktable[i].macFrom, macFrom, 6)) {
+            if ((negoreq_sn != negoreqchktable[i].negoreq_sn) ||
+               (TimeDiff(currenttime,negoreqchktable[i].timestamp)) > (10*1000*1000)) {
+                negoreqchktable[i].negoreq_sn = negoreq_sn;
+                negoreqchktable[i].timestamp = currenttime;
+                return TRUE;
+            }
+            else
+                return FALSE;
+        }
+    }
+
+    //pop the oldest one if no match peer in table
+    for (i = 0 ; i < NegochktableSize ; i++) {
+        if (negoreqchktable[i].timestamp < oldesttime) {
+            oldesttime = negoreqchktable[i].timestamp;
+            oldestidx = i;
+        }
+    }
+    memcpy( negoreqchktable[oldestidx].macFrom, macFrom, 6);
+    negoreqchktable[oldestidx].negoreq_sn = negoreq_sn;
+    negoreqchktable[oldestidx].timestamp = currenttime;
+    return TRUE;
+}
+#endif
 
 void hdd_indicateMgmtFrame( hdd_adapter_t *pAdapter,
                             tANI_U32 nFrameLength,
@@ -2532,6 +2617,17 @@
                 u8 *macFrom = &pbFrames[WLAN_HDD_80211_FRM_DA_OFFSET+6];
                 actionFrmType = pbFrames[WLAN_HDD_PUBLIC_ACTION_FRAME_TYPE_OFFSET];
                 hddLog(LOG1, "Rx Action Frame %u", actionFrmType);
+#ifdef CONFIG_CUST_PLATFORM
+                if (nFrameLength > 23) {
+                     u16 mgmt_sn = (u16) ((pbFrames[23]<<8|pbFrames[22])>>4);
+
+                     if (actionFrmType == WLAN_HDD_GO_NEG_REQ &&
+                          hdd_checkNegoReqFrameSN(macFrom, mgmt_sn) == FALSE) {
+                             printk(KERN_ERR "same SN %d from Peer %pM, drop it\n", mgmt_sn, macFrom);
+                             return;
+                     }
+                }
+#endif
 #ifdef WLAN_FEATURE_P2P_DEBUG
                 if(actionFrmType >= MAX_P2P_ACTION_FRAME_TYPE)
                 {
diff -urN qcacld-new.orig/CORE/HDD/src/wlan_hdd_softap_tx_rx.c qcacld-new/CORE/HDD/src/wlan_hdd_softap_tx_rx.c
--- qcacld-new.orig/CORE/HDD/src/wlan_hdd_softap_tx_rx.c	2016-05-16 10:58:08.718298648 +0800
+++ qcacld-new/CORE/HDD/src/wlan_hdd_softap_tx_rx.c	2016-05-16 10:58:19.010298648 +0800
@@ -547,6 +547,10 @@
 }
 #endif /* QCA_LL_TX_FLOW_CT */
 
+#ifdef CONFIG_CONTX_USB_DEBUG
+extern int txkeeprun;
+extern int txkeepruntoofast;
+#endif
 
 /**============================================================================
   @brief hdd_softap_hard_start_xmit() - Function registered with the Linux OS
@@ -607,6 +611,17 @@
    }
    else
    {
+#ifdef DIRECT_AUDIO_SUPPORT
+	#define DIRECT_AUDIO_LLC_TYPE 0x43FF
+	if (skb->protocol == DIRECT_AUDIO_LLC_TYPE) {
+		struct ethhdr *eth_hdr;
+		STAId = HDD_WLAN_INVALID_STA_ID;
+		eth_hdr = (struct ethhdr *)(skb->data);
+		hdd_softap_GetStaId(pAdapter, (v_MACADDR_t *)eth_hdr->h_dest, &STAId);
+		//STAId = 2; //hack
+	}
+	else
+#endif
   	  STAId = *(v_U8_t *)(((v_U8_t *)(skb->data)) - 1);
       if (STAId == HDD_WLAN_INVALID_STA_ID)
       {
@@ -649,6 +664,12 @@
              (VOS_TIMER_STATE_STOPPED ==
              vos_timer_getCurrentState(&pAdapter->tx_flow_control_timer))) {
           netif_tx_stop_all_queues(dev);
+#ifdef CONFIG_CONTX_USB_DEBUG
+          if (txkeeprun) {
+			  txkeepruntoofast = 1;
+              pr_err("contx too fast, slow down\n");
+          }
+#endif
           vos_timer_start(&pAdapter->tx_flow_control_timer,
                           WLAN_SAP_HDD_TX_FLOW_CONTROL_OS_Q_BLOCK_TIME);
        }
@@ -1827,6 +1848,14 @@
                                  HDD_WAKE_LOCK_DURATION);
 #endif
 
+#ifdef DIRECT_AUDIO_SUPPORT
+#define DIRECT_AUDIO_LLC_TYPE 0x43FF
+	if (skb->protocol == htons(DIRECT_AUDIO_LLC_TYPE)) {
+		extern void SDA_Rx_fun( struct net_device *dev, struct sk_buff *skb);
+		SDA_Rx_fun(pAdapter->dev, skb);
+		return VOS_STATUS_SUCCESS;
+	}
+#endif
 
    rxstat = netif_rx_ni(skb);
    if (NET_RX_SUCCESS == rxstat)
diff -urN qcacld-new.orig/CORE/HDD/src/wlan_hdd_tx_rx.c qcacld-new/CORE/HDD/src/wlan_hdd_tx_rx.c
--- qcacld-new.orig/CORE/HDD/src/wlan_hdd_tx_rx.c	2016-05-16 10:58:08.718298648 +0800
+++ qcacld-new/CORE/HDD/src/wlan_hdd_tx_rx.c	2016-05-16 10:58:19.010298648 +0800
@@ -2163,6 +2163,9 @@
   @return                : VOS_STATUS_E_FAILURE if any errors encountered,
                          : VOS_STATUS_SUCCESS otherwise
   ===========================================================================*/
+#ifdef DIRECT_AUDIO_SUPPORT
+extern void SDA_Rx_fun( struct net_device *dev, struct sk_buff *skb);
+#endif
 VOS_STATUS hdd_rx_packet_cbk(v_VOID_t *vosContext,
                              adf_nbuf_t rxBuf, v_U8_t staId)
 {
@@ -2284,6 +2287,13 @@
                                  HDD_WAKE_LOCK_DURATION);
 #endif
 
+#ifdef DIRECT_AUDIO_SUPPORT
+#define DIRECT_AUDIO_LLC_TYPE 0x43FF
+	if (skb->protocol == htons(DIRECT_AUDIO_LLC_TYPE)) {
+		SDA_Rx_fun(pAdapter->dev, skb);
+		return VOS_STATUS_SUCCESS;
+	}
+#endif
 
    rxstat = netif_rx_ni(skb);
    if (NET_RX_SUCCESS == rxstat)
diff -urN qcacld-new.orig/CORE/HDD/src/wlan_hdd_wext.c qcacld-new/CORE/HDD/src/wlan_hdd_wext.c
--- qcacld-new.orig/CORE/HDD/src/wlan_hdd_wext.c	2016-05-16 10:58:08.738298648 +0800
+++ qcacld-new/CORE/HDD/src/wlan_hdd_wext.c	2016-05-16 10:58:19.014298648 +0800
@@ -247,7 +247,13 @@
 #define WE_PPS_5G_EBT                         83
 #define WE_SET_FW_CRASH_INJECT                84
 #define WE_SET_DIRECT_AUDIO_TEST              85
+#ifdef CONFIG_WLAN_FWLOG_FILE
+#define WE_DBGLOG_FWLOG_FILE_ENABLE           86
+#endif
 #define WE_USB_CONTX_DEBUG			87
+#ifdef CONFIG_WLAN_FWLOG_FILE
+#define WE_DBGLOG_FWLOG_FILE_MAX_SIZE         88
+#endif
 
 
 /* Private ioctls and their sub-ioctls */
@@ -4585,6 +4591,44 @@
 
 /* set param sub-ioctls */
 
+#ifdef DIRECT_AUDIO_SUPPORT
+extern int Direct_Audio_TX_debug(unsigned int usbdbgtxtime);
+extern int Direct_Audio_RX_debug(void);
+#ifdef CONFIG_CONTX_USB_DEBUG
+int txkeeprun=0;
+int txkeepruntoofast=0;
+int txkeepruntoofastseriously=0;
+#define CONTX_LOOP_TIMEMS 20
+int txkeepcountmax=2147483647;
+extern int SDA_CONTX_COUNT_RESET(void);
+extern int SDA_CONTX_COUNT_RESULT(char *, A_UINT8 wait_loop);
+struct work_struct sda_contx_work;
+int init_sda_work=0;
+struct completion completion_usbcontx;
+static void sda_contx_work_item(struct work_struct *work)
+{
+		int transmit_count = txkeepcountmax;
+        while (txkeeprun && transmit_count > 0){
+                Direct_Audio_TX_debug(1);
+                transmit_count -= 32;
+                if (txkeepruntoofast) {
+                        yield();
+                        msleep(30);
+                        txkeepruntoofast = 0;
+                }
+                if (txkeepruntoofastseriously) {
+                        yield();
+                        msleep(1000);
+                        txkeepruntoofastseriously = 0;
+                        pr_err("USB contx run too fast, cause seriously delay\n");
+                }
+
+        }
+        complete(&completion_usbcontx);
+}
+
+#endif /* CONFIG_CONTX_USB_DEBUG */
+#endif /* DIRECT_AUDIO_SUPPORT */
 
 static int iw_setint_getnone(struct net_device *dev, struct iw_request_info *info,
                        union iwreq_data *wrqu, char *extra)
@@ -5559,6 +5603,26 @@
                                           set_value, DBG_CMD);
              break;
         }
+#ifdef CONFIG_WLAN_FWLOG_FILE
+        case WE_DBGLOG_FWLOG_FILE_ENABLE:
+        {
+             hddLog(LOG1, "WE_DBGLOG_FWLOG_FILE_ENABLE val %d", set_value);
+             pHddCtx->fw_log_settings.dl_fwlog_file = set_value;
+             ret = process_wma_set_command((int)pAdapter->sessionId,
+                                          (int)WMI_DBGLOG_FWLOG_FILE_ENABLE,
+                                          set_value, DBG_CMD);
+             break;
+        }
+        case WE_DBGLOG_FWLOG_FILE_MAX_SIZE:
+        {
+             hddLog(LOG1, "WE_DBGLOG_FWLOG_FILE_MAX_SIZE val %d", set_value);
+             pHddCtx->fw_log_settings.dl_fwlog_file_max_size = set_value;
+             ret = process_wma_set_command((int)pAdapter->sessionId,
+                                          (int)WMI_DBGLOG_FWLOG_FILE_MAX_SIZE,
+                                          set_value, DBG_CMD);
+             break;
+        }
+#endif
 
 	case WE_SET_TXRX_FWSTATS:
 	{
@@ -6007,6 +6071,43 @@
 #endif
 #endif
 
+#ifdef DIRECT_AUDIO_SUPPORT
+		case WE_SET_DIRECT_AUDIO_TEST:
+			hddLog(LOGW, "%s: Try Direct_Audiofunction %s\n",
+							__func__, set_value?"TX":"RX");
+			if (set_value) {
+				ret = Direct_Audio_TX_debug(0);
+			}
+			else {
+				ret = Direct_Audio_RX_debug();
+			}
+		break;
+#ifdef CONFIG_CONTX_USB_DEBUG
+		case WE_USB_CONTX_DEBUG:
+			hddLog(LOGW, "%s: USB_CONTX for %d secs 0 to disable\n",
+							__func__, set_value);
+			if (set_value) {
+				/* this part is preset. only works from 9378 USB 2.3 */
+				SDA_CONTX_COUNT_RESET();
+				init_completion(&completion_usbcontx);
+				txkeeprun = 1;
+				if(!init_sda_work) {
+					init_sda_work = 1;
+					INIT_WORK(&sda_contx_work, sda_contx_work_item);
+				}
+				schedule_work(&sda_contx_work);
+			}
+			else {
+				hddLog(LOGW, "%s: USB_CONTX off\n",
+							__func__);
+				txkeeprun = 0;
+				msleep(1000);
+				SDA_CONTX_COUNT_RESULT(NULL, 0);
+			}
+		break;
+
+#endif /* CONFIG_CONTX_USB_DEBUG */
+#endif /* DIRECT_AUDIO_SUPPORT */
 
         default:
         {
@@ -7245,6 +7346,38 @@
         }
 #endif /* FEATURE_OEM_DATA_SUPPORT */
 #endif
+#if defined(CONFIG_CONTX_USB_DEBUG) && defined(DIRECT_AUDIO_SUPPORT)
+		case WE_GET_USB_CONTX_DEBUG:
+		{
+			hddLog(LOGW, "%s: USB_CONTX for 20000 packets\n",
+						__func__);
+
+			SDA_CONTX_COUNT_RESET();
+
+			txkeeprun = 1;
+			txkeepcountmax = 20000;
+			init_completion(&completion_usbcontx);
+
+			if(!init_sda_work) {
+				init_sda_work = 1;
+				INIT_WORK(&sda_contx_work, sda_contx_work_item);
+			}
+
+			schedule_work(&sda_contx_work);
+
+			wait_for_completion_timeout(&completion_usbcontx,
+										msecs_to_jiffies(100000));
+
+			msleep(1000);  //wait for qued data to flush
+			SDA_CONTX_COUNT_RESULT(extra, 10);
+			txkeeprun = 0;
+			txkeepcountmax = 2147483647;
+
+			wrqu->data.length = strnlen(extra, WE_MAX_STR_LEN-1)+1;
+			break;
+	   }
+
+#endif /* CONFIG_CONTX_USB_DEBUG */
 
         default:
         {
@@ -10153,6 +10286,11 @@
 #endif
 #endif
 
+#ifdef DIRECT_AUDIO_SUPPORT
+	{	WE_SET_DIRECT_AUDIO_TEST,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+        0, "aow" },
+#endif
 
     {   WLAN_PRIV_SET_NONE_GET_INT,
         0,
@@ -10785,6 +10923,29 @@
     {   WE_SET_SMPS_PARAM,
         IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2,
         0, "set_smps_param" },
+#ifdef CONFIG_WLAN_FWLOG_FILE
+    {   WE_DBGLOG_FWLOG_FILE_ENABLE,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+        0,
+        "dl_fwlog_file" },
+#endif
+#if CONFIG_CONTX_USB_DEBUG
+	{	WE_USB_CONTX_DEBUG,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+		0,
+		"setusbcontx" },
+    {   WE_GET_USB_CONTX_DEBUG,
+        0,
+        IW_PRIV_TYPE_CHAR| WE_MAX_STR_LEN,
+        "getusbcontx" },
+
+#endif
+#ifdef CONFIG_WLAN_FWLOG_FILE
+    {   WE_DBGLOG_FWLOG_FILE_MAX_SIZE,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+        0,
+        "dl_fwlog_size" },
+#endif
 
 
 };
diff -urN qcacld-new.orig/CORE/MAC/inc/sirApi.h qcacld-new/CORE/MAC/inc/sirApi.h
--- qcacld-new.orig/CORE/MAC/inc/sirApi.h	2016-05-16 10:58:08.890298648 +0800
+++ qcacld-new/CORE/MAC/inc/sirApi.h	2016-05-16 10:58:19.050298648 +0800
@@ -3917,6 +3917,49 @@
     IOCTL_PRIV_SWOW_PULSE_TEST  = 42,//Write of swow_pulse_test
 };
 
+#ifdef WLAN_FEATURE_EXTWOW_OUTDOOR_SUPPORT
+typedef struct
+{
+    tANI_U8 vdev_id;
+
+    tANI_U8  rc4_write_sandbox[256];
+    tANI_U8  rc4_write_x;
+    tANI_U8  rc4_write_y;
+    tANI_U8  rc4_read_sandbox[256];
+    tANI_U8  rc4_read_x;
+    tANI_U8  rc4_read_y;
+    tANI_U8  ssl_write_seq[8];
+    tANI_U8  ssl_read_seq[8];
+    tANI_U8  ssl_sha1_write_key[64];
+    tANI_U16 ssl_sha1_write_key_len;
+    tANI_U8  ssl_sha1_read_key[64];
+    tANI_U16 ssl_sha1_read_key_len;
+
+
+    /** ip header parameter */
+    tANI_U32 ip_id; /* NC id */
+    tANI_U32 ip_device_ip; /* NC IP address */
+    tANI_U32 ip_server_ip; /* Push server IP address */
+
+    /** tcp header parameter */
+    tANI_U16 tcp_src_port; /* NC TCP port */
+    tANI_U16 tcp_dst_port; /* Push server TCP port */
+    tANI_U32 tcp_seq;
+    tANI_U32 tcp_ack_seq;
+    tANI_U32 tcp_options_len;
+    tANI_U8  tcp_options[40];
+    tANI_U32 asyncId;
+
+    tANI_U32 keepalive_init; /* Initial ping interval */
+    tANI_U32 keepalive_min; /* Minimum ping interval */
+    tANI_U32 keepalive_max; /* Maximum ping interval */
+    tANI_U32 keepalive_inc; /* Increment of ping interval */
+
+    tANI_U32 tcp_tx_timeout_val;
+    tANI_U32 tcp_rx_timeout_val;
+    tSirMacAddr gateway_mac;
+} tSirAppType2Params, *tpSirAppType2Params;
+#endif
 #endif
 
 typedef struct sSirWlanSetRxpFilters
diff -urN qcacld-new.orig/CORE/MAC/src/pe/lim/limProcessMessageQueue.c qcacld-new/CORE/MAC/src/pe/lim/limProcessMessageQueue.c
--- qcacld-new.orig/CORE/MAC/src/pe/lim/limProcessMessageQueue.c	2016-05-16 10:58:08.930298648 +0800
+++ qcacld-new/CORE/MAC/src/pe/lim/limProcessMessageQueue.c	2016-05-16 10:58:19.054298648 +0800
@@ -246,11 +246,24 @@
               pMac->lim.gLimPrevMlmState);
         MTRACE(macTraceMsgRx(pMac, NO_SESSION, LIM_TRACE_MAKE_RXMSG(pMsg->type, LIM_MSG_DEFERRED));)
     }
+#ifdef CONFIG_CUST_PLATFORM
+	else if (pMsg->type == SIR_BB_XPORT_MGMT_MSG)
+	{
+		limLog(pMac, LOGW, FL("Dropped lim message (0x%X)"), pMsg->type);
+		MTRACE(macTraceMsgRx(pMac, NO_SESSION, LIM_TRACE_MAKE_RXMSG(pMsg->type, LIM_MSG_DROPPED));)
+	}
+	else
+	{
+		limLog(pMac, LOGE, FL("Dropped lim message (0x%X)"), pMsg->type);
+		MTRACE(macTraceMsgRx(pMac, NO_SESSION, LIM_TRACE_MAKE_RXMSG(pMsg->type, LIM_MSG_DROPPED));)
+	}
+#else
 	else
 	{
 		limLog(pMac, LOGE, FL("Dropped lim message (0x%X)"), pMsg->type);
 		MTRACE(macTraceMsgRx(pMac, NO_SESSION, LIM_TRACE_MAKE_RXMSG(pMsg->type, LIM_MSG_DROPPED));)
 	}
+#endif
     return retCode;
 } /*** end limDeferMsg() ***/
 
diff -urN qcacld-new.orig/CORE/MAC/src/pe/lim/limUtils.c qcacld-new/CORE/MAC/src/pe/lim/limUtils.c
--- qcacld-new.orig/CORE/MAC/src/pe/lim/limUtils.c	2016-05-16 10:58:08.950298648 +0800
+++ qcacld-new/CORE/MAC/src/pe/lim/limUtils.c	2016-05-16 10:58:19.054298648 +0800
@@ -7552,9 +7552,15 @@
         left -= 2;
         if(elem_len > left)
         {
+#ifdef CONFIG_CUST_PLATFORM
+            limLog( pMac, LOGW,
+               FL("****Invalid IEs eid = %d elem_len=%d left=%d*****"),
+                                               elem_id,elem_len,left);
+#else
             limLog( pMac, LOGE,
                FL("****Invalid IEs eid = %d elem_len=%d left=%d*****"),
 								   elem_id,elem_len,left);
+#endif
             return NULL;
         }
         if (SIR_MAC_EID_VENDOR == elem_id)
diff -urN qcacld-new.orig/CORE/SAP/src/sapFsm.c qcacld-new/CORE/SAP/src/sapFsm.c
--- qcacld-new.orig/CORE/SAP/src/sapFsm.c	2016-05-16 10:58:08.738298648 +0800
+++ qcacld-new/CORE/SAP/src/sapFsm.c	2016-05-16 10:58:19.014298648 +0800
@@ -986,6 +986,26 @@
                          pCsrRoamInfo->peerMac,sizeof(tSirMacAddr));
             sapApAppEvent.sapevt.sapStationAssocReassocCompleteEvent.staId = pCsrRoamInfo->staId ;
             sapApAppEvent.sapevt.sapStationAssocReassocCompleteEvent.statusCode = pCsrRoamInfo->statusCode;
+#ifdef CONFIG_CUST_PLATFORM
+            if ((pCsrRoamInfo->assocReqLength > 4) && pCsrRoamInfo->assocReqPtr) {
+                vos_mem_copy(sapApAppEvent.sapevt.sapStationAssocReassocCompleteEvent.ies, pCsrRoamInfo->assocReqPtr + 4,
+                             pCsrRoamInfo->assocReqLength-4);
+                sapApAppEvent.sapevt.sapStationAssocReassocCompleteEvent.iesLen = pCsrRoamInfo->assocReqLength - 4;
+            } else {
+                sapApAppEvent.sapevt.sapStationAssocReassocCompleteEvent.iesLen = pCsrRoamInfo->rsnIELen;
+                vos_mem_copy(sapApAppEvent.sapevt.sapStationAssocReassocCompleteEvent.ies, pCsrRoamInfo->prsnIE,
+                             pCsrRoamInfo->rsnIELen);
+
+                if(pCsrRoamInfo->addIELen)
+                {
+                    v_U8_t  len = sapApAppEvent.sapevt.sapStationAssocReassocCompleteEvent.iesLen;
+                    sapApAppEvent.sapevt.sapStationAssocReassocCompleteEvent.iesLen
+                                                            += pCsrRoamInfo->addIELen;
+                    vos_mem_copy(&sapApAppEvent.sapevt.sapStationAssocReassocCompleteEvent.ies[len], pCsrRoamInfo->paddIE,
+                                 pCsrRoamInfo->addIELen);
+                }
+            }
+#else
             sapApAppEvent.sapevt.sapStationAssocReassocCompleteEvent.iesLen = pCsrRoamInfo->rsnIELen;
             vos_mem_copy(sapApAppEvent.sapevt.sapStationAssocReassocCompleteEvent.ies, pCsrRoamInfo->prsnIE,
                         pCsrRoamInfo->rsnIELen);
@@ -998,6 +1018,7 @@
                 vos_mem_copy(&sapApAppEvent.sapevt.sapStationAssocReassocCompleteEvent.ies[len], pCsrRoamInfo->paddIE,
                             pCsrRoamInfo->addIELen);
             }
+#endif
 
             sapApAppEvent.sapevt.sapStationAssocReassocCompleteEvent.wmmEnabled = pCsrRoamInfo->wmmEnabledSta;
             sapApAppEvent.sapevt.sapStationAssocReassocCompleteEvent.status = (eSapStatus )context;
diff -urN qcacld-new.orig/CORE/SERVICES/BMI/ol_fw.c qcacld-new/CORE/SERVICES/BMI/ol_fw.c
--- qcacld-new.orig/CORE/SERVICES/BMI/ol_fw.c	2016-05-16 10:58:08.822298648 +0800
+++ qcacld-new/CORE/SERVICES/BMI/ol_fw.c	2016-05-16 10:58:19.034298648 +0800
@@ -941,6 +941,203 @@
 A_UINT32 fw_stack_addr;
 void *fw_ram_seg_addr[FW_RAM_SEG_CNT];
 
+#if defined(CONFIG_CRASH_DUMP_CLD) || defined(CONFIG_WLAN_FWLOG_FILE)
+
+#define GET_INODE_FROM_FILEP(filp) ((filp)->f_path.dentry->d_inode)
+
+int _readwrite_file(const char *filename, char *rbuf,
+	const char *wbuf, size_t length, int mode)
+{
+	int ret = 0;
+	struct file *filp = (struct file *)-ENOENT;
+	mm_segment_t oldfs;
+	oldfs = get_fs();
+	set_fs(KERNEL_DS);
+
+	do {
+		filp = filp_open(filename, mode, S_IRUSR);
+
+		if (IS_ERR(filp) || !filp->f_op) {
+			ret = -ENOENT;
+			break;
+		}
+
+		if (!filp->f_op->write || !filp->f_op->read) {
+			filp_close(filp, NULL);
+			ret = -ENOENT;
+			break;
+		}
+
+		if (length == 0) {
+			/* Read the length of the file only */
+			struct inode    *inode;
+
+			inode = GET_INODE_FROM_FILEP(filp);
+			if (!inode) {
+				printk(KERN_ERR
+					"_readwrite_file: Error 2\n");
+				ret = -ENOENT;
+				break;
+			}
+			ret = i_size_read(inode->i_mapping->host);
+			break;
+		}
+
+		if (wbuf) {
+			ret = filp->f_op->write(
+				filp, wbuf, length, &filp->f_pos);
+			if (ret < 0) {
+				printk(KERN_ERR
+					"_readwrite_file: Error 3\n");
+				break;
+			}
+		} else {
+			ret = filp->f_op->read(
+				filp, rbuf, length, &filp->f_pos);
+			if (ret < 0) {
+				printk(KERN_ERR
+					"_readwrite_file: Error 4\n");
+				break;
+			}
+		}
+	} while (0);
+
+	if (!IS_ERR(filp))
+		filp_close(filp, NULL);
+
+	set_fs(oldfs);
+	return ret;
+}
+
+#ifdef CONFIG_CRASH_DUMP_CLD
+#define DUMP_BUF_SIZE 20000 //backtrace + stack size is around 20K
+#define MAX_DUMP_FW_SIZE 100000
+
+#define CRASH_DUMP_FILE "/opt/var/log/cld_fwcrash.log"
+
+
+int check_dump_file_size(void)
+{
+	int status = 0, size = 0;
+	size = _readwrite_file(CRASH_DUMP_FILE, NULL, NULL, 0, O_RDONLY);
+	if (size > (MAX_DUMP_FW_SIZE - DUMP_BUF_SIZE)) {
+
+		printk(KERN_ERR "clean big log 0x%x\n", size);
+		status = _readwrite_file(CRASH_DUMP_FILE, NULL, NULL,
+			0, (O_WRONLY | O_TRUNC));
+	}
+
+	return status;
+}
+
+static int dump_fw_crash_to_file(struct ol_softc *scn)
+{
+	A_UINT32 *reg, pattern, i, start_addr = 0;
+	A_UINT32 MSPId = 0, mSPId = 0, SIId = 0, CRMId = 0, len;
+	A_UINT8 *data;
+	A_UINT32 remaining;
+	char *buf;
+	unsigned int str_len = 0, buf_len = DUMP_BUF_SIZE;
+	int status = 0, dumpcomplete = 0;
+
+	buf = vos_mem_malloc(buf_len);
+
+	if (buf == NULL) {
+		printk(KERN_ERR "No buffer available for crash log\n");
+		return -ENOMEM;
+	}
+
+	memset(buf, 0, buf_len);
+
+	data = scn->hif_sc->fw_data;
+	len = scn->hif_sc->fw_data_len;
+	pattern = *((A_UINT32 *) data);
+
+
+	if (pattern == FW_ASSERT_PATTERN) {
+		MSPId = (scn->target_fw_version & 0xf0000000) >> 28;
+		mSPId = (scn->target_fw_version & 0xf000000) >> 24;
+		SIId = (scn->target_fw_version & 0xf00000) >> 20;
+		CRMId = scn->target_fw_version & 0x7fff;
+		status = check_dump_file_size();
+		if (status)
+			printk(KERN_ERR "crash log file check status code 0x%x\n", status);
+		str_len = scnprintf(buf + str_len, buf_len - str_len, "Host SW version: %s\n", hdd_get_version_string());
+		str_len += scnprintf(buf + str_len, buf_len - str_len, "FW version: %d.%d.%d.%d\n", MSPId, mSPId, SIId, CRMId);
+		pr_err("Host SW version: %s\n", hdd_get_version_string());
+		pr_err("FW version: %d.%d.%d.%d", MSPId, mSPId, SIId, CRMId);
+		if (vos_is_load_unload_in_progress(VOS_MODULE_ID_VOSS, NULL)) {
+			printk(KERN_INFO "%s: Loading/Unloading is in progress, ignore!\n",
+				__func__);
+			vos_mem_free(buf);
+			return 0;
+		}
+		reg = (A_UINT32 *) (data + 4);
+		for (i = 0; i < min_t(A_UINT32, len - 4, FW_REG_DUMP_CNT); i += 4) {
+			A_UINT8 temp_buf[128];
+			hex_dump_to_buffer(reg+i, 16, 16, 4, temp_buf, sizeof(temp_buf), false);
+			str_len += snprintf(buf + str_len, buf_len - str_len, "%#08x: %s\n", i*4, temp_buf);
+		}
+		print_hex_dump(KERN_DEBUG, " ", DUMP_PREFIX_OFFSET, 16, 4, reg,
+				min_t(A_UINT32, len - 4, FW_REG_DUMP_CNT * 4),
+				false);
+		scn->fw_ram_dumping = 0;
+
+		if (scn->enableFwSelfRecovery)
+			vos_set_logp_in_progress(VOS_MODULE_ID_VOSS, TRUE);
+	}
+#ifdef CONFIG_CRASH_DUMP_STACK
+	else if (pattern == FW_REG_PATTERN) {
+		reg = (A_UINT32 *) (data + 4);
+		start_addr = *reg++;
+		if (scn->fw_ram_dumping == 0) {
+			str_len += scnprintf(buf + str_len, buf_len - str_len, "Firmware stack dump:\n");
+			pr_err("Firmware stack dump:");
+			scn->fw_ram_dumping = 1;
+			fw_stack_addr = start_addr;
+		}
+		remaining = len - 8;
+		/* len is in byte, but it's printed in double-word. */
+		for (i = 0; i < (len - 8); i += 16) {
+			A_UINT8 temp_buf[128];
+			if ((*reg == FW_REG_END_PATTERN) && (i == len - 12)) {
+				scn->fw_ram_dumping = 0;
+				str_len += scnprintf(buf + str_len, buf_len - str_len, "Stack start address = %#08x\n",
+					fw_stack_addr);
+				pr_err("Stack start address = %#08x\n",
+					fw_stack_addr);
+				dumpcomplete = 1;
+                          	pr_err("F/W crash log dump completed\n");
+				break;
+			}
+			hex_dump_to_buffer(reg, remaining, 16, 4, temp_buf,
+						sizeof(temp_buf), false);
+			str_len += scnprintf(buf + str_len, buf_len - str_len, "%#08x: %s\n", start_addr + i, temp_buf);
+			pr_err("%#08x: %s\n", start_addr + i, temp_buf);
+			remaining -= 16;
+			reg += 4;
+		}
+	}
+#endif
+	status = _readwrite_file(CRASH_DUMP_FILE, NULL,
+			buf, str_len, (O_WRONLY | O_APPEND | O_CREAT));
+	if (status < 0)
+		printk(KERN_ERR "write failed with status code 0x%x\n", status);
+
+	if (dumpcomplete) {
+		if (vos_is_logp_in_progress(VOS_MODULE_ID_VOSS, NULL)) {
+				/* dispatch 'offline' uevent after FWDump */
+				A_MSLEEP(1500);
+				kobject_uevent(&scn->adf_dev->dev->kobj, KOBJ_OFFLINE);
+				vos_set_logp_in_progress(VOS_MODULE_ID_VOSS, FALSE);
+		}
+	}
+
+	vos_mem_free(buf);
+	return status;
+}
+#endif
+#endif
 
 
 /* ol_ramdump_handler is to receive information of firmware crash dump, and
@@ -957,6 +1154,12 @@
  *            of the last packet is FW_RAMDUMP_END_PATTERN;
  * IRAM dump and AXI dump are with the same format as DRAM dump.
  */
+#ifdef CONFIG_CRASH_DUMP_CLD
+void ol_ramdump_handler(struct ol_softc *scn)
+{
+	dump_fw_crash_to_file(scn);
+}
+#else
 void ol_ramdump_handler(struct ol_softc *scn)
 {
 	A_UINT32 *reg, pattern, i, start_addr = 0;
@@ -1063,6 +1266,7 @@
 		}
 	}
 }
+#endif /* CONFIG_CRASH_DUMP_CLD */
 #endif
 
 #define REGISTER_DUMP_LEN_MAX   60
diff -urN qcacld-new.orig/CORE/SERVICES/COMMON/adf/adf_nbuf.c qcacld-new/CORE/SERVICES/COMMON/adf/adf_nbuf.c
--- qcacld-new.orig/CORE/SERVICES/COMMON/adf/adf_nbuf.c	2016-05-16 10:58:08.754298648 +0800
+++ qcacld-new/CORE/SERVICES/COMMON/adf/adf_nbuf.c	2016-05-16 10:58:19.026298648 +0800
@@ -94,6 +94,9 @@
      */
     skb_reserve(skb, reserve);
 
+#ifdef CONFIG_CUST_PLATFORM
+	skb->next=NULL;
+#endif
 
     return skb;
 }
diff -urN qcacld-new.orig/CORE/SERVICES/COMMON/dbglog_host.h qcacld-new/CORE/SERVICES/COMMON/dbglog_host.h
--- qcacld-new.orig/CORE/SERVICES/COMMON/dbglog_host.h	2016-05-16 10:58:08.754298648 +0800
+++ qcacld-new/CORE/SERVICES/COMMON/dbglog_host.h	2016-05-16 10:58:19.026298648 +0800
@@ -185,6 +185,15 @@
 int
 dbglog_report_enable(wmi_unified_t  wmi_handle, A_BOOL isenable);
 
+#ifdef CONFIG_WLAN_FWLOG_FILE
+/** Enable write fwlog into a file */
+int
+dbglog_fwlog_file_enable(wmi_unified_t  wmi_handle, A_BOOL isenable);
+
+/** set max size of fwlog file */
+int
+dbglog_fwlog_file_max_size (wmi_unified_t  wmi_handle, A_UINT32 size);
+#endif
 /** Set the log level
 * @brief DBGLOG_INFO - Information lowest log level
 * @brief DBGLOG_WARNING
diff -urN qcacld-new.orig/CORE/SERVICES/COMMON/osapi_linux.h qcacld-new/CORE/SERVICES/COMMON/osapi_linux.h
--- qcacld-new.orig/CORE/SERVICES/COMMON/osapi_linux.h	2016-05-16 10:58:08.766298648 +0800
+++ qcacld-new/CORE/SERVICES/COMMON/osapi_linux.h	2016-05-16 10:58:19.026298648 +0800
@@ -139,10 +139,19 @@
 #endif
 #define A_PRINTF(args...) A_ANDROID_PRINTF(ATH_DEBUG_INFO, NULL, "ar6k_driver", args)
 #else
+#ifdef CONFIG_CUST_PLATFORM
+#define A_LOGGER(mask, mod, args...)    printk(KERN_ERR args)
+#define A_PRINTF(args...)               printk(KERN_ERR args)
+#else
 #define A_LOGGER(mask, mod, args...)    printk(args)
 #define A_PRINTF(args...)               printk(args)
+#endif
 #endif /* ANDROID */
+#ifdef CONFIG_CUST_PLATFORM
+#define A_PRINTF_LOG(args...)           printk(KERN_ERR args)
+#else
 #define A_PRINTF_LOG(args...)           printk(args)
+#endif
 #define A_SNPRINTF(buf, len, args...)	snprintf (buf, len, args)
 
 /* Mutual Exclusion */
diff -urN qcacld-new.orig/CORE/SERVICES/HIF/USB/if_usb.c qcacld-new/CORE/SERVICES/HIF/USB/if_usb.c
--- qcacld-new.orig/CORE/SERVICES/HIF/USB/if_usb.c	2016-05-16 10:58:08.822298648 +0800
+++ qcacld-new/CORE/SERVICES/HIF/USB/if_usb.c	2016-05-16 10:58:19.034298648 +0800
@@ -118,6 +118,37 @@
 	return NOTIFY_DONE;
 }
 
+#ifdef CONFIG_CUST_PLATFORM
+static int ssvd_disable_micom_reset(void)
+{
+	const char cmd=0x36, ack=0x36;
+	const int len=4;
+	char data[4]={0, 9, 1, 0};
+	int ret, cnt=0;
+	const struct kernel_symbol *sym = NULL;
+	int (*micom_fn)(char cmd, char ack, char *data, int len);
+
+	printk(KERN_ERR "%s\n", __func__);
+
+	sym = find_symbol("sdp_micom_send_cmd_ack", NULL, NULL, 1, true);
+
+	if (sym) {
+		micom_fn = (void*)sym->value;
+	} else {
+		printk(KERN_ERR "[%s] there is no micom driver\n", __func__ );
+		return -1;
+	}
+	do {
+		ret = micom_fn(cmd, ack, data, len);
+		if(ret) {
+			printk( KERN_ERR "%s : Send msg fail(cnt=%d)\n", __func__, cnt );
+			msleep( 50 );
+		}
+		cnt++;
+	} while(ret && (cnt < 3));
+	return ret;
+}
+#endif
 
 static int
 hif_usb_probe(struct usb_interface *interface, const struct usb_device_id *id)
@@ -214,6 +245,10 @@
 	register_reboot_notifier(&sc->reboot_notifier);
 
 	usb_sc = sc;
+#ifdef CONFIG_CUST_PLATFORM
+	if (ssvd_disable_micom_reset())
+		pr_err ("%s: failed to disable micom reset\n",__func__);
+#endif
 	return 0;
 
 err_config:
diff -urN qcacld-new.orig/CORE/SERVICES/WMA/regdomain_common.h qcacld-new/CORE/SERVICES/WMA/regdomain_common.h
--- qcacld-new.orig/CORE/SERVICES/WMA/regdomain_common.h	2016-05-16 10:58:08.790298648 +0800
+++ qcacld-new/CORE/SERVICES/WMA/regdomain_common.h	2016-05-16 10:58:19.030298648 +0800
@@ -100,6 +100,9 @@
     FCC4_FCCA   = 0x12,     /* USA - Public Safety */
     FCC5_FCCA   = 0x13,     /* US with no DFS (UNII-1 + UNII-3 Only)*/
     FCC6_FCCA   = 0x14,     /* Canada for AP only*/
+#ifdef SS_REGULATORY
+    FCC5_WORLD  = 0x15,
+#endif /* SS_REGULATORY */
 
     FCC2_FCCA   = 0x20,     /* Canada */
     FCC2_WORLD  = 0x21,     /* Australia & HK */
@@ -216,6 +219,9 @@
     MKK12_MKKA2 = 0xDD,     /* Japan UNI-1 even + UNI-1 odd + UNI-2 + mid-band + 4.9GHz + MKKA2 */
 
     MKK13_MKKB  = 0xDE,     /* Japan UNI-1 even + UNI-1 odd + UNI-2 + mid-band + MKKB + All passive + no adhoc */
+#ifdef SS_REGULATORY
+    MKK5_MKKA	= 0XDF,
+#endif /* SS_REGULATORY */
 
     /* Following definitions are used only by s/w to map old
      * Japan SKUs.
@@ -345,6 +351,9 @@
 	{FCC3_ETSIC,    FCC3,		ETSIC,		NO_REQ, NO_REQ, PSCAN_DEFER, 0 },
 	{FCC4_FCCA,     FCC4,		FCCA,		DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB, NO_REQ, PSCAN_DEFER, 0 },
 	{FCC5_FCCA,     FCC5,		FCCA,		NO_REQ, NO_REQ, PSCAN_DEFER, 0 },
+#ifdef SS_REGULATORY
+	{FCC5_WORLD,    FCC5,		WORLD,		NO_REQ, NO_REQ, PSCAN_DEFER, 0 },
+#endif /* SS_REGULATORY */
 	{FCC6_FCCA,     FCC6,		FCCA,		NO_REQ, NO_REQ, PSCAN_DEFER, 0 },
 	{FCC6_WORLD,    FCC6,		WORLD,		NO_REQ, NO_REQ, PSCAN_DEFER, 0 },
 
@@ -405,6 +414,9 @@
 	{MKK4_FCCA,     MKK4,           FCCA,           DISALLOW_ADHOC_11A_TURB | NEED_NFC | LIMIT_FRAME_4MS, NEED_NFC, PSCAN_MKK3, CTRY_JAPAN29 },
 
 	/* MKK5 */
+#ifdef SS_REGULATORY
+	{MKK5_MKKA, MKK5,       MKKA,       DISALLOW_ADHOC_11A_TURB | NEED_NFC | LIMIT_FRAME_4MS, NEED_NFC, PSCAN_MKK3, CTRY_JAPAN56 },
+#endif /* SS_REGULATORY */
 	{MKK5_MKKB,	MKK5,		MKKA,		DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB | NEED_NFC | LIMIT_FRAME_4MS, NEED_NFC, PSCAN_MKK3 | PSCAN_MKKA | PSCAN_MKKA_G, CTRY_JAPAN13 },
 	{MKK5_MKKA2,MKK5,		MKKA,		DISALLOW_ADHOC_11A_TURB | NEED_NFC | LIMIT_FRAME_4MS, NEED_NFC, PSCAN_MKK3 | PSCAN_MKKA2 | PSCAN_MKKA2_G, CTRY_JAPAN14 },
 	{MKK5_MKKC,	MKK5,		MKKC,		DISALLOW_ADHOC_11A_TURB | NEED_NFC | LIMIT_FRAME_4MS, NEED_NFC, PSCAN_MKK3, CTRY_JAPAN15 },
@@ -670,6 +682,41 @@
     {CTRY_YEMEN,       NULL1_WORLD,   "YE", "YEMEN",          YES,  NO, YES, YES, YES,  NO,  NO, NO, 7000 },
     {CTRY_ZIMBABWE,    NULL1_WORLD,   "ZW", "ZIMBABWE",       YES,  NO, YES, YES, YES,  NO,  NO, NO, 7000 },
 
+#ifdef SS_REGULATORY
+	/*11g, ATu,	GTu, G20, G40, A20, A40, A80*/
+	{CTRY_QM,	NULL1_ETSIB,	"QM", "SS A",       	  YES,  NO, YES, YES,  NO,  NO,  NO,  NO, 7000 },//NO 5G
+	{CTRY_QN,	FCC3_WORLD,		"QN", "SS B",       	  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_QO,	ETSI8_WORLD,	"QO", "SS C", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_QP,	APL10_WORLD,	"QP", "SS D", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_QQ,	ETSI1_WORLD,	"QQ", "SS E", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_QR,	FCC1_WORLD,		"QR", "SS F", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_QS,	FCC2_ETSIC,		"QS", "SS G", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_QT,	ETSI3_WORLD,	"QT", "SS H", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_QU,	ETSI5_WORLD,	"QU", "SS I", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_QV,	APL4_WORLD,		"QV", "SS J", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_QW,	APL5_WORLD,		"QW", "SS K", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_QX,	FCC4_FCCA,		"QX", "SS L", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_QY,	FCC6_WORLD,		"QY", "SS M", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_QZ,	APL2_WORLD,		"QZ", "SS N", 		  YES, YES, YES, YES, YES, YES, YES,  NO, 7000 },//NO AC80
+	{CTRY_XA,	APL9_WORLD,		"XA", "SS O", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XB,	APL8_WORLD,		"XB", "SS P", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XC,	ETSI9_WORLD,	"XC", "SS Q", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XD,	FCC5_WORLD,		"XD", "SS R", 		  YES, YES, YES, YES, YES, YES, YES,  NO, 7000 },//NO AC80
+	{CTRY_XE,	APL6_WORLD,		"XE", "SS S", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XF,	MKK5_MKKA,		"XF", "SS T", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XG,	MKK11_FCCA,		"XG", "SS U", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XH,	MKK15_MKKA1,	"XH", "SS V", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XI,	APL3_WORLD,		"XI", "SS W", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XJ,	FCC6_FCCA,		"XJ", "SS X", 		   NO, YES,  NO,  NO,  NO, YES, YES,  NO, 7000 },//No 2G, NO AC80
+	{CTRY_XK,	APL7_FCCA,		"XK", "SS Y", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XL,	ETSI2_WORLD,	"XL", "SS Z", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XM,	ETSI6_WORLD,	"XM", "SS AA", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XN,	ETSI4_WORLD,	"XN", "SS AB", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XO,	WOR3_WORLD,		"XO", "SS AC", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XP,	WOR01_WORLD,	"XP", "SS AD", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XQ,	WOR02_WORLD,	"XQ", "SS AE", 		  YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
+	{CTRY_XR,	WOR4_WORLD,		"XR", "SS AF", 		  YES, YES, YES, YES, YES, YES, YES,  NO, 7000 },//NO AC80
+#endif /* SS_REGULATORY */
 
 };
 
diff -urN qcacld-new.orig/CORE/SERVICES/WMA/regdomain.h qcacld-new/CORE/SERVICES/WMA/regdomain.h
--- qcacld-new.orig/CORE/SERVICES/WMA/regdomain.h	2016-05-16 10:58:08.790298648 +0800
+++ qcacld-new/CORE/SERVICES/WMA/regdomain.h	2016-05-16 10:58:19.030298648 +0800
@@ -1089,6 +1089,40 @@
     CTRY_AUSTRALIA2           = 5000,    /* Australia for AP only */
     CTRY_CANADA2              = 5001,    /* Canada for AP only */
     CTRY_BELGIUM2             = 5002,    /* Belgium/Cisco implementation */
+#ifdef SS_REGULATORY
+    CTRY_QM             	  = 5003,   /* customer_1_spec */
+    CTRY_QN             	  = 5004,   /* customer_1_spec */
+    CTRY_QO             	  = 5005,   /* customer_1_spec */
+    CTRY_QP             	  = 5006,   /* customer_1_spec */
+    CTRY_QQ             	  = 5007,   /* customer_1_spec */
+    CTRY_QR             	  = 5008,   /* customer_1_spec */
+    CTRY_QS             	  = 5009,   /* customer_1_spec */
+    CTRY_QT             	  = 5010,   /* customer_1_spec */
+    CTRY_QU             	  = 5011,   /* customer_1_spec */
+    CTRY_QV             	  = 5012,   /* customer_1_spec */
+    CTRY_QW             	  = 5013,   /* customer_1_spec */
+    CTRY_QX             	  = 5014,   /* customer_1_spec */
+    CTRY_QY             	  = 5015,   /* customer_1_spec */
+    CTRY_QZ             	  = 5016,   /* customer_1_spec */
+    CTRY_XA             	  = 5017,   /* customer_1_spec */
+    CTRY_XB             	  = 5018,   /* customer_1_spec */
+    CTRY_XC             	  = 5019,  	/* customer_1_spec */
+    CTRY_XD            	  	  = 5020,	/* customer_1_spec */
+    CTRY_XE             	  = 5021, 	/* customer_1_spec */
+    CTRY_XF             	  = 5022, 	/* customer_1_spec */
+    CTRY_XG             	  = 5023, 	/* customer_1_spec */
+    CTRY_XH             	  = 5024, 	/* customer_1_spec */
+    CTRY_XI             	  = 5025, 	/* customer_1_spec */
+    CTRY_XJ             	  = 5026,	/* customer_1_spec */
+    CTRY_XK             	  = 5027, 	/* customer_1_spec */
+    CTRY_XL             	  = 5028, 	/* customer_1_spec */
+    CTRY_XM             	  = 5029, 	/* customer_1_spec */
+    CTRY_XN             	  = 5030, 	/* customer_1_spec */
+    CTRY_XO             	  = 5031, 	/* customer_1_spec */
+    CTRY_XP             	  = 5032, 	/* customer_1_spec */
+    CTRY_XQ             	  = 5033, 	/* customer_1_spec */
+    CTRY_XR             	  = 5034, 	/* customer_1_spec */
+#endif /* SS_REGULATORY */
 };
 int32_t regdmn_get_country_alpha2(struct regulatory *reg);
 void regdmn_set_regval(struct regulatory *reg);
diff -urN qcacld-new.orig/CORE/SERVICES/WMA/wma.c qcacld-new/CORE/SERVICES/WMA/wma.c
--- qcacld-new.orig/CORE/SERVICES/WMA/wma.c	2016-05-16 10:58:08.806298648 +0800
+++ qcacld-new/CORE/SERVICES/WMA/wma.c	2016-05-16 10:58:19.034298648 +0800
@@ -1549,6 +1549,10 @@
 	WMA_LOGD("%s: vdev_id %d type %d Wakeup_pin_num %x",
 		 __func__, cmd->vdev_id,
 		 cmd->type, cmd->wakeup_pin_num);
+#ifdef CONFIG_CUST_PLATFORM
+	printk(KERN_ERR "SWOW: vdev_id %d type %d Wakeup_pin_num %x pulsetest:%u %u",
+		 cmd->vdev_id, cmd->type, cmd->wakeup_pin_num, cmd->swol_pulsetest_type, cmd->swol_pulsetest_application);
+#endif
 
 	ret = wmi_unified_cmd_send(wma->wmi_handle, buf, len,
 				   WMI_EXTWOW_ENABLE_CMDID);
@@ -1610,6 +1614,28 @@
 			 "password %.16s pass_length %u",
 		__func__, cmd->vdev_id, cmd->ident, cmd->ident_len,
 		cmd->passwd, cmd->passwd_len);
+#ifdef CONFIG_CUST_PLATFORM
+	printk(KERN_ERR "SWOW: vdev_id %d "
+                         "identification_id %.8s id_length %u "
+                         "password %.16s pass_length %u"
+                         "waker filter:%u passwd filter:%u pattern:%u exception:%u exception_app:%u\n",
+		cmd->vdev_id, cmd->ident, cmd->ident_len,
+		cmd->passwd, cmd->passwd_len,
+		cmd->swol_indoor_waker_check,
+		cmd->swol_indoor_pw_check,
+		cmd->swol_indoor_pattern,
+		cmd->swol_indoor_exception,
+		cmd->swol_indoor_exception_app);
+	for (i = 0; i < 8; i++) {
+		printk(KERN_ERR "Waker [%d] %08x%08x %s(%u) 0x%x\n",
+			i,
+			cmd->swol_indoor_key_mac[i].mac_addr47to32,
+			cmd->swol_indoor_key_mac[i].mac_addr31to0,
+			cmd->swol_indoor_key[i],
+			cmd->swol_indoor_key_len[i],
+			cmd->swol_indoor_app_mask[i]);
+	}
+#endif
 
 	ret = wmi_unified_cmd_send(wma->wmi_handle, buf, len,
 				   WMI_EXTWOW_SET_APP_TYPE1_PARAMS_CMDID);
@@ -1622,6 +1648,93 @@
 	return VOS_STATUS_SUCCESS;
 }
 
+#ifdef WLAN_FEATURE_EXTWOW_OUTDOOR_SUPPORT
+static int wma_set_app_type2_params_in_fw(tp_wma_handle wma,
+			 tpSirAppType2Params appType2Params)
+{
+	wmi_extwow_set_app_type2_params_cmd_fixed_param *cmd;
+	wmi_buf_t buf;
+	int32_t len;
+	int ret;
+
+	len = sizeof(wmi_extwow_set_app_type2_params_cmd_fixed_param);
+	buf = wmi_buf_alloc(wma->wmi_handle, len);
+	if (!buf) {
+		WMA_LOGE("%s: Failed allocate wmi buffer", __func__);
+		return VOS_STATUS_E_NOMEM;
+	}
+
+	cmd = (wmi_extwow_set_app_type2_params_cmd_fixed_param *)
+						    wmi_buf_data(buf);
+
+	WMITLV_SET_HDR(&cmd->tlv_header,
+             WMITLV_TAG_STRUC_wmi_extwow_set_app_type2_params_cmd_fixed_param,
+             WMITLV_GET_STRUCT_TLVLEN(
+			wmi_extwow_set_app_type2_params_cmd_fixed_param));
+
+	cmd->vdev_id = appType2Params->vdev_id;
+
+	vos_mem_copy(cmd->rc4_write_sandbox, appType2Params->rc4_write_sandbox, 256);
+	vos_mem_copy(cmd->rc4_read_sandbox, appType2Params->rc4_read_sandbox, 256);
+	vos_mem_copy(cmd->ssl_write_seq, appType2Params->ssl_write_seq, 8);
+	vos_mem_copy(cmd->ssl_read_seq, appType2Params->ssl_read_seq, 8);
+	vos_mem_copy(cmd->ssl_sha1_write_key, appType2Params->ssl_sha1_write_key, 64);
+	vos_mem_copy(cmd->ssl_sha1_read_key, appType2Params->ssl_sha1_read_key, 64);
+	cmd->rc4_write_x = appType2Params->rc4_write_x;
+	cmd->rc4_write_y = appType2Params->rc4_write_y;
+	cmd->rc4_read_x = appType2Params->rc4_read_x;
+	cmd->rc4_read_y = appType2Params->rc4_read_y;
+	cmd->ssl_sha1_write_key_len = appType2Params->ssl_sha1_write_key_len;
+	cmd->ssl_sha1_read_key_len = appType2Params->ssl_sha1_read_key_len;
+	cmd->tcp_options_len =  appType2Params->tcp_options_len;
+	vos_mem_copy(cmd->tcp_options, appType2Params->tcp_options, sizeof(cmd->tcp_options));
+	cmd->asyncId = appType2Params->asyncId;
+
+	cmd->ip_id = appType2Params->ip_id;
+	cmd->ip_device_ip = appType2Params->ip_device_ip;
+	cmd->ip_server_ip = appType2Params->ip_server_ip;
+
+	cmd->tcp_src_port = appType2Params->tcp_src_port;
+	cmd->tcp_dst_port = appType2Params->tcp_dst_port;
+	cmd->tcp_seq = appType2Params->tcp_seq;
+	cmd->tcp_ack_seq = appType2Params->tcp_ack_seq;
+
+	cmd->keepalive_init = appType2Params->keepalive_init;
+	cmd->keepalive_min = appType2Params->keepalive_min;
+	cmd->keepalive_max = appType2Params->keepalive_max;
+	cmd->keepalive_inc = appType2Params->keepalive_inc;
+
+	WMI_CHAR_ARRAY_TO_MAC_ADDR(appType2Params->gateway_mac,
+						&cmd->gateway_mac);
+	cmd->tcp_tx_timeout_val = appType2Params->tcp_tx_timeout_val;
+	cmd->tcp_rx_timeout_val = appType2Params->tcp_rx_timeout_val;
+
+	WMA_LOGD("%s: vdev_id %d gateway_mac %pM "
+			 "ip_id %x ip_device_ip %x ip_server_ip %x "
+			 "tcp_src_port %u tcp_dst_port %u tcp_seq %u "
+			 "tcp_ack_seq %u tcp_options_len %u keepalive_init %u keepalive_min %u "
+			 "keepalive_max %u keepalive_inc %u "
+			 "tcp_tx_timeout_val %u tcp_rx_timeout_val %u",
+		__func__, cmd->vdev_id, appType2Params->gateway_mac,
+		cmd->ip_id, cmd->ip_device_ip, cmd->ip_server_ip,
+		cmd->tcp_src_port, cmd->tcp_dst_port, cmd->tcp_seq,
+		cmd->tcp_ack_seq, cmd->tcp_options_len, cmd->keepalive_init, cmd->keepalive_min,
+		cmd->keepalive_max, cmd->keepalive_inc,
+		cmd->tcp_tx_timeout_val, cmd->tcp_rx_timeout_val);
+
+
+	ret = wmi_unified_cmd_send(wma->wmi_handle, buf, len,
+				   WMI_EXTWOW_SET_APP_TYPE2_PARAMS_CMDID);
+	if (ret) {
+		WMA_LOGE("%s: Failed to set APP TYPE2 PARAMS", __func__);
+		wmi_buf_free(buf);
+		return VOS_STATUS_E_FAILURE;
+	}
+
+	return VOS_STATUS_SUCCESS;
+
+}
+#endif
 #endif
 static void wma_update_pdev_stats(tp_wma_handle wma,
 					wmi_pdev_stats *pdev_stats)
@@ -10603,6 +10716,20 @@
 				WMA_LOGE("dbglog_report_enable"
 						" failed ret %d", ret);
 			break;
+#ifdef CONFIG_WLAN_FWLOG_FILE
+		case WMI_DBGLOG_FWLOG_FILE_ENABLE:
+                        ret = dbglog_fwlog_file_enable(wma->wmi_handle, privcmd->param_value);
+			if (ret)
+				WMA_LOGE("dbglog_fwlog_file_enable"
+						" failed ret %d", ret);
+			break;
+                case WMI_DBGLOG_FWLOG_FILE_MAX_SIZE:
+                        ret = dbglog_fwlog_file_max_size(wma->wmi_handle, privcmd->param_value);
+                        if (ret)
+                                WMA_LOGE("dbglog_fwlog_file_max_size"
+                                                " failed ret %d", ret);
+                        break;
+#endif
 #ifdef FEATURE_GREEN_AP
 		case WMI_PDEV_GREEN_AP_PS_ENABLE_CMDID:
 			/* Set the Green AP */
@@ -17125,6 +17252,44 @@
 	return VOS_STATUS_SUCCESS;
 }
 
+#ifdef CONFIG_CUST_PLATFORM
+static int ssvd_micom_wlan_reset(void)
+{
+	const char cmd = 0xb3, ack = 0xb3;
+	const int len = 5;
+	char pull_low[5] = {6, };
+	char pull_high[5] = {10, };
+	int ret, cnt = 0;
+
+	const struct kernel_symbol *sym = NULL;
+	int (*micom_fn)(char cmd, char ack, char *data, int len);
+
+	printk(KERN_ERR "%s\n", __func__);
+
+	sym = find_symbol("sdp_micom_send_cmd_ack", NULL, NULL, 1, true);
+
+	if (sym) {
+		micom_fn = (void*)sym->value;
+	} else {
+		printk(KERN_ERR "[%s] there is no micom driver\n", __func__ );
+		return -1;
+	}
+
+	do {
+		ret = micom_fn(cmd, ack, pull_low, len);
+		if(ret) {
+			printk( KERN_ERR "%s : Send micom wlan reset pull low msg fail(cnt=%d)\n", __func__, cnt );
+		}
+		msleep( 500 );
+		ret = micom_fn(cmd, ack, pull_high, len);
+		if(ret) {
+			printk( KERN_ERR "%s : Send micom wlan reset pull high msg fail(cnt=%d)\n", __func__, cnt );
+		}
+		cnt++;
+	} while(ret && (cnt < 3));
+	return ret;
+}
+#endif
 
 /*
  * Sends host wakeup indication to FW. On receiving this indication,
@@ -17177,9 +17342,16 @@
 #ifndef CONFIG_CUST_PLATFORM
 			struct hif_usb_softc *sc = scn->hif_sc;
 #endif
+#ifdef CONFIG_CUST_PLATFORM
+			printk(KERN_ERR "%s logp not in progress try ssr\n", __func__);
+#else
 			VOS_BUG(0);
+#endif
 			wmi_set_target_resumeok(wma->wmi_handle, FALSE);
                         //do COLD Reset first
+#ifdef CONFIG_CUST_PLATFORM
+			ssvd_micom_wlan_reset();
+#endif
 			if (scn) {
 #ifndef CONFIG_CUST_PLATFORM
 				if (sc) {
@@ -21579,6 +21751,13 @@
 				(tSirAppType1Params *)msg->bodyptr);
 			vos_mem_free(msg->bodyptr);
 			break;
+#ifdef WLAN_FEATURE_EXTWOW_OUTDOOR_SUPPORT
+		case WDA_WLAN_SET_APP_TYPE2_PARAMS:
+			wma_set_app_type2_params_in_fw(wma_handle,
+				(tSirAppType2Params *)msg->bodyptr);
+			vos_mem_free(msg->bodyptr);
+			break;
+#endif
 #endif
 		case WDA_VDEV_START_RSP_IND:
 			wma_vdev_start_rsp_ind(wma_handle, msg->bodyptr);
@@ -24810,9 +24989,16 @@
 #ifndef CONFIG_CUST_PLATFORM
 			struct hif_usb_softc *sc = scn->hif_sc;
 #endif
+#ifdef CONFIG_CUST_PLATFORM
+			printk(KERN_ERR "%s logp not in progress try ssr\n", __func__);
+#else
 			VOS_BUG(0);
+#endif
 			wmi_set_target_resumeok(wma_handle->wmi_handle, FALSE);
 			//trigger SSR
+#ifdef CONFIG_CUST_PLATFORM
+			ssvd_micom_wlan_reset();
+#endif
 			if (scn) {
                 //do COLD Reset first
 #ifndef CONFIG_CUST_PLATFORM
diff -urN qcacld-new.orig/CORE/SERVICES/WMA/wma.h qcacld-new/CORE/SERVICES/WMA/wma.h
--- qcacld-new.orig/CORE/SERVICES/WMA/wma.h	2016-05-16 10:58:08.790298648 +0800
+++ qcacld-new/CORE/SERVICES/WMA/wma.h	2016-05-16 10:58:19.026298648 +0800
@@ -77,7 +77,11 @@
 
 /** Private **/
 #define WMA_CFG_NV_DNLD_TIMEOUT            500
+#ifdef CONFIG_CUST_PLATFORM
+#define WMA_READY_EVENTID_TIMEOUT          15000
+#else
 #define WMA_READY_EVENTID_TIMEOUT          2000
+#endif
 #define WMA_TGT_SUSPEND_COMPLETE_TIMEOUT   1000
 #define WMA_WAKE_LOCK_TIMEOUT              1000
 #define WMA_MAX_RESUME_RETRY               1000
diff -urN qcacld-new.orig/CORE/SME/inc/csrApi.h qcacld-new/CORE/SME/inc/csrApi.h
--- qcacld-new.orig/CORE/SME/inc/csrApi.h	2016-05-16 10:58:08.746298648 +0800
+++ qcacld-new/CORE/SME/inc/csrApi.h	2016-05-16 10:58:19.018298648 +0800
@@ -1366,6 +1366,10 @@
     tSirAddie            addIE;           // Additional IE received from peer, which can be WSC and/or P2P IE
     tANI_U8              reassocReq;      //set to true if reassoc
     tANI_U8              timingMeasCap;
+#ifdef CONFIG_CUST_PLATFORM
+    tANI_U32             assocReqLength;
+    tANI_U8              assocReqPtr[SIR_MAC_MAX_IE_LENGTH*4];
+#endif
 } tSirSmeAssocIndToUpperLayerCnf, *tpSirSmeAssocIndToUpperLayerCnf;
 
 typedef struct tagCsrSummaryStatsInfo
diff -urN qcacld-new.orig/CORE/SME/inc/sme_Api.h qcacld-new/CORE/SME/inc/sme_Api.h
--- qcacld-new.orig/CORE/SME/inc/sme_Api.h	2016-05-16 10:58:08.746298648 +0800
+++ qcacld-new/CORE/SME/inc/sme_Api.h	2016-05-16 10:58:19.018298648 +0800
@@ -2236,6 +2236,27 @@
 eHalStatus sme_ConfigureAppType1Params( tHalHandle hHal,
                           tpSirAppType1Params  wlanAppType1Params);
 
+#ifdef WLAN_FEATURE_EXTWOW_OUTDOOR_SUPPORT
+/* ---------------------------------------------------------------------------
+
+  \fn    sme_ConfigureAppType2Params
+
+  \brief
+    SME will pass this request to lower mac to configure Indoor WoW parameters.
+
+  \param
+
+    hHal - The handle returned by macOpen.
+
+    wlanAppType2Params- Depicts the wlan Indoor params
+
+  \return eHalStatus
+
+
+--------------------------------------------------------------------------- */
+eHalStatus sme_ConfigureAppType2Params( tHalHandle hHal,
+                          tpSirAppType2Params  wlanAppType2Params);
+#endif
 #endif
 
 /* ---------------------------------------------------------------------------
diff -urN qcacld-new.orig/CORE/SME/src/csr/csrApiRoam.c qcacld-new/CORE/SME/src/csr/csrApiRoam.c
--- qcacld-new.orig/CORE/SME/src/csr/csrApiRoam.c	2016-05-16 10:58:08.750298648 +0800
+++ qcacld-new/CORE/SME/src/csr/csrApiRoam.c	2016-05-16 10:58:19.018298648 +0800
@@ -8776,6 +8776,10 @@
             pRoamInfo->prsnIE = pUpperLayerAssocCnf->rsnIE.rsnIEdata;
             pRoamInfo->addIELen = (tANI_U8)pUpperLayerAssocCnf->addIE.length;
             pRoamInfo->paddIE = pUpperLayerAssocCnf->addIE.addIEdata;
+#ifdef CONFIG_CUST_PLATFORM
+            pRoamInfo->assocReqLength = (tANI_U8)pUpperLayerAssocCnf->assocReqLength;
+            pRoamInfo->assocReqPtr = pUpperLayerAssocCnf->assocReqPtr;
+#endif
             vos_mem_copy(pRoamInfo->peerMac, pUpperLayerAssocCnf->peerMacAddr,
                          sizeof(tSirMacAddr));
             vos_mem_copy(&pRoamInfo->bssid, pUpperLayerAssocCnf->bssId,
@@ -14255,6 +14259,12 @@
         //timingMeasCap
         *pBuf = pAssocInd->timingMeasCap;
         pBuf += sizeof (tANI_U8);
+#ifdef CONFIG_CUST_PLATFORM
+        if (pAssocInd->assocReqLength && pAssocInd->assocReqPtr) {
+            pMsg->assocReqLength = pAssocInd->assocReqLength;
+            vos_mem_copy(pMsg->assocReqPtr, pAssocInd->assocReqPtr, pAssocInd->assocReqLength);
+        }
+#endif
         msgQ.type = eWNI_SME_UPPER_LAYER_ASSOC_CNF;
         msgQ.bodyptr = pMsg;
         msgQ.bodyval = 0;
diff -urN qcacld-new.orig/CORE/SME/src/csr/csrApiScan.c qcacld-new/CORE/SME/src/csr/csrApiScan.c
--- qcacld-new.orig/CORE/SME/src/csr/csrApiScan.c	2016-05-16 10:58:08.750298648 +0800
+++ qcacld-new/CORE/SME/src/csr/csrApiScan.c	2016-05-16 10:58:19.018298648 +0800
@@ -2782,6 +2782,10 @@
             pRoamInfo->prsnIE = pUpperLayerAssocCnf->rsnIE.rsnIEdata;
             pRoamInfo->addIELen = (tANI_U8)pUpperLayerAssocCnf->addIE.length;
             pRoamInfo->paddIE = pUpperLayerAssocCnf->addIE.addIEdata;
+#ifdef CONFIG_CUST_PLATFORM
+            pRoamInfo->assocReqLength = (tANI_U8)pUpperLayerAssocCnf->assocReqLength;
+            pRoamInfo->assocReqPtr = pUpperLayerAssocCnf->assocReqPtr;
+#endif
             vos_mem_copy(pRoamInfo->peerMac, pUpperLayerAssocCnf->peerMacAddr, sizeof(tSirMacAddr));
             vos_mem_copy(&pRoamInfo->bssid, pUpperLayerAssocCnf->bssId, sizeof(tCsrBssid));
             pRoamInfo->wmmEnabledSta = pUpperLayerAssocCnf->wmmEnabledSta;
diff -urN qcacld-new.orig/CORE/SME/src/sme_common/sme_Api.c qcacld-new/CORE/SME/src/sme_common/sme_Api.c
--- qcacld-new.orig/CORE/SME/src/sme_common/sme_Api.c	2016-05-16 10:58:08.754298648 +0800
+++ qcacld-new/CORE/SME/src/sme_common/sme_Api.c	2016-05-16 10:58:19.026298648 +0800
@@ -7788,6 +7788,59 @@
     return(status);
 }
 
+#ifdef WLAN_FEATURE_EXTWOW_OUTDOOR_SUPPORT
+/* ---------------------------------------------------------------------------
+
+  \fn    sme_ConfigureAppType2Params
+
+  \brief
+   SME will pass this request to lower mac to configure Indoor WoW parameters.
+
+  \param
+
+    hHal - The handle returned by macOpen.
+
+    wlanAppType2Params- Depicts the wlan App Type 2 (Outdoor) params
+
+  \return eHalStatus
+
+
+--------------------------------------------------------------------------- */
+eHalStatus sme_ConfigureAppType2Params( tHalHandle hHal,
+                          tpSirAppType2Params  wlanAppType2Params)
+{
+    eHalStatus status = eHAL_STATUS_SUCCESS;
+    VOS_STATUS vosStatus = VOS_STATUS_SUCCESS;
+    tpAniSirGlobal pMac = PMAC_STRUCT(hHal);
+    vos_msg_t       vosMessage;
+    tpSirAppType2Params MsgPtr = vos_mem_malloc(sizeof(*MsgPtr));
+
+    if (!MsgPtr)
+        return eHAL_STATUS_FAILURE;
+
+    MTRACE(vos_trace(VOS_MODULE_ID_SME,
+                  TRACE_CODE_SME_RX_HDD_CONFIG_APP_TYPE2, NO_SESSION, 0));
+
+    if ( eHAL_STATUS_SUCCESS ==
+            ( status = sme_AcquireGlobalLock( &pMac->sme ) ) ) {
+
+        /* serialize the req through MC thread */
+        vos_mem_copy(MsgPtr, wlanAppType2Params, sizeof(*MsgPtr));
+        vosMessage.bodyptr = MsgPtr;
+        vosMessage.type =  WDA_WLAN_SET_APP_TYPE2_PARAMS;
+        vosStatus = vos_mq_post_message( VOS_MQ_ID_WDA, &vosMessage );
+        if ( !VOS_IS_STATUS_SUCCESS(vosStatus) ) {
+           vos_mem_free(MsgPtr);
+           status = eHAL_STATUS_FAILURE;
+        }
+        sme_ReleaseGlobalLock( &pMac->sme );
+    } else {
+        vos_mem_free(MsgPtr);
+    }
+
+    return(status);
+}
+#endif
 #endif
 
 /* ---------------------------------------------------------------------------
diff -urN qcacld-new.orig/CORE/UTILS/FWLOG/dbglog_host.c qcacld-new/CORE/UTILS/FWLOG/dbglog_host.c
--- qcacld-new.orig/CORE/UTILS/FWLOG/dbglog_host.c	2016-05-16 10:58:08.738298648 +0800
+++ qcacld-new/CORE/UTILS/FWLOG/dbglog_host.c	2016-05-16 10:58:19.014298648 +0800
@@ -1163,6 +1163,112 @@
     },
 };
 
+#ifdef CONFIG_WLAN_FWLOG_FILE
+extern int _readwrite_file(const char *filename, char *rbuf,
+                           const char *wbuf, size_t length, int mode);
+
+#define FWLOG_FILE_BUF_MAX_DEFAULT_SIZE	  (16*1024) /* default 16k */
+#define FWLOG_FILE_BUF_THREHOLD           (12*1024) /* default 12k */
+#define FWLOG_FILE_MAX_DEFAULT_SIZE       (10*1024*1024) /* default 10M */
+#define FWLOG_FILE_DEFAULT_PATH           "/opt/var/log/cld_fw.log"
+
+struct _dbglog_fwlog_file {
+    A_UINT8  print_to_file;
+    A_UINT32 file_max_size;
+    A_UINT8  file_path_and_name[64];
+    A_UINT32 file_size;
+    A_UINT32 buf_used_size;
+    A_UINT32 buf_free_size;
+    A_UINT8* buf_free_idx;
+    struct mutex lock;
+    struct work_struct work;
+    adf_os_timer_t timer;
+    A_UINT8* buf;
+    A_UINT32 overflow;
+} dbglog_fwlog_file_ctx;
+
+inline void dbglog_fwlog_file_trunc(void)
+{
+
+    _readwrite_file(dbglog_fwlog_file_ctx.file_path_and_name, NULL,
+                    NULL, 0, (O_WRONLY | O_CREAT | O_TRUNC));
+
+    dbglog_fwlog_file_ctx.file_size = 0;
+}
+
+
+void dbglog_fwlog_file_write_file(void)
+{
+    int ret;
+
+    if (dbglog_fwlog_file_ctx.buf_used_size) {
+        if (dbglog_fwlog_file_ctx.file_size >= dbglog_fwlog_file_ctx.file_max_size) {
+            dbglog_fwlog_file_trunc();
+        }
+        ret = _readwrite_file(dbglog_fwlog_file_ctx.file_path_and_name, NULL,
+                              dbglog_fwlog_file_ctx.buf,
+                              dbglog_fwlog_file_ctx.buf_used_size,
+                              (O_WRONLY | O_APPEND | O_CREAT));
+        if (ret < 0) {
+            printk("%s:%d: fail to write\n", __func__, __LINE__);
+            return;
+        }
+
+        dbglog_fwlog_file_ctx.buf_free_idx = dbglog_fwlog_file_ctx.buf;
+        dbglog_fwlog_file_ctx.file_size += dbglog_fwlog_file_ctx.buf_used_size;
+        dbglog_fwlog_file_ctx.buf_used_size = 0;
+        dbglog_fwlog_file_ctx.buf_free_size = FWLOG_FILE_BUF_MAX_DEFAULT_SIZE;
+    }
+}
+
+
+void dbglog_fwlog_file_thread(struct work_struct *work)
+{
+    mutex_lock(&dbglog_fwlog_file_ctx.lock);
+    dbglog_fwlog_file_write_file();
+    mutex_unlock(&dbglog_fwlog_file_ctx.lock);
+}
+
+
+void dbglog_fwlog_file_timeout_handler(void* ctx)
+{
+    schedule_work(&dbglog_fwlog_file_ctx.work);
+}
+
+int dbglog_fwlog_file_init(void)
+{
+    dbglog_fwlog_file_ctx.buf = kmalloc(FWLOG_FILE_BUF_MAX_DEFAULT_SIZE, GFP_KERNEL);
+    if (dbglog_fwlog_file_ctx.buf == NULL) {
+        printk("%s:%d: not enough mem\n", __func__, __LINE__);
+        return -ENOMEM;
+    }
+
+    dbglog_fwlog_file_ctx.print_to_file = 0;
+    dbglog_fwlog_file_ctx.overflow = 0;
+    dbglog_fwlog_file_ctx.file_max_size = FWLOG_FILE_MAX_DEFAULT_SIZE;
+	A_SNPRINTF(dbglog_fwlog_file_ctx.file_path_and_name,
+			strnlen(FWLOG_FILE_DEFAULT_PATH, 63) + 1,
+			FWLOG_FILE_DEFAULT_PATH);
+    dbglog_fwlog_file_ctx.file_size = 0;
+    dbglog_fwlog_file_ctx.buf_used_size = 0;
+    dbglog_fwlog_file_ctx.buf_free_size = FWLOG_FILE_BUF_MAX_DEFAULT_SIZE;
+    dbglog_fwlog_file_ctx.buf_free_idx = dbglog_fwlog_file_ctx.buf;
+    mutex_init(&dbglog_fwlog_file_ctx.lock);
+    INIT_WORK(&dbglog_fwlog_file_ctx.work, dbglog_fwlog_file_thread);
+    adf_os_timer_init(NULL, &dbglog_fwlog_file_ctx.timer, dbglog_fwlog_file_timeout_handler, NULL);
+
+    return 0;
+}
+
+void dbglog_fwlog_file_deinit(void)
+{
+    adf_os_timer_cancel(&dbglog_fwlog_file_ctx.timer);
+    adf_os_timer_free(&dbglog_fwlog_file_ctx.timer);
+    flush_work(&dbglog_fwlog_file_ctx.work);
+    mutex_unlock(&dbglog_fwlog_file_ctx.lock);
+    kfree(dbglog_fwlog_file_ctx.buf);
+}
+#endif
 
 int dbglog_module_log_enable(wmi_unified_t  wmi_handle, A_UINT32 mod_id,
                   bool isenable)
@@ -1302,6 +1408,30 @@
 }
 
 
+#ifdef CONFIG_WLAN_FWLOG_FILE
+int dbglog_fwlog_file_enable(wmi_unified_t  wmi_handle, bool isenable)
+{
+
+	if (isenable) {
+		dbglog_fwlog_file_ctx.print_to_file = 1;
+		dbglog_fwlog_file_trunc();
+	} else {
+		dbglog_fwlog_file_ctx.print_to_file = 0;
+	}
+	return 0;
+}
+
+
+int dbglog_fwlog_file_max_size(wmi_unified_t  wmi_handle, A_UINT32 size)
+{
+        if (size == 0) {
+             dbglog_fwlog_file_ctx.file_max_size = FWLOG_FILE_MAX_DEFAULT_SIZE;
+        } else {
+             dbglog_fwlog_file_ctx.file_max_size = size;
+        }
+        return 0;
+}
+#endif
 
 int dbglog_report_enable(wmi_unified_t  wmi_handle, bool isenable)
 {
@@ -1314,6 +1444,9 @@
 	bitmap[1] = 0x1F;
 	/* set the module level bitmap  */
 	dbglog_set_mod_enable_bitmap(wmi_handle, 0x0, bitmap, 2);
+#ifdef CONFIG_WLAN_FWLOG_FILE
+	dbglog_fwlog_file_trunc();
+#endif
     } else {
         dbglog_set_vap_enable_bitmap(wmi_handle, bitmap[0]);
         dbglog_set_mod_enable_bitmap(wmi_handle, DBGLOG_LVL_MAX, bitmap, 2);
@@ -1349,12 +1482,65 @@
 {
     char buf[128];
     va_list ap;
+#ifdef CONFIG_WLAN_FWLOG_FILE
+    int len = 0;
+
+    if (dbglog_fwlog_file_ctx.print_to_file) {
+        mutex_lock(&dbglog_fwlog_file_ctx.lock);
+
+        if (dbglog_fwlog_file_ctx.buf_used_size  == 0) {
+	    adf_os_timer_cancel(&dbglog_fwlog_file_ctx.timer);
+            adf_os_timer_start(&dbglog_fwlog_file_ctx.timer, 100);
+        }
+
+        if (dbglog_fwlog_file_ctx.buf_free_size <= 120) {
+            dbglog_fwlog_file_ctx.overflow++;
+            printk("%s:%d: overflow:%u\n", __func__, __LINE__, dbglog_fwlog_file_ctx.overflow);
+            mutex_unlock(&dbglog_fwlog_file_ctx.lock);
+            return;
+        }
+
+	if (vap_id < DBGLOG_MAX_VDEVID) {
+            len = snprintf(dbglog_fwlog_file_ctx.buf_free_idx, dbglog_fwlog_file_ctx.buf_free_size,
+                           "[%u] vap-%u ", timestamp, vap_id);
+	} else {
+            len = snprintf(dbglog_fwlog_file_ctx.buf_free_idx, dbglog_fwlog_file_ctx.buf_free_size,
+                           "[%u] ", timestamp);
+	}
+
+        va_start(ap, fmt);
+        len += vsnprintf(dbglog_fwlog_file_ctx.buf_free_idx + len, dbglog_fwlog_file_ctx.buf_free_size - len, fmt, ap);
+	dbglog_fwlog_file_ctx.buf_free_idx[len] = '\n';
+	len++;
+        dbglog_fwlog_file_ctx.buf_free_idx += len;
+        dbglog_fwlog_file_ctx.buf_used_size += len;
+        dbglog_fwlog_file_ctx.buf_free_size -= len;
+        va_end(ap);
+        if ((dbglog_fwlog_file_ctx.buf_used_size >= FWLOG_FILE_BUF_THREHOLD) ||
+            ((dbglog_fwlog_file_ctx.file_size + dbglog_fwlog_file_ctx.buf_used_size) >= dbglog_fwlog_file_ctx.file_max_size)) {
+            adf_os_timer_cancel(&dbglog_fwlog_file_ctx.timer);
+            dbglog_fwlog_file_write_file();
+        }
+        mutex_unlock(&dbglog_fwlog_file_ctx.lock);
+    } else {
+        if (vap_id < DBGLOG_MAX_VDEVID) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (DBGLOG_PRINT_PREFIX "[%u] vap-%u ", timestamp, vap_id));
+        } else {
+            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (DBGLOG_PRINT_PREFIX "[%u] ", timestamp));
+        }
+        va_start(ap, fmt);
+        vsnprintf(buf, sizeof(buf), fmt, ap);
+        va_end(ap);
+        AR_DEBUG_PRINTF(ATH_DEBUG_INFO, ("%s\n", buf));
+    }
+#else
 
     va_start(ap, fmt);
     vsnprintf(buf, sizeof(buf), fmt, ap);
     va_end(ap);
 
     AR_DEBUG_PRINTF(ATH_DEBUG_INFO, ("%s\n", buf));
+#endif
 }
 
 void
@@ -1365,6 +1551,60 @@
 {
     char buf[128];
     va_list ap;
+#ifdef CONFIG_WLAN_FWLOG_FILE
+    int len = 0;
+
+    if (dbglog_fwlog_file_ctx.print_to_file) {
+        mutex_lock(&dbglog_fwlog_file_ctx.lock);
+
+        if (dbglog_fwlog_file_ctx.buf_used_size  == 0) {
+	    adf_os_timer_cancel(&dbglog_fwlog_file_ctx.timer);
+            adf_os_timer_start(&dbglog_fwlog_file_ctx.timer, 100);
+        }
+
+        if (dbglog_fwlog_file_ctx.buf_free_size <= 120) {
+            dbglog_fwlog_file_ctx.overflow++;
+            printk("%s:%d: overflow:%u\n", __func__, __LINE__, dbglog_fwlog_file_ctx.overflow);
+            mutex_unlock(&dbglog_fwlog_file_ctx.lock);
+            return;
+        }
+
+	if (vap_id < DBGLOG_MAX_VDEVID) {
+		len = snprintf(dbglog_fwlog_file_ctx.buf_free_idx, dbglog_fwlog_file_ctx.buf_free_size,
+			"[%u] vap-%u ", timestamp, vap_id);
+	} else {
+		len = snprintf(dbglog_fwlog_file_ctx.buf_free_idx, dbglog_fwlog_file_ctx.buf_free_size,
+			"[%u] ", timestamp);
+	}
+
+        va_start(ap, fmt);
+        len += vsnprintf(dbglog_fwlog_file_ctx.buf_free_idx + len, dbglog_fwlog_file_ctx.buf_free_size - len, fmt, ap);
+	dbglog_fwlog_file_ctx.buf_free_idx[len] = '\n';
+	len++;
+        dbglog_fwlog_file_ctx.buf_free_idx += len;
+        dbglog_fwlog_file_ctx.buf_used_size += len;
+        dbglog_fwlog_file_ctx.buf_free_size -= len;
+        va_end(ap);
+        if ((dbglog_fwlog_file_ctx.buf_used_size >= FWLOG_FILE_BUF_THREHOLD) ||
+            ((dbglog_fwlog_file_ctx.file_size + dbglog_fwlog_file_ctx.buf_used_size) >= dbglog_fwlog_file_ctx.file_max_size)) {
+            adf_os_timer_cancel(&dbglog_fwlog_file_ctx.timer);
+            dbglog_fwlog_file_write_file();
+        }
+        mutex_unlock(&dbglog_fwlog_file_ctx.lock);
+    } else {
+        if (vap_id < DBGLOG_MAX_VDEVID) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (DBGLOG_PRINT_PREFIX "[%u] vap-%u ", timestamp, vap_id));
+        } else {
+            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (DBGLOG_PRINT_PREFIX "[%u] ", timestamp));
+        }
+
+        va_start(ap, fmt);
+        vsnprintf(buf, sizeof(buf), fmt, ap);
+        va_end(ap);
+
+        AR_DEBUG_PRINTF(ATH_DEBUG_INFO, ("%s", buf));
+    }
+#else
     if (vap_id < DBGLOG_MAX_VDEVID) {
         AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (DBGLOG_PRINT_PREFIX "[%u] vap-%u ", timestamp, vap_id));
     } else {
@@ -1376,6 +1616,7 @@
     va_end(ap);
 
     AR_DEBUG_PRINTF(ATH_DEBUG_INFO, ("%s", buf));
+#endif
 }
 
 #define USE_NUMERIC 0
@@ -1385,7 +1626,38 @@
                              A_UINT32 timestamp, A_UINT16 numargs, A_UINT32 *args)
 {
     int i;
+#ifdef CONFIG_WLAN_FWLOG_FILE
+    int len = 0;
+
+    if (dbglog_fwlog_file_ctx.print_to_file) {
+        mutex_lock(&dbglog_fwlog_file_ctx.lock);
+
+        if (dbglog_fwlog_file_ctx.buf_used_size  == 0) {
+	    adf_os_timer_cancel(&dbglog_fwlog_file_ctx.timer);
+            adf_os_timer_start(&dbglog_fwlog_file_ctx.timer, 100);
+        }
+
+        if (dbglog_fwlog_file_ctx.buf_free_size <= 120) {
+            dbglog_fwlog_file_ctx.overflow++;
+            printk("%s:%d: overflow:%u\n", __func__, __LINE__, dbglog_fwlog_file_ctx.overflow);
+            mutex_unlock(&dbglog_fwlog_file_ctx.lock);
+            return TRUE;
+        }
+
+	if (vap_id < DBGLOG_MAX_VDEVID) {
+            len = snprintf(dbglog_fwlog_file_ctx.buf_free_idx, dbglog_fwlog_file_ctx.buf_free_size,
+                           "[%u] vap-%u %s (", timestamp, vap_id, dbglog_get_msg(mod_id, dbg_id));
+	} else {
+            len = snprintf(dbglog_fwlog_file_ctx.buf_free_idx, dbglog_fwlog_file_ctx.buf_free_size,
+                           "[%u] %s (", timestamp, dbglog_get_msg(mod_id, dbg_id));
+	}
+
+        for (i = 0; i < numargs; i++) {
+#if USE_NUMERIC
+            len += snprintf(dbglog_fwlog_file_ctx.buf_free_idx + len, dbglog_fwlog_file_ctx.buf_free_size - len, "%u", args[i]);
+#else
             len += snprintf(dbglog_fwlog_file_ctx.buf_free_idx + len, dbglog_fwlog_file_ctx.buf_free_size - len, "%#x", args[i]);
+#endif
             if ((i + 1) < numargs) {
                 dbglog_fwlog_file_ctx.buf_free_idx[len] = ',';
                 dbglog_fwlog_file_ctx.buf_free_idx[len+1] = ' ';
@@ -1411,14 +1683,18 @@
         }
 
         for (i = 0; i < numargs; i++) {
+#if USE_NUMERIC
             AR_DEBUG_PRINTF(ATH_DEBUG_INFO, ("%u", args[i]));
+#else
             AR_DEBUG_PRINTF(ATH_DEBUG_INFO, ("%#x", args[i]));
+#endif
             if ((i + 1) < numargs) {
                 AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (", "));
             }
         }
         AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (" )\n"));
     }
+#else
     if (vap_id < DBGLOG_MAX_VDEVID) {
         AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (DBGLOG_PRINT_PREFIX "[%u] vap-%u %s ( ", timestamp, vap_id, dbglog_get_msg(mod_id, dbg_id)));
     } else {
@@ -1426,13 +1702,17 @@
     }
 
     for (i = 0; i < numargs; i++) {
+#if USE_NUMERIC
         AR_DEBUG_PRINTF(ATH_DEBUG_INFO, ("%u", args[i]));
+#else
         AR_DEBUG_PRINTF(ATH_DEBUG_INFO, ("%#x", args[i]));
+#endif
         if ((i + 1) < numargs) {
             AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (", "));
         }
     }
     AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (" )\n"));
+#endif
 
     return TRUE;
 }
@@ -4137,6 +4417,12 @@
     /* Initialize debugfs */
     dbglog_debugfs_init(wmi_handle);
 #endif /* WLAN_OPEN_SOURCE */
+#ifdef CONFIG_WLAN_FWLOG_FILE
+    res = dbglog_fwlog_file_init();
+    if (res != 0) {
+        return res;
+    }
+#endif
 
     return res;
 }
@@ -4146,6 +4432,9 @@
 {
     int res = 0;
 
+#ifdef CONFIG_WLAN_FWLOG_FILE
+    dbglog_fwlog_file_deinit();
+#endif
 #ifdef WLAN_OPEN_SOURCE
     /* DeInitialize the fw debug log queue */
     skb_queue_purge(&wmi_handle->dbglog.fwlog_queue);
diff -urN qcacld-new.orig/CORE/VOSS/src/vos_sched.c qcacld-new/CORE/VOSS/src/vos_sched.c
--- qcacld-new.orig/CORE/VOSS/src/vos_sched.c	2016-05-16 10:58:08.882298648 +0800
+++ qcacld-new/CORE/VOSS/src/vos_sched.c	2016-05-16 10:58:19.042298648 +0800
@@ -120,6 +120,70 @@
 }
 #endif /* #ifndef CONFIG_CUST_PLATFORM */
 
+#ifdef CONFIG_CUST_PLATFORM
+
+static int vos_cpu_hotplug_notify(struct notifier_block *block,
+                                  unsigned long state, void *hcpu)
+{
+   unsigned long cpu = (unsigned long) hcpu;
+   unsigned long pref_cpu = 0;
+   pVosSchedContext pSchedContext = get_vos_sched_ctxt();
+   int i;
+   cpumask_var_t pref_cpumask;
+
+   if ((NULL == pSchedContext) || (NULL == pSchedContext->TlshimRxThread))
+       return NOTIFY_OK;
+
+   if (vos_is_load_unload_in_progress(VOS_MODULE_ID_VOSS, NULL))
+   {
+       return NOTIFY_OK;
+   }
+
+   if (!alloc_cpumask_var(&pref_cpumask, GFP_KERNEL)) {
+      VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_ERROR,
+         "%s: fail to allocate pref_cpumask", __func__);
+      return NOTIFY_OK;
+   }
+
+   switch (state) {
+   case CPU_ONLINE:
+       if (affine_cpu != 0)
+           return NOTIFY_OK;
+
+       for_each_online_cpu(i) {
+           if (i == 0)
+               continue;
+		   pref_cpu |= 0x1 <<i;
+           cpumask_or(pref_cpumask, pref_cpumask, cpumask_of(i));
+       }
+       break;
+   case CPU_DEAD:
+       if (!(cpu & affine_cpu))
+           return NOTIFY_OK;
+
+       affine_cpu = 0;
+       for_each_online_cpu(i) {
+           if (i == 0)
+               continue;
+           pref_cpu |= 0x1 << i;
+           cpumask_or(pref_cpumask, pref_cpumask, cpumask_of(i));
+       }
+   }
+
+   if (pref_cpu == 0) {
+	   free_cpumask_var(pref_cpumask);
+	   return NOTIFY_OK;
+   	}
+
+   if (!set_cpus_allowed_ptr(pSchedContext->TlshimRxThread, pref_cpumask))
+       affine_cpu = pref_cpu;
+
+   printk("vos_cpu_hotplug_notify perf_cpu = 0x%lx\n", pref_cpu);
+   free_cpumask_var(pref_cpumask);
+
+   return NOTIFY_OK;
+}
+#else
 static int vos_cpu_hotplug_notify(struct notifier_block *block,
                                   unsigned long state, void *hcpu)
 {
@@ -169,6 +233,7 @@
 
    return NOTIFY_OK;
 
+#endif /* CONFIG_CUST_PLATFORM */
 
 static struct notifier_block vos_cpu_hotplug_notifier = {
    .notifier_call = vos_cpu_hotplug_notify,
@@ -1551,11 +1616,43 @@
    unsigned long pref_cpu = 0;
    bool shutdown = false;
    int status, i;
+#ifdef CONFIG_CUST_PLATFORM
+   cpumask_var_t pref_cpumask;
+
+   set_user_nice(current, -13);
+#else
    set_user_nice(current, -1);
+#endif
 #ifdef MSM_PLATFORM
    set_wake_up_idle(true);
 #endif
 
+#ifdef CONFIG_CUST_PLATFORM
+
+   /* Find the available cpu core other than cpu 0 and
+    * bind the thread */
+   if (!alloc_cpumask_var(&pref_cpumask, GFP_KERNEL)) {
+      VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_ERROR,
+         "%s: fail to allocate pref_cpumask", __func__);
+      goto SKIP_AFFINE;
+   }
+
+   for_each_online_cpu(i) {
+       if (i == 0)   /* avoid using cpu 0 */
+           continue;
+       pref_cpu |= 0x1 << i;
+       cpumask_or(pref_cpumask, pref_cpumask, cpumask_of(i));
+   }
+
+   printk("VosTlshimRxThread perf_cpu = 0x%lx\n", pref_cpu);
+
+   if (pref_cpu != 0 && (!set_cpus_allowed_ptr(current, pref_cpumask)))
+      affine_cpu = pref_cpu;
+
+   free_cpumask_var(pref_cpumask);
+
+SKIP_AFFINE:
+#else
 
 	/* Find the available cpu core other than cpu 0 and
 	 * bind the thread */
@@ -1567,6 +1664,7 @@
 	}
 	if (pref_cpu != 0 && (!vos_set_cpus_allowed_ptr(current, pref_cpu)))
 		affine_cpu = pref_cpu;
+#endif
 
 	if (!arg) {
 		VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_ERROR,
