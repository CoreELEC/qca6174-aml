From bfe7dd34dfc67aa4a977ae0db27d34f8de0eadcc Mon Sep 17 00:00:00 2001
From: Yi Chen <yichen@qti.qualcomm.com>
Date: Mon, 18 Apr 2016 18:52:15 +0800
Subject: [PATCH 7/7] QCACLD Support CONFIG CONTX USB DEBUG. Signed-off-by: Yi
 Chen <yichen@qti.qualcomm.com>

---
 CORE/CLD_TXRX/TLSHIM/tl_shim.c       |   13 ++++
 CORE/CLD_TXRX/TXRX/ol_tx_queue.c     |   15 ++++
 CORE/CLD_TXRX/TXRX/ol_tx_sched.c     |   16 +++++
 CORE/HDD/src/wlan_hdd_direct_audio.c |  128 ++++++++++++++++++++++++++++++++--
 CORE/HDD/src/wlan_hdd_softap_tx_rx.c |   11 +++
 CORE/HDD/src/wlan_hdd_wext.c         |   50 +++++++++++--
 6 files changed, 222 insertions(+), 11 deletions(-)

diff --git a/CORE/CLD_TXRX/TLSHIM/tl_shim.c b/CORE/CLD_TXRX/TLSHIM/tl_shim.c
index 7b41017..b1a9b89 100644
--- a/CORE/CLD_TXRX/TLSHIM/tl_shim.c
+++ b/CORE/CLD_TXRX/TLSHIM/tl_shim.c
@@ -1109,6 +1109,10 @@ void WLANTL_RegisterVdev(void *vos_ctx, void *vdev)
 	adf_os_atomic_set(&tl_shim->vdev_active[vdev_handle->vdev_id], 1);
 }
 
+#ifdef CONFIG_CONTX_USB_DEBUG
+extern int txkeeprun;
+#endif
+
 /*
  * TL API called from WMA to un-register a vdev for data service with
  * txrx. This API is called once vdev delete.
@@ -1152,11 +1156,20 @@ void *tlshim_peer_validity(void *vos_ctx, uint8_t sta_id)
 		return NULL;
 	}
 
+#ifdef CONFIG_CONTX_USB_DEBUG
+	if (!txkeeprun) {
+		if (!tl_shim->sta_info[sta_id].registered) {
+			TLSHIM_LOGW("Staion is not yet registered for data service");
+			return NULL;
+		}
+	}
+#else
 	if (!tl_shim->sta_info[sta_id].registered) {
 		TLSHIM_LOGW("Staion is not yet registered for data service");
 		return NULL;
 	}
 
+#endif
 	peer = ol_txrx_peer_find_by_local_id(
 			((pVosContextType) vos_ctx)->pdev_txrx_ctx,
 			sta_id);
diff --git a/CORE/CLD_TXRX/TXRX/ol_tx_queue.c b/CORE/CLD_TXRX/TXRX/ol_tx_queue.c
index 5278fb6..6d15103 100644
--- a/CORE/CLD_TXRX/TXRX/ol_tx_queue.c
+++ b/CORE/CLD_TXRX/TXRX/ol_tx_queue.c
@@ -215,6 +215,11 @@ ol_tx_queue_discard(
     }
 }
 
+#if defined(CONFIG_CONTX_USB_DEBUG) && defined(DIRECT_AUDIO_SUPPORT)
+extern int txkeeprun;
+extern int txkeepruntoofastseriously;
+#endif
+
 void
 ol_tx_enqueue(
     struct ol_txrx_pdev_t *pdev,
@@ -237,6 +242,16 @@ ol_tx_enqueue(
      */
 #if defined(CONFIG_PER_VDEV_TX_DESC_POOL)
     vdev = tx_desc->vdev;
+#if defined(CONFIG_CONTX_USB_DEBUG) && defined(DIRECT_AUDIO_SUPPORT)
+    if (txkeeprun &&
+		(adf_os_atomic_read(&vdev->tx_desc_count) >
+          ((ol_tx_desc_pool_size_hl(pdev->ctrl_pdev) >> 1)
+		- TXRX_HL_TX_FLOW_CTRL_MGMT_RESERVED)
+		- OL_TX_DESC_POOL_SIZE_MIN_HL/2)){
+			txkeepruntoofastseriously = 1;
+			pr_err("contx too at ol, slow down\n");
+    }
+#endif
     if (adf_os_atomic_read(&vdev->tx_desc_count) >
           ((ol_tx_desc_pool_size_hl(pdev->ctrl_pdev) >> 1)
            - TXRX_HL_TX_FLOW_CTRL_MGMT_RESERVED)) {
diff --git a/CORE/CLD_TXRX/TXRX/ol_tx_sched.c b/CORE/CLD_TXRX/TXRX/ol_tx_sched.c
index 58779e4..e82309f 100644
--- a/CORE/CLD_TXRX/TXRX/ol_tx_sched.c
+++ b/CORE/CLD_TXRX/TXRX/ol_tx_sched.c
@@ -686,6 +686,12 @@ ol_tx_sched_wrr_adv_credit_sanity_check(struct ol_txrx_pdev_t *pdev, u_int32_t c
  * The scheduler sync spinlock has been acquired outside this function,
  * so there is no need to worry about mutex within this function.
  */
+
+#ifdef CONFIG_CONTX_USB_DEBUG
+extern int txkeeprun;
+extern int txkeepruntoofast;
+#endif
+
 static int
 ol_tx_sched_select_batch_wrr_adv(
     struct ol_txrx_pdev_t *pdev,
@@ -741,6 +747,11 @@ ol_tx_sched_select_batch_wrr_adv(
          * service this category after all).
          */
         category->state.wrr_count = category->state.wrr_count - 1;
+#ifdef CONFIG_CONTX_USB_DEBUG
+        if (txkeeprun && category->state.frms > 500) {
+                txkeepruntoofast = 1;
+        }
+#endif
         return 0;
     }
     /* enough credit is available - go ahead and send some frames */
@@ -815,9 +826,14 @@ ol_tx_sched_select_batch_wrr_adv(
         TX_SCHED_DEBUG_PRINT("Leave %s\n", __func__);
     } else {
         used_credits = 0;
+#ifdef CONFIG_CONTX_USB_DEBUG
+        if (!txkeeprun)
+            TX_SCHED_DEBUG_PRINT("ol_tx_sched_select_batch_wrr_adv: error, no TXQ can be popped.");
+#else
         /* TODO: find its reason */
         VOS_TRACE(VOS_MODULE_ID_TXRX, VOS_TRACE_LEVEL_ERROR,
              "ol_tx_sched_select_batch_wrr_adv: error, no TXQ can be popped.");
+#endif
     }
     return used_credits;
 }
diff --git a/CORE/HDD/src/wlan_hdd_direct_audio.c b/CORE/HDD/src/wlan_hdd_direct_audio.c
index 07e9514..07fec33 100644
--- a/CORE/HDD/src/wlan_hdd_direct_audio.c
+++ b/CORE/HDD/src/wlan_hdd_direct_audio.c
@@ -313,6 +313,11 @@ rx_fail:
 #endif
 }
 
+#ifdef CONFIG_CONTX_USB_DEBUG
+extern struct timer_list da_timer;
+extern int txkeeprun;
+#endif /* CONFIG_CONTX_USB_DEBUG */
+
 void SDA_function4Send(unsigned int BufferId, unsigned char *pBuffer, unsigned int BufferSize)
 {
 	hdd_adapter_t * vif;
@@ -337,11 +342,19 @@ void SDA_function4Send(unsigned int BufferId, unsigned char *pBuffer, unsigned i
 	}
 	if (vif->device_mode == WLAN_HDD_INFRA_STATION || vif->device_mode == WLAN_HDD_P2P_CLIENT) {
 		pHddStaCtx = WLAN_HDD_GET_STATION_CTX_PTR(vif);
+#ifdef CONFIG_CONTX_USB_DEBUG
+		if (!pHddStaCtx || (!hdd_connIsConnected(pHddStaCtx) && !txkeeprun)) {
+			VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+				"%s: STA %p is not connected\n", __func__, pHddStaCtx);
+			return;
+		}
+#else
 		if (!pHddStaCtx || !hdd_connIsConnected(pHddStaCtx)) {
 			VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
 				"%s: STA %p is not connected\n", __func__, pHddStaCtx);
 			return;
 		}
+#endif
 	}
 	if (vif->device_mode == WLAN_HDD_SOFTAP || vif->device_mode == WLAN_HDD_P2P_GO) {
 		pAPCtx = WLAN_HDD_GET_AP_CTX_PTR(vif);
@@ -431,6 +444,12 @@ void Direct_Audio_init(hdd_context_t *pHddCtx)
 void Direct_Audio_deinit(hdd_context_t *pHddCtx)
 {
 	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,"%s[%d]\n\r",__func__,__LINE__);
+#ifdef CONFIG_CONTX_USB_DEBUG
+	if (txkeeprun == 1) {
+		txkeeprun = 0;
+		msleep(500);
+	}
+#endif /* CONFIG_CONTX_USB_DEBUG */
 }
 
 #if defined(HIF_USB)
@@ -521,14 +540,80 @@ static void debug_tx_done_cb(unsigned int BufferId, unsigned char *pBuffer, unsi
 			"%s[%d]BufferId=%d,pBuffer=0x%p,BufferSize=%d\n\r",
 	        __func__, __LINE__, BufferId, pBuffer, BufferSize);
 }
+#ifdef CONFIG_CONTX_USB_DEBUG
+/* only works with 9378 USB v2.3 only work on with some firmwares */
+static u8 seq_for_contx=0;
+extern int txkeepcountmax;
+int SDA_CONTX_COUNT_RESET(void)
+{
+	struct hif_usb_softc *sc;
+	struct ol_softc *pOlsc;
+	VosContextType *pHIFContext = NULL;
+	v_CONTEXT_t pVosContext = NULL;
+
+	if (DA_context.pHddCtx == NULL) {
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
+			"%s: DA_context.ar should not be NULL\n", __func__);
+		return 0;
+	}
+
+	pVosContext = DA_context.pHddCtx->pvosContext;
+	pHIFContext = ((VosContextType*)pVosContext)->pHIFContext;
+	pOlsc = (struct ol_softc *)pHIFContext;
+	sc = pOlsc->hif_sc;
+
+	seq_for_contx = 0;
+	HIFDiagWriteAccess(sc->hif_device, 0x41c240, 0);
+	HIFDiagWriteAccess(sc->hif_device, 0x41c244, 0);
+	HIFDiagWriteAccess(sc->hif_device, 0x41c248, 0);
+	HIFDiagWriteAccess(sc->hif_device, 0x41c24c, 0);
+	msleep(5);  //wait for write to complete
+	return 0;
+}
+
+int SDA_CONTX_COUNT_RESULT(char * extra, A_UINT8 wait_loop)
+{
+	A_UINT32 seq_error = 0, content_err_count = 0, totalcount =0;
+	struct hif_usb_softc *sc;
+	struct ol_softc *pOlsc;
+	VosContextType *pHIFContext = NULL;
+	v_CONTEXT_t pVosContext = NULL;
+
+	if (DA_context.pHddCtx == NULL) {
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
+			"%s: DA_context.ar should not be NULL\n", __func__);
+		return 0;
+	}
+
+	pVosContext = DA_context.pHddCtx->pvosContext;
+	pHIFContext = ((VosContextType*)pVosContext)->pHIFContext;
+	pOlsc = (struct ol_softc *)pHIFContext;
+	sc = pOlsc->hif_sc;
+
+	HIFDiagReadAccess(sc->hif_device, 0x41c24c, &totalcount);
+	while (wait_loop-- && (totalcount != txkeepcountmax)) {
+		pr_err("bus slow wait %d time, (%d)\n",(10 - wait_loop), totalcount);
+		msleep(200);
+		HIFDiagReadAccess(sc->hif_device, 0x41c24c, &totalcount);
+	}
+
+	HIFDiagReadAccess(sc->hif_device, 0x41c244, &seq_error);
+	HIFDiagReadAccess(sc->hif_device, 0x41c248, &content_err_count);
+
+	pr_err(" total %d seq_err %d content_err %d\n", totalcount, seq_error, content_err_count);
+
+	if (extra)
+		snprintf(extra, WE_MAX_STR_LEN, " total %d seq_err %d content_err %d\n", totalcount, seq_error, content_err_count);
+	return 0;
+}
+
+#endif
 
 #ifdef CONFIG_VOS_MEM_PRE_ALLOC
 static u8 gtxdebugbuf[(sizeof(SDA_Header_t)+MAX_BUF_SIZE)*MAX_SHARE_MEM_ITEM];
 static u8 grxdebugbuf[sizeof(struct D_A_SHARE_MEM)*MAX_SHARE_MEM_ITEM];
 #endif
-
-
-int Direct_Audio_TX_debug(void)
+int Direct_Audio_TX_debug(unsigned int usbdbgtxtime)
 {
 	u8	*buf;
 	u32 len,i,BufferSize;
@@ -555,6 +640,15 @@ int Direct_Audio_TX_debug(void)
 #endif
 	SDA_setSharedMemory4Send(0, buf, len, sizeof(SDA_Header_t)+MAX_BUF_SIZE, 50);
 	ptr	= buf;
+#ifdef CONFIG_CONTX_USB_DEBUG
+	if (txkeeprun != 0) {
+		DA_context.vif_id = 1; //p2p0
+		sendcount = MAX_SHARE_MEM_ITEM;
+	} else {
+		DA_context.vif_id = 1; //p2p0
+		sendcount = 5;
+	}
+#endif /* CONFIG_CONTX_USB_DEBUG */
 	//construct tx share memory
 	vif = hdd_get_adapter_by_vdev(DA_context.pHddCtx, DA_context.vif_id);
 	if(!vif)
@@ -568,7 +662,31 @@ int Direct_Audio_TX_debug(void)
 	memset(buf,0x00,len);
 	share_mem_ptr = (SDA_Descriptor_t *)buf;
 	BufferSize = 0;
+#ifdef CONFIG_CONTX_USB_DEBUG
+	for (i=0; i < sendcount; i++) {
+		//fill descript
+		share_mem_ptr->m_ReadyToCopy = 1;
+		share_mem_ptr->m_PayloadSize = 1024;
+		share_mem_ptr->m_TimeStamp = 0;
+		//fill ethernet header
+		eth_ptr = ptr+sizeof(SDA_Header_t)-sizeof(struct ethhdr);
+		eth_hdr = (struct ethhdr *)eth_ptr;
+		memcpy(eth_hdr->h_dest,test_peermac,6);
+		memcpy(eth_hdr->h_source,vif->dev->dev_addr,6);
+		eth_hdr->h_proto = htons(DIRECT_AUDIO_LLC_TYPE);
+		if (usbdbgtxtime != 0 ) {
+			memset(ptr+sizeof(SDA_Header_t),0xa5,share_mem_ptr->m_PayloadSize);
+			memset(ptr+sizeof(SDA_Header_t),seq_for_contx,2+1); /* +2 for aligment in fw */
+			seq_for_contx++;
+		} else {
+			memset(ptr+sizeof(SDA_Header_t),0xa5,share_mem_ptr->m_PayloadSize);
+		}
+		BufferSize += sizeof(SDA_Header_t) + MAX_BUF_SIZE;
+		ptr = ptr + sizeof(SDA_Header_t) + MAX_BUF_SIZE;
+		share_mem_ptr = (SDA_Descriptor_t *)ptr;
+	}
 
+#else
 	for (i=0; i < sendcount; i++) {
 		//fill descript
 		share_mem_ptr->m_ReadyToCopy = 1;
@@ -585,12 +703,12 @@ int Direct_Audio_TX_debug(void)
 		ptr = ptr + sizeof(SDA_Header_t) + MAX_BUF_SIZE;
 		share_mem_ptr = (SDA_Descriptor_t *)ptr;
 	}
+#endif /* CONFIG_CONTX_USB_DEBUG */
 	VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
 		"%s[%d]BufferId=%d,pBuffer=0x%p,BufferSize=%d\n\r",
 	    __func__, __LINE__, 0, buf, BufferSize);
 	//notify Direct Audio module to send packet
 	SDA_function4Send(0, buf, BufferSize);
-
 #ifndef CONFIG_VOS_MEM_PRE_ALLOC
 	kfree(buf);
 #endif
@@ -643,7 +761,7 @@ int Direct_Audio_RX_debug(void)
 	return 0;
 }
 #else
-int Direct_Audio_TX_debug(void)
+int Direct_Audio_TX_debug(unsigned int usbdbgtxtime)
 {
 	return 0;
 }
diff --git a/CORE/HDD/src/wlan_hdd_softap_tx_rx.c b/CORE/HDD/src/wlan_hdd_softap_tx_rx.c
index cede368..c9adcd3 100644
--- a/CORE/HDD/src/wlan_hdd_softap_tx_rx.c
+++ b/CORE/HDD/src/wlan_hdd_softap_tx_rx.c
@@ -214,6 +214,11 @@ void hdd_softap_tx_resume_cb(void *adapter_context,
 }
 #endif /* QCA_LL_TX_FLOW_CT */
 
+#ifdef CONFIG_CONTX_USB_DEBUG
+extern int txkeeprun;
+extern int txkeepruntoofast;
+#endif
+
 /**============================================================================
   @brief hdd_softap_hard_start_xmit() - Function registered with the Linux OS
                                         for transmitting packets.
@@ -335,6 +340,12 @@ int __hdd_softap_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
                 vos_timer_getCurrentState(&pAdapter->tx_flow_control_timer))) {
                hddLog(LOG1, FL("Disabling queues"));
                netif_tx_stop_all_queues(dev);
+#ifdef CONFIG_CONTX_USB_DEBUG
+              if (txkeeprun) {
+	            	  txkeepruntoofast = 1;
+                  pr_err("contx too fast, slow down\n");
+              }
+#endif
                vos_timer_start(&pAdapter->tx_flow_control_timer,
                                WLAN_SAP_HDD_TX_FLOW_CONTROL_OS_Q_BLOCK_TIME);
                pAdapter->hdd_stats.hddTxRxStats.txflow_timer_cnt++;
diff --git a/CORE/HDD/src/wlan_hdd_wext.c b/CORE/HDD/src/wlan_hdd_wext.c
index dbe929c..7ccde21 100644
--- a/CORE/HDD/src/wlan_hdd_wext.c
+++ b/CORE/HDD/src/wlan_hdd_wext.c
@@ -115,11 +115,6 @@
 #define HDD_SET_MCBC_FILTERS_TO_FW      1
 #define HDD_DELETE_MCBC_FILTERS_FROM_FW 0
 
-#ifdef DIRECT_AUDIO_SUPPORT
-extern int Direct_Audio_TX_debug(void);
-extern int Direct_Audio_RX_debug(void);
-#endif
-
 static int ioctl_debug;
 module_param(ioctl_debug, int, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
 
@@ -316,6 +311,8 @@ static const hdd_freq_chan_map_t freq_chan_map[] = { {2412, 1}, {2417, 2},
 #define WE_GET_TEMPERATURE              56
 #define WE_GET_FW_STATUS                57
 #define WE_CAP_TSF                      58
+/* continue usb */
+#define WE_GET_USB_CONTX_DEBUG          59
 
 /* Private ioctls and their sub-ioctls */
 #define WLAN_PRIV_SET_INT_GET_INT     (SIOCIWFIRSTPRIV + 2)
@@ -7415,7 +7412,7 @@ static int __iw_setint_getnone(struct net_device *dev,
                       __func__, set_value ? "TX" : "RX");
 
            if (set_value) {
-               ret = Direct_Audio_TX_debug();
+               ret = Direct_Audio_TX_debug(0);
            } else {
                ret = Direct_Audio_RX_debug();
            }
@@ -8717,6 +8714,37 @@ static int __iw_get_char_setnone(struct net_device *dev,
             wrqu->data.length = strlen(extra) + 1;
             break;
         }
+#if defined(CONFIG_CONTX_USB_DEBUG) && defined(DIRECT_AUDIO_SUPPORT)
+        case WE_GET_USB_CONTX_DEBUG:
+        {
+            hddLog(LOGW, "%s: USB_CONTX for 20000 packets\n", __func__);
+
+            SDA_CONTX_COUNT_RESET();
+
+            txkeeprun = 1;
+            txkeepcountmax = 20000;
+            init_completion(&completion_usbcontx);
+
+            if(!init_sda_work) {
+            	init_sda_work = 1;
+            	INIT_WORK(&sda_contx_work, sda_contx_work_item);
+            }
+
+            schedule_work(&sda_contx_work);
+
+            wait_for_completion_timeout(&completion_usbcontx,
+                                         msecs_to_jiffies(100000));
+
+            msleep(1000);  //wait for qued data to flush
+            SDA_CONTX_COUNT_RESULT(extra, 10);
+            txkeeprun = 0;
+            txkeepcountmax = 2147483647;
+
+            wrqu->data.length = strnlen(extra, WE_MAX_STR_LEN-1)+1;
+            break;
+        }
+
+#endif /* CONFIG_CONTX_USB_DEBUG */
         default:
         {
             hddLog(LOGE, "%s: Invalid IOCTL command %d", __func__, sub_cmd );
@@ -12607,6 +12635,16 @@ static const struct iw_priv_args we_private_args[] = {
         0,
         "dl_fwlog_file" },
 #endif
+#ifdef CONFIG_CONTX_USB_DEBUG
+    {   WE_USB_CONTX_DEBUG,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+        0,
+        "setusbcontx" },
+    {   WE_GET_USB_CONTX_DEBUG,
+        0,
+        IW_PRIV_TYPE_CHAR| WE_MAX_STR_LEN,
+        "getusbcontx" },
+#endif
     {   WE_SET_MON_MODE_CHAN,
         IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2,
         0, "setMonChan" },
-- 
1.7.9.5

