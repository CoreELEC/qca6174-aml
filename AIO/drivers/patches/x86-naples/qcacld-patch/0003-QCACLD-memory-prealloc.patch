From 2bf58fc3c66604c0e4bdf3d71fc2b415995a2fe4 Mon Sep 17 00:00:00 2001
From: Yi Chen <yichen@qti.qualcomm.com>
Date: Mon, 18 Apr 2016 16:48:21 +0800
Subject: [PATCH 3/7] QCACLD memory prealloc. Signed-off-by: Yi Chen
 <yichen@qti.qualcomm.com>

---
 CORE/HDD/src/wlan_hdd_main.c          |   15 ++++
 CORE/SERVICES/COMMON/adf/adf_os_mem.h |   21 +++++-
 CORE/VOSS/inc/vos_memory.h            |   15 ++++
 CORE/VOSS/src/vos_memory.c            |  132 +++++++++++++++++++++++++++++++--
 4 files changed, 175 insertions(+), 8 deletions(-)

diff --git a/CORE/HDD/src/wlan_hdd_main.c b/CORE/HDD/src/wlan_hdd_main.c
index a9bc8d2..206f876 100644
--- a/CORE/HDD/src/wlan_hdd_main.c
+++ b/CORE/HDD/src/wlan_hdd_main.c
@@ -15328,6 +15328,15 @@ static int hdd_driver_init( void)
    pr_info("%s: loading driver v%s\n", WLAN_MODULE_NAME,
            QWLAN_VERSIONSTR TIMER_MANAGER_STR MEMORY_DEBUG_STR);
 
+#ifdef CONFIG_VOS_MEM_PRE_ALLOC
+   status = vos_prealloc_init();
+   if (!VOS_IS_STATUS_SUCCESS(status))
+   {
+     hddLog(VOS_TRACE_LEVEL_FATAL,"%s: Failed to prealloc memory", __func__);
+     ret_status = -1;
+   }
+#endif /* CONFIG_VOS_MEM_PRE_ALLOC */
+
    do {
 
 #ifndef MODULE
@@ -15400,6 +15409,9 @@ static int hdd_driver_init( void)
 #ifdef TIMER_MANAGER
       vos_timer_exit();
 #endif
+#ifdef CONFIG_VOS_MEM_PRE_ALLOC
+      vos_prealloc_deinit();
+#endif
 #ifdef MEMORY_DEBUG
       vos_mem_exit();
 #endif
@@ -15523,6 +15535,9 @@ static void hdd_driver_exit(void)
 #ifdef TIMER_MANAGER
    vos_timer_exit();
 #endif
+#ifdef CONFIG_VOS_MEM_PRE_ALLOC
+   vos_prealloc_deinit();
+#endif
 #ifdef MEMORY_DEBUG
    vos_mem_exit();
 #endif
diff --git a/CORE/SERVICES/COMMON/adf/adf_os_mem.h b/CORE/SERVICES/COMMON/adf/adf_os_mem.h
index a7ba013..2ab6076 100644
--- a/CORE/SERVICES/COMMON/adf/adf_os_mem.h
+++ b/CORE/SERVICES/COMMON/adf/adf_os_mem.h
@@ -44,6 +44,9 @@
 #endif
 
 #include <i_vos_types.h>
+#ifdef CONFIG_VOS_MEM_PRE_ALLOC
+#include <vos_memory.h>
+#endif
 
 #ifdef MEMORY_DEBUG
 #define adf_os_mem_alloc(_osdev, _size) adf_os_mem_alloc_debug(_osdev,\
@@ -70,17 +73,24 @@ adf_os_mem_free_debug(void *buf);
 static inline void *
 adf_os_mem_alloc(adf_os_device_t osdev, adf_os_size_t size)
 {
-#ifdef CONFIG_WCNSS_MEM_PRE_ALLOC
+#if defined(CONFIG_WCNSS_MEM_PRE_ALLOC) || defined(CONFIG_VOS_MEM_PRE_ALLOC)
     void *p_mem;
 #endif
 
-#ifdef CONFIG_WCNSS_MEM_PRE_ALLOC
+#if defined(CONFIG_WCNSS_MEM_PRE_ALLOC)
    if (size > WCNSS_PRE_ALLOC_GET_THRESHOLD)
    {
        p_mem = wcnss_prealloc_get(size);
        if (NULL != p_mem)
            return p_mem;
    }
+#elif defined(CONFIG_VOS_MEM_PRE_ALLOC)
+	if (size > VOS_PRE_ALLOC_GET_THRESHOLD)
+	{
+		p_mem = vos_prealloc_get(size);
+		if (NULL != p_mem)
+			return p_mem;
+	}
 #endif
 
     return __adf_os_mem_alloc(osdev, size);
@@ -94,11 +104,16 @@ adf_os_mem_alloc(adf_os_device_t osdev, adf_os_size_t size)
 static inline void
 adf_os_mem_free(void *buf)
 {
-#ifdef CONFIG_WCNSS_MEM_PRE_ALLOC
+#if defined(CONFIG_WCNSS_MEM_PRE_ALLOC)
     if (wcnss_prealloc_put(buf))
     {
         return;
     }
+#elif defined(CONFIG_VOS_MEM_PRE_ALLOC)
+	if (vos_prealloc_put(buf))
+	{
+		return;
+	}
 #endif
 
     __adf_os_mem_free(buf);
diff --git a/CORE/VOSS/inc/vos_memory.h b/CORE/VOSS/inc/vos_memory.h
index 2147f24..9879504 100644
--- a/CORE/VOSS/inc/vos_memory.h
+++ b/CORE/VOSS/inc/vos_memory.h
@@ -89,6 +89,21 @@ v_VOID_t *vos_mem_malloc_debug(v_SIZE_t size, const char *fileName,
 v_VOID_t * vos_mem_malloc( v_SIZE_t size );
 #endif
 
+#ifdef CONFIG_VOS_MEM_PRE_ALLOC
+#define VOS_PRE_ALLOC_GET_THRESHOLD (16*1024)
+
+struct vos_prealloc {
+	v_UINT_t occupied;
+	v_UINT_t size;
+	v_VOID_t *ptr;
+};
+
+v_UINT_t vos_prealloc_init(v_VOID_t);
+v_VOID_t vos_prealloc_deinit(v_VOID_t);
+v_SINT_t vos_prealloc_put(v_VOID_t *ptr);
+v_VOID_t *vos_prealloc_get(v_UINT_t size);
+
+#endif /* CONFIG_VOS_MEM_PRE_ALLOC */
 
 /*----------------------------------------------------------------------------
 
diff --git a/CORE/VOSS/src/vos_memory.c b/CORE/VOSS/src/vos_memory.c
index 9012401..8f84152 100644
--- a/CORE/VOSS/src/vos_memory.c
+++ b/CORE/VOSS/src/vos_memory.c
@@ -62,6 +62,11 @@
 #include <net/cnss_prealloc.h>
 #endif
 
+#ifdef CONFIG_VOS_MEM_PRE_ALLOC
+#include <vos_getBin.h>
+#include <epping_main.h>
+#endif
+
 #ifdef MEMORY_DEBUG
 #include "wlan_hdd_dp_utils.h"
 #include <linux/stacktrace.h>
@@ -107,6 +112,34 @@ static struct s_vos_mem_usage_struct g_usage_mem_buf[MAX_USAGE_TRACE_BUF_NUM];
 
 #define VOS_GET_MEMORY_TIME_THRESHOLD 300
 
+#ifdef CONFIG_VOS_MEM_PRE_ALLOC
+static DEFINE_MUTEX(alloc_lock);
+
+/* pre-alloced at load time
+ * following three definition must fit
+ * to avoid memory corruption */
+#define TOTOTAL_PRELOCATE (32*10 + 64*2 + 128*1 + 256*1)*1024
+static struct vos_prealloc vos_allocs[] = {
+	{0, 32 * 1024, NULL},
+	{0, 32 * 1024, NULL},
+	{0, 32 * 1024, NULL},
+	{0, 32 * 1024, NULL},
+	{0, 32 * 1024, NULL},
+	{0, 32 * 1024, NULL},
+	{0, 32 * 1024, NULL},
+	{0, 32 * 1024, NULL},
+	{0, 32 * 1024, NULL},
+	{0, 32 * 1024, NULL},
+	{0, 64 * 1024, NULL},
+	{0, 64 * 1024, NULL},
+	{0, 128 * 1024, NULL},
+	{0, 256 * 1024, NULL},
+};
+
+v_BYTE_t pre_alloc_pool[TOTOTAL_PRELOCATE];
+
+#endif /* CONFIG_VOS_MEM_PRE_ALLOC */
+
 /*---------------------------------------------------------------------------
  * Type Declarations
  * ------------------------------------------------------------------------*/
@@ -118,6 +151,74 @@ static struct s_vos_mem_usage_struct g_usage_mem_buf[MAX_USAGE_TRACE_BUF_NUM];
 /*---------------------------------------------------------------------------
  * External Function implementation
  * ------------------------------------------------------------------------*/
+
+#ifdef CONFIG_VOS_MEM_PRE_ALLOC
+
+/* pre-alloced at load time*/
+v_UINT_t vos_prealloc_init(v_VOID_t)
+{
+	v_UINT_t i;
+	v_UINT_t alloc_pos = 0;
+
+	for (i = 0; i < ARRAY_SIZE(vos_allocs); i++) {
+		vos_allocs[i].occupied = 0;
+		vos_allocs[i].ptr = &pre_alloc_pool[alloc_pos];
+		alloc_pos += vos_allocs[i].size;
+		if (alloc_pos > TOTOTAL_PRELOCATE)
+			return -ENOMEM;
+	}
+	return 0;
+}
+v_VOID_t vos_prealloc_deinit(v_VOID_t)
+{
+	v_UINT_t i;
+
+	for (i = 0; i < ARRAY_SIZE(vos_allocs); i++)
+		vos_allocs[i].occupied = 0;
+}
+v_VOID_t *vos_prealloc_get(v_UINT_t size)
+{
+	v_UINT_t i = 0;
+
+	if (WLAN_IS_EPPING_ENABLED(vos_get_conparam()))
+		return NULL;
+
+	mutex_lock(&alloc_lock);
+	for (i = 0; i < ARRAY_SIZE(vos_allocs); i++) {
+		if (vos_allocs[i].occupied)
+			continue;
+		if (vos_allocs[i].size > size) {
+			/* we found the slot */
+			vos_allocs[i].occupied = 1;
+			mutex_unlock(&alloc_lock);
+			return vos_allocs[i].ptr;
+		}
+	}
+	VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_FATAL,
+		"vos_pre: %s: prealloc not available at size %d\n", __func__, size);
+	mutex_unlock(&alloc_lock);
+	return NULL;
+}
+
+v_SINT_t vos_prealloc_put(v_VOID_t *ptr)
+{
+	v_UINT_t i = 0;
+
+	if (WLAN_IS_EPPING_ENABLED(vos_get_conparam()))
+		return 0;
+	mutex_lock(&alloc_lock);
+	for (i = 0; i < ARRAY_SIZE(vos_allocs); i++) {
+		if (vos_allocs[i].ptr == ptr) {
+			vos_allocs[i].occupied = 0;
+			mutex_unlock(&alloc_lock);
+			return 1;
+		}
+	}
+	mutex_unlock(&alloc_lock);
+	return 0;
+}
+#endif /* CONFIG_VOS_MEM_PRE_ALLOC */
+
 #ifdef MEMORY_DEBUG
 #ifdef MEM_USAGE_TRACE
 static void
@@ -413,7 +514,7 @@ v_VOID_t *vos_mem_malloc_debug(v_SIZE_t size, const char *fileName,
        flags = GFP_ATOMIC;
    }
 
-#ifdef CONFIG_WCNSS_MEM_PRE_ALLOC
+#if defined(CONFIG_WCNSS_MEM_PRE_ALLOC)
    if (size > WCNSS_PRE_ALLOC_GET_THRESHOLD)
    {
       v_VOID_t *pmem;
@@ -423,6 +524,14 @@ v_VOID_t *vos_mem_malloc_debug(v_SIZE_t size, const char *fileName,
          return pmem;
       }
    }
+#elif defined(CONFIG_VOS_MEM_PRE_ALLOC)
+	if (size > VOS_PRE_ALLOC_GET_THRESHOLD)
+	{
+		v_VOID_t *pmem;
+		pmem = vos_prealloc_get(size);
+		if (NULL != pmem)
+			return pmem;
+	}
 #endif
 
    new_size = size + sizeof(struct s_vos_mem_struct) + 8;
@@ -480,9 +589,12 @@ v_VOID_t vos_mem_free( v_VOID_t *ptr )
         VOS_STATUS vosStatus;
         struct s_vos_mem_struct* memStruct = ((struct s_vos_mem_struct*)ptr) - 1;
 
-#ifdef CONFIG_WCNSS_MEM_PRE_ALLOC
+#if defined(CONFIG_WCNSS_MEM_PRE_ALLOC)
         if (wcnss_prealloc_put(ptr))
             return;
+#elif defined(CONFIG_VOS_MEM_PRE_ALLOC)
+		if (vos_prealloc_put(ptr))
+   			return;
 #endif
 
         spin_lock_irqsave(&vosMemList.lock, IrqFlags);
@@ -521,7 +633,7 @@ v_VOID_t vos_mem_free( v_VOID_t *ptr )
 v_VOID_t * vos_mem_malloc( v_SIZE_t size )
 {
    int flags = GFP_KERNEL;
-#ifdef CONFIG_WCNSS_MEM_PRE_ALLOC
+#if defined(CONFIG_WCNSS_MEM_PRE_ALLOC) || defined(CONFIG_VOS_MEM_PRE_ALLOC)
     v_VOID_t* pmem;
 #endif
    v_VOID_t* memPtr = NULL;
@@ -538,7 +650,7 @@ v_VOID_t * vos_mem_malloc( v_SIZE_t size )
    {
       flags = GFP_ATOMIC;
    }
-#ifdef CONFIG_WCNSS_MEM_PRE_ALLOC
+#if defined(CONFIG_WCNSS_MEM_PRE_ALLOC)
    if(size > WCNSS_PRE_ALLOC_GET_THRESHOLD)
    {
        pmem = wcnss_prealloc_get(size);
@@ -547,6 +659,13 @@ v_VOID_t * vos_mem_malloc( v_SIZE_t size )
            return pmem;
        }
    }
+#elif defined(CONFIG_VOS_MEM_PRE_ALLOC)
+	if(size > VOS_PRE_ALLOC_GET_THRESHOLD)
+	{
+		pmem = vos_prealloc_get(size);
+		if(NULL != pmem)
+			return pmem;
+	}
 #endif
    time_before_kmalloc = vos_timer_get_system_time();
    memPtr = kmalloc(size, flags);
@@ -571,9 +690,12 @@ v_VOID_t vos_mem_free( v_VOID_t *ptr )
     if (ptr == NULL)
       return;
 
-#ifdef CONFIG_WCNSS_MEM_PRE_ALLOC
+#if defined(CONFIG_WCNSS_MEM_PRE_ALLOC)
     if(wcnss_prealloc_put(ptr))
         return;
+#elif defined(CONFIG_VOS_MEM_PRE_ALLOC)
+    if(vos_prealloc_put(ptr))
+        return;
 #endif
 
     kfree(ptr);
-- 
1.7.9.5

