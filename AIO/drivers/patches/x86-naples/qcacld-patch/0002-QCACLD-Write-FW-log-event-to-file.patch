From b2f04094b741c8a1bf90832a8f188c42ff04ab03 Mon Sep 17 00:00:00 2001
From: Yi Chen <yichen@qti.qualcomm.com>
Date: Mon, 18 Apr 2016 16:35:42 +0800
Subject: [PATCH 2/7] QCACLD Write FW log event to file. Signed-off-by: Yi
 Chen <yichen@qti.qualcomm.com>

---
 CORE/HDD/inc/qc_sap_ioctl.h        |    2 +
 CORE/HDD/inc/wlan_hdd_main.h       |    4 +
 CORE/HDD/src/wlan_hdd_hostapd.c    |   18 ++
 CORE/HDD/src/wlan_hdd_wext.c       |   40 +++++
 CORE/SERVICES/COMMON/dbglog_host.h |   10 ++
 CORE/SERVICES/COMMON/wmi_unified.h |    6 +-
 CORE/SERVICES/WMA/wma.c            |   14 ++
 CORE/UTILS/FWLOG/dbglog_host.c     |  326 ++++++++++++++++++++++++++++++++++++
 8 files changed, 419 insertions(+), 1 deletion(-)

diff --git a/CORE/HDD/inc/qc_sap_ioctl.h b/CORE/HDD/inc/qc_sap_ioctl.h
index 256c14d..ef97045 100644
--- a/CORE/HDD/inc/qc_sap_ioctl.h
+++ b/CORE/HDD/inc/qc_sap_ioctl.h
@@ -266,6 +266,8 @@ enum {
     QCASAP_PARAM_TX_STBC,
     QCASAP_PARAM_RX_STBC,
     QCASAP_SET_RADAR_DBG,
+    QCSAP_DBGLOG_FWLOG_FILE_ENABLE,
+    QCSAP_DBGLOG_FWLOG_FILE_MAX_SIZE,
 };
 
 int iw_get_channel_list(struct net_device *dev,
diff --git a/CORE/HDD/inc/wlan_hdd_main.h b/CORE/HDD/inc/wlan_hdd_main.h
index 19b6665..3658488 100644
--- a/CORE/HDD/inc/wlan_hdd_main.h
+++ b/CORE/HDD/inc/wlan_hdd_main.h
@@ -1306,6 +1306,10 @@ typedef struct
     v_U8_t dl_loglevel;
     v_U8_t index;
     v_U32_t dl_mod_loglevel[MAX_MOD_LOGLEVEL];
+#ifdef CONFIG_WLAN_FWLOG_FILE
+    v_U8_t dl_fwlog_file;
+    v_U32_t dl_fwlog_file_max_size;
+#endif
 
 }fw_log_info;
 
diff --git a/CORE/HDD/src/wlan_hdd_hostapd.c b/CORE/HDD/src/wlan_hdd_hostapd.c
index 4998af6..8e0e24c 100644
--- a/CORE/HDD/src/wlan_hdd_hostapd.c
+++ b/CORE/HDD/src/wlan_hdd_hostapd.c
@@ -3008,6 +3008,24 @@ static __iw_softap_setparam(struct net_device *dev,
                                                set_value, DBG_CMD);
                   break;
              }
+#ifdef CONFIG_WLAN_FWLOG_FILE
+        case QCSAP_DBGLOG_FWLOG_FILE_ENABLE:
+             {
+                  hddLog(LOG1, "QCSAP_DBGLOG_FWLOG_FILE_ENABLE val %d", set_value);
+                  ret = process_wma_set_command((int)pHostapdAdapter->sessionId,
+                                               (int)WMI_DBGLOG_FWLOG_FILE_ENABLE,
+                                               set_value, DBG_CMD);
+                  break;
+             }
+        case QCSAP_DBGLOG_FWLOG_FILE_MAX_SIZE:
+             {
+                  hddLog(LOG1, "QCSAP_DBGLOG_FWLOG_FILE_MAX_SIZE val %d", set_value);
+                  ret = process_wma_set_command((int)pHostapdAdapter->sessionId,
+                                               (int)WMI_DBGLOG_FWLOG_FILE_MAX_SIZE,
+                                               set_value, DBG_CMD);
+                  break;
+             }
+#endif
          case QCSAP_PARAM_SET_MCC_CHANNEL_LATENCY:
              {
                   tVOS_CONCURRENCY_MODE concurrent_state = 0;
diff --git a/CORE/HDD/src/wlan_hdd_wext.c b/CORE/HDD/src/wlan_hdd_wext.c
index a5ccce3..90b0075 100644
--- a/CORE/HDD/src/wlan_hdd_wext.c
+++ b/CORE/HDD/src/wlan_hdd_wext.c
@@ -242,6 +242,12 @@ static const hdd_freq_chan_map_t freq_chan_map[] = { {2412, 1}, {2417, 2},
 #define WE_DUMP_STATS                         85
 #define WE_CLEAR_STATS                        86
 #define WE_SET_CHANNEL                        87
+#ifdef CONFIG_WLAN_FWLOG_FILE
+#define WE_DBGLOG_FWLOG_FILE_ENABLE           88
+#endif
+#ifdef CONFIG_WLAN_FWLOG_FILE
+#define WE_DBGLOG_FWLOG_FILE_MAX_SIZE         89
+#endif
 
 
 /* Private ioctls and their sub-ioctls */
@@ -6983,6 +6989,27 @@ static int __iw_setint_getnone(struct net_device *dev,
              break;
         }
 
+#ifdef CONFIG_WLAN_FWLOG_FILE
+        case WE_DBGLOG_FWLOG_FILE_ENABLE:
+        {
+             hddLog(LOG1, "WE_DBGLOG_FWLOG_FILE_ENABLE val %d", set_value);
+             pHddCtx->fw_log_settings.dl_fwlog_file = set_value;
+             ret = process_wma_set_command((int)pAdapter->sessionId,
+                                          (int)WMI_DBGLOG_FWLOG_FILE_ENABLE,
+                                          set_value, DBG_CMD);
+             break;
+        }
+        case WE_DBGLOG_FWLOG_FILE_MAX_SIZE:
+        {
+             hddLog(LOG1, "WE_DBGLOG_FWLOG_FILE_MAX_SIZE val %d", set_value);
+             pHddCtx->fw_log_settings.dl_fwlog_file_max_size = set_value;
+             ret = process_wma_set_command((int)pAdapter->sessionId,
+                                          (int)WMI_DBGLOG_FWLOG_FILE_MAX_SIZE,
+                                          set_value, DBG_CMD);
+             break;
+        }
+#endif
+
     case WE_SET_TXRX_FWSTATS:
     {
            hddLog(LOG1, "WE_SET_TXRX_FWSTATS val %d", set_value);
@@ -12437,6 +12464,13 @@ static const struct iw_priv_args we_private_args[] = {
         0,
         "gpio_control" },
 #endif
+#ifdef CONFIG_WLAN_FWLOG_FILE
+    {   WE_DBGLOG_FWLOG_FILE_MAX_SIZE,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+        0,
+        "dl_fwlog_size" },
+#endif
+
 
 #ifdef MEMORY_DEBUG
     /* handlers for sub ioctl */
@@ -12540,6 +12574,12 @@ static const struct iw_priv_args we_private_args[] = {
         IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2,
         0, "crash_inject" },
 #endif
+#ifdef CONFIG_WLAN_FWLOG_FILE
+    {   WE_DBGLOG_FWLOG_FILE_ENABLE,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+        0,
+        "dl_fwlog_file" },
+#endif
     {   WE_SET_MON_MODE_CHAN,
         IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2,
         0, "setMonChan" },
diff --git a/CORE/SERVICES/COMMON/dbglog_host.h b/CORE/SERVICES/COMMON/dbglog_host.h
index d17acc5..3115740 100644
--- a/CORE/SERVICES/COMMON/dbglog_host.h
+++ b/CORE/SERVICES/COMMON/dbglog_host.h
@@ -185,6 +185,16 @@ dbglog_set_timestamp_resolution(wmi_unified_t  wmi_handle, A_UINT16 tsr);
 int
 dbglog_report_enable(wmi_unified_t  wmi_handle, A_BOOL isenable);
 
+#ifdef CONFIG_WLAN_FWLOG_FILE
+/** Enable write fwlog into a file */
+int
+dbglog_fwlog_file_enable(wmi_unified_t  wmi_handle, A_BOOL isenable);
+
+/** set max size of fwlog file */
+int
+dbglog_fwlog_file_max_size (wmi_unified_t  wmi_handle, A_UINT32 size);
+#endif
+
 /** Set the log level
 * @brief DBGLOG_INFO - Information lowest log level
 * @brief DBGLOG_WARNING
diff --git a/CORE/SERVICES/COMMON/wmi_unified.h b/CORE/SERVICES/COMMON/wmi_unified.h
index 3347177..b6dd041 100644
--- a/CORE/SERVICES/COMMON/wmi_unified.h
+++ b/CORE/SERVICES/COMMON/wmi_unified.h
@@ -3555,7 +3555,11 @@ typedef enum {
     /** set type of the debug output */
     WMI_DBGLOG_TYPE,
     /** Enable Disable debug */
-    WMI_DBGLOG_REPORT_ENABLE
+    WMI_DBGLOG_REPORT_ENABLE,
+    /** Enable fwlog write to file */
+    WMI_DBGLOG_FWLOG_FILE_ENABLE,
+    /** set max size of fwlog file */
+    WMI_DBGLOG_FWLOG_FILE_MAX_SIZE,
 } WMI_DBG_PARAM;
 
 /* param_value for param_id WMI_PDEV_PARAM_CTS_CBW */
diff --git a/CORE/SERVICES/WMA/wma.c b/CORE/SERVICES/WMA/wma.c
index 448700e..8ed5149 100644
--- a/CORE/SERVICES/WMA/wma.c
+++ b/CORE/SERVICES/WMA/wma.c
@@ -14454,6 +14454,20 @@ static void wma_process_cli_set_cmd(tp_wma_handle wma,
 				WMA_LOGE("dbglog_report_enable"
 						" failed ret %d", ret);
 			break;
+#ifdef CONFIG_WLAN_FWLOG_FILE
+		case WMI_DBGLOG_FWLOG_FILE_ENABLE:
+                        ret = dbglog_fwlog_file_enable(wma->wmi_handle, privcmd->param_value);
+			if (ret)
+				WMA_LOGE("dbglog_fwlog_file_enable"
+						" failed ret %d", ret);
+			break;
+                case WMI_DBGLOG_FWLOG_FILE_MAX_SIZE:
+                        ret = dbglog_fwlog_file_max_size(wma->wmi_handle, privcmd->param_value);
+                        if (ret)
+                                WMA_LOGE("dbglog_fwlog_file_max_size"
+                                                " failed ret %d", ret);
+                        break;
+#endif
 #ifdef FEATURE_GREEN_AP
 		case WMI_PDEV_GREEN_AP_PS_ENABLE_CMDID:
 			/* Set the Green AP */
diff --git a/CORE/UTILS/FWLOG/dbglog_host.c b/CORE/UTILS/FWLOG/dbglog_host.c
index ff73b3c..8cd05a0 100644
--- a/CORE/UTILS/FWLOG/dbglog_host.c
+++ b/CORE/UTILS/FWLOG/dbglog_host.c
@@ -1269,6 +1269,112 @@ char * DBG_MSG_ARR[WLAN_MODULE_ID_MAX][MAX_DBG_MSGS] =
     },
 };
 
+#ifdef CONFIG_WLAN_FWLOG_FILE
+extern int _readwrite_file(const char *filename, char *rbuf,
+                           const char *wbuf, size_t length, int mode);
+
+#define FWLOG_FILE_BUF_MAX_DEFAULT_SIZE	  (16*1024) /* default 16k */
+#define FWLOG_FILE_BUF_THREHOLD           (12*1024) /* default 12k */
+#define FWLOG_FILE_MAX_DEFAULT_SIZE       (10*1024*1024) /* default 10M */
+#define FWLOG_FILE_DEFAULT_PATH           "/opt/var/log/cld_fw.log"
+
+struct _dbglog_fwlog_file {
+    A_UINT8  print_to_file;
+    A_UINT32 file_max_size;
+    A_UINT8  file_path_and_name[64];
+    A_UINT32 file_size;
+    A_UINT32 buf_used_size;
+    A_UINT32 buf_free_size;
+    A_UINT8* buf_free_idx;
+    struct mutex lock;
+    struct work_struct work;
+    adf_os_timer_t timer;
+    A_UINT8* buf;
+    A_UINT32 overflow;
+} dbglog_fwlog_file_ctx;
+
+inline void dbglog_fwlog_file_trunc(void)
+{
+
+    _readwrite_file(dbglog_fwlog_file_ctx.file_path_and_name, NULL,
+                    NULL, 0, (O_WRONLY | O_CREAT | O_TRUNC));
+
+    dbglog_fwlog_file_ctx.file_size = 0;
+}
+
+
+void dbglog_fwlog_file_write_file(void)
+{
+    int ret;
+
+    if (dbglog_fwlog_file_ctx.buf_used_size) {
+        if (dbglog_fwlog_file_ctx.file_size >= dbglog_fwlog_file_ctx.file_max_size) {
+            dbglog_fwlog_file_trunc();
+        }
+        ret = _readwrite_file(dbglog_fwlog_file_ctx.file_path_and_name, NULL,
+                              dbglog_fwlog_file_ctx.buf,
+                              dbglog_fwlog_file_ctx.buf_used_size,
+                              (O_WRONLY | O_APPEND | O_CREAT));
+        if (ret < 0) {
+            printk("%s:%d: fail to write\n", __func__, __LINE__);
+            return;
+        }
+
+        dbglog_fwlog_file_ctx.buf_free_idx = dbglog_fwlog_file_ctx.buf;
+        dbglog_fwlog_file_ctx.file_size += dbglog_fwlog_file_ctx.buf_used_size;
+        dbglog_fwlog_file_ctx.buf_used_size = 0;
+        dbglog_fwlog_file_ctx.buf_free_size = FWLOG_FILE_BUF_MAX_DEFAULT_SIZE;
+    }
+}
+
+
+void dbglog_fwlog_file_thread(struct work_struct *work)
+{
+    mutex_lock(&dbglog_fwlog_file_ctx.lock);
+    dbglog_fwlog_file_write_file();
+    mutex_unlock(&dbglog_fwlog_file_ctx.lock);
+}
+
+
+void dbglog_fwlog_file_timeout_handler(void* ctx)
+{
+    schedule_work(&dbglog_fwlog_file_ctx.work);
+}
+
+int dbglog_fwlog_file_init(void)
+{
+    dbglog_fwlog_file_ctx.buf = kmalloc(FWLOG_FILE_BUF_MAX_DEFAULT_SIZE, GFP_KERNEL);
+    if (dbglog_fwlog_file_ctx.buf == NULL) {
+        printk("%s:%d: not enough mem\n", __func__, __LINE__);
+        return -ENOMEM;
+    }
+
+    dbglog_fwlog_file_ctx.print_to_file = 0;
+    dbglog_fwlog_file_ctx.overflow = 0;
+    dbglog_fwlog_file_ctx.file_max_size = FWLOG_FILE_MAX_DEFAULT_SIZE;
+    memcpy(dbglog_fwlog_file_ctx.file_path_and_name,
+           FWLOG_FILE_DEFAULT_PATH,
+           sizeof(dbglog_fwlog_file_ctx.file_path_and_name));
+    dbglog_fwlog_file_ctx.file_size = 0;
+    dbglog_fwlog_file_ctx.buf_used_size = 0;
+    dbglog_fwlog_file_ctx.buf_free_size = FWLOG_FILE_BUF_MAX_DEFAULT_SIZE;
+    dbglog_fwlog_file_ctx.buf_free_idx = dbglog_fwlog_file_ctx.buf;
+    mutex_init(&dbglog_fwlog_file_ctx.lock);
+    INIT_WORK(&dbglog_fwlog_file_ctx.work, dbglog_fwlog_file_thread);
+    adf_os_timer_init(NULL, &dbglog_fwlog_file_ctx.timer, dbglog_fwlog_file_timeout_handler, NULL, ADF_DEFERRABLE_TIMER);
+
+    return 0;
+}
+
+void dbglog_fwlog_file_deinit(void)
+{
+    adf_os_timer_cancel(&dbglog_fwlog_file_ctx.timer);
+    adf_os_timer_free(&dbglog_fwlog_file_ctx.timer);
+    flush_work(&dbglog_fwlog_file_ctx.work);
+    mutex_unlock(&dbglog_fwlog_file_ctx.lock);
+    kfree(dbglog_fwlog_file_ctx.buf);
+}
+#endif
 int dbglog_module_log_enable(wmi_unified_t  wmi_handle, A_UINT32 mod_id,
                   bool isenable)
 {
@@ -1406,6 +1512,36 @@ dbglog_set_mod_enable_bitmap(wmi_unified_t  wmi_handle,A_UINT32 log_level, A_UIN
 			mod_enable_bitmap,bitmap_len);
 }
 
+#ifdef CONFIG_WLAN_FWLOG_FILE
+int dbglog_fwlog_file_enable(wmi_unified_t  wmi_handle, bool isenable)
+{
+	if (isenable > TRUE) {
+		AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("dbglog_fwlog_file_enable:Invalid value %d\n",
+						isenable));
+		return -EINVAL;
+	}
+
+	if (isenable) {
+		dbglog_fwlog_file_ctx.print_to_file = 1;
+		dbglog_fwlog_file_trunc();
+	} else {
+		dbglog_fwlog_file_ctx.print_to_file = 0;
+	}
+	return 0;
+}
+
+
+int dbglog_fwlog_file_max_size(wmi_unified_t  wmi_handle, A_UINT32 size)
+{
+        if (size == 0) {
+             dbglog_fwlog_file_ctx.file_max_size = FWLOG_FILE_MAX_DEFAULT_SIZE;
+        } else {
+             dbglog_fwlog_file_ctx.file_max_size = size;
+        }
+        return 0;
+}
+#endif
+
 int dbglog_report_enable(wmi_unified_t  wmi_handle, bool isenable)
 {
     int bitmap[2] = {0};
@@ -1423,6 +1559,9 @@ int dbglog_report_enable(wmi_unified_t  wmi_handle, bool isenable)
 	bitmap[1] = 0x1F;
 	/* set the module level bitmap  */
 	dbglog_set_mod_enable_bitmap(wmi_handle, 0x0, bitmap, 2);
+#ifdef CONFIG_WLAN_FWLOG_FILE
+	dbglog_fwlog_file_trunc();
+#endif
     } else {
         dbglog_set_vap_enable_bitmap(wmi_handle, bitmap[0]);
         dbglog_set_mod_enable_bitmap(wmi_handle, DBGLOG_LVL_MAX, bitmap, 2);
@@ -1457,6 +1596,58 @@ dbglog_printf(
 {
     char buf[128];
     va_list ap;
+#ifdef CONFIG_WLAN_FWLOG_FILE
+    int len = 0;
+
+    if (dbglog_fwlog_file_ctx.print_to_file) {
+        mutex_lock(&dbglog_fwlog_file_ctx.lock);
+
+        if (dbglog_fwlog_file_ctx.buf_used_size  == 0) {
+	    adf_os_timer_cancel(&dbglog_fwlog_file_ctx.timer);
+            adf_os_timer_start(&dbglog_fwlog_file_ctx.timer, 100);
+        }
+
+        if (dbglog_fwlog_file_ctx.buf_free_size <= 120) {
+            dbglog_fwlog_file_ctx.overflow++;
+            printk("%s:%d: overflow:%u\n", __func__, __LINE__, dbglog_fwlog_file_ctx.overflow);
+            mutex_unlock(&dbglog_fwlog_file_ctx.lock);
+            return;
+        }
+
+	if (vap_id < DBGLOG_MAX_VDEVID) {
+            len = snprintf(dbglog_fwlog_file_ctx.buf_free_idx, dbglog_fwlog_file_ctx.buf_free_size,
+                           "[%u] vap-%u ", timestamp, vap_id);
+	} else {
+            len = snprintf(dbglog_fwlog_file_ctx.buf_free_idx, dbglog_fwlog_file_ctx.buf_free_size,
+                           "[%u] ", timestamp);
+	}
+
+        va_start(ap, fmt);
+        len += vsnprintf(dbglog_fwlog_file_ctx.buf_free_idx + len, dbglog_fwlog_file_ctx.buf_free_size - len, fmt, ap);
+	dbglog_fwlog_file_ctx.buf_free_idx[len] = '\n';
+	len++;
+        dbglog_fwlog_file_ctx.buf_free_idx += len;
+        dbglog_fwlog_file_ctx.buf_used_size += len;
+        dbglog_fwlog_file_ctx.buf_free_size -= len;
+        va_end(ap);
+        if ((dbglog_fwlog_file_ctx.buf_used_size >= FWLOG_FILE_BUF_THREHOLD) ||
+            ((dbglog_fwlog_file_ctx.file_size + dbglog_fwlog_file_ctx.buf_used_size) >= dbglog_fwlog_file_ctx.file_max_size)) {
+            adf_os_timer_cancel(&dbglog_fwlog_file_ctx.timer);
+            dbglog_fwlog_file_write_file();
+        }
+        mutex_unlock(&dbglog_fwlog_file_ctx.lock);
+    } else {
+        if (vap_id < DBGLOG_MAX_VDEVID) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (DBGLOG_PRINT_PREFIX "[%u] vap-%u ", timestamp, vap_id));
+        } else {
+            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (DBGLOG_PRINT_PREFIX "[%u] ", timestamp));
+        }
+        va_start(ap, fmt);
+        vsnprintf(buf, sizeof(buf), fmt, ap);
+        va_end(ap);
+        AR_DEBUG_PRINTF(ATH_DEBUG_INFO, ("%s\n", buf));
+    }
+#else
 
     if (vap_id < DBGLOG_MAX_VDEVID) {
         AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (DBGLOG_PRINT_PREFIX "[%u] vap-%u ", timestamp, vap_id));
@@ -1469,6 +1660,7 @@ dbglog_printf(
     va_end(ap);
 
     AR_DEBUG_PRINTF(ATH_DEBUG_INFO, ("%s\n", buf));
+#endif
 }
 
 void
@@ -1479,6 +1671,60 @@ dbglog_printf_no_line_break(
 {
     char buf[128];
     va_list ap;
+#ifdef CONFIG_WLAN_FWLOG_FILE
+    int len = 0;
+
+    if (dbglog_fwlog_file_ctx.print_to_file) {
+        mutex_lock(&dbglog_fwlog_file_ctx.lock);
+
+        if (dbglog_fwlog_file_ctx.buf_used_size  == 0) {
+	    adf_os_timer_cancel(&dbglog_fwlog_file_ctx.timer);
+            adf_os_timer_start(&dbglog_fwlog_file_ctx.timer, 100);
+        }
+
+        if (dbglog_fwlog_file_ctx.buf_free_size <= 120) {
+            dbglog_fwlog_file_ctx.overflow++;
+            printk("%s:%d: overflow:%u\n", __func__, __LINE__, dbglog_fwlog_file_ctx.overflow);
+            mutex_unlock(&dbglog_fwlog_file_ctx.lock);
+            return;
+        }
+
+	if (vap_id < DBGLOG_MAX_VDEVID) {
+		len = snprintf(dbglog_fwlog_file_ctx.buf_free_idx, dbglog_fwlog_file_ctx.buf_free_size,
+			"[%u] vap-%u ", timestamp, vap_id);
+	} else {
+		len = snprintf(dbglog_fwlog_file_ctx.buf_free_idx, dbglog_fwlog_file_ctx.buf_free_size,
+			"[%u] ", timestamp);
+	}
+
+        va_start(ap, fmt);
+        len += vsnprintf(dbglog_fwlog_file_ctx.buf_free_idx + len, dbglog_fwlog_file_ctx.buf_free_size - len, fmt, ap);
+	dbglog_fwlog_file_ctx.buf_free_idx[len] = '\n';
+	len++;
+        dbglog_fwlog_file_ctx.buf_free_idx += len;
+        dbglog_fwlog_file_ctx.buf_used_size += len;
+        dbglog_fwlog_file_ctx.buf_free_size -= len;
+        va_end(ap);
+        if ((dbglog_fwlog_file_ctx.buf_used_size >= FWLOG_FILE_BUF_THREHOLD) ||
+            ((dbglog_fwlog_file_ctx.file_size + dbglog_fwlog_file_ctx.buf_used_size) >= dbglog_fwlog_file_ctx.file_max_size)) {
+            adf_os_timer_cancel(&dbglog_fwlog_file_ctx.timer);
+            dbglog_fwlog_file_write_file();
+        }
+        mutex_unlock(&dbglog_fwlog_file_ctx.lock);
+    } else {
+        if (vap_id < DBGLOG_MAX_VDEVID) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (DBGLOG_PRINT_PREFIX "[%u] vap-%u ", timestamp, vap_id));
+        } else {
+            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (DBGLOG_PRINT_PREFIX "[%u] ", timestamp));
+        }
+
+        va_start(ap, fmt);
+        vsnprintf(buf, sizeof(buf), fmt, ap);
+        va_end(ap);
+
+        AR_DEBUG_PRINTF(ATH_DEBUG_INFO, ("%s", buf));
+    }
+#else
 
     if (vap_id < DBGLOG_MAX_VDEVID) {
         AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (DBGLOG_PRINT_PREFIX "[%u] vap-%u ", timestamp, vap_id));
@@ -1491,6 +1737,7 @@ dbglog_printf_no_line_break(
     va_end(ap);
 
     AR_DEBUG_PRINTF(ATH_DEBUG_INFO, ("%s", buf));
+#endif
 }
 
 #define USE_NUMERIC 0
@@ -1500,6 +1747,75 @@ dbglog_default_print_handler(A_UINT32 mod_id, A_UINT16 vap_id, A_UINT32 dbg_id,
                              A_UINT32 timestamp, A_UINT16 numargs, A_UINT32 *args)
 {
     int i;
+#ifdef CONFIG_WLAN_FWLOG_FILE
+    int len = 0;
+
+    if (dbglog_fwlog_file_ctx.print_to_file) {
+        mutex_lock(&dbglog_fwlog_file_ctx.lock);
+
+        if (dbglog_fwlog_file_ctx.buf_used_size  == 0) {
+	    adf_os_timer_cancel(&dbglog_fwlog_file_ctx.timer);
+            adf_os_timer_start(&dbglog_fwlog_file_ctx.timer, 100);
+        }
+
+        if (dbglog_fwlog_file_ctx.buf_free_size <= 120) {
+            dbglog_fwlog_file_ctx.overflow++;
+            printk("%s:%d: overflow:%u\n", __func__, __LINE__, dbglog_fwlog_file_ctx.overflow);
+            mutex_unlock(&dbglog_fwlog_file_ctx.lock);
+            return TRUE;
+        }
+
+	if (vap_id < DBGLOG_MAX_VDEVID) {
+            len = snprintf(dbglog_fwlog_file_ctx.buf_free_idx, dbglog_fwlog_file_ctx.buf_free_size,
+                           "[%u] vap-%u %s (", timestamp, vap_id, dbglog_get_msg(mod_id, dbg_id));
+	} else {
+            len = snprintf(dbglog_fwlog_file_ctx.buf_free_idx, dbglog_fwlog_file_ctx.buf_free_size,
+                           "[%u] %s (", timestamp, dbglog_get_msg(mod_id, dbg_id));
+	}
+
+        for (i = 0; i < numargs; i++) {
+#if USE_NUMERIC
+            len += snprintf(dbglog_fwlog_file_ctx.buf_free_idx + len, dbglog_fwlog_file_ctx.buf_free_size - len, "%u", args[i]);
+#else
+            len += snprintf(dbglog_fwlog_file_ctx.buf_free_idx + len, dbglog_fwlog_file_ctx.buf_free_size - len, "%#x", args[i]);
+#endif
+            if ((i + 1) < numargs) {
+                dbglog_fwlog_file_ctx.buf_free_idx[len] = ',';
+                dbglog_fwlog_file_ctx.buf_free_idx[len+1] = ' ';
+                len += 2;
+            }
+        }
+        len += snprintf(dbglog_fwlog_file_ctx.buf_free_idx + len, dbglog_fwlog_file_ctx.buf_free_size - len, " )\n");
+        dbglog_fwlog_file_ctx.buf_free_idx += len;
+        dbglog_fwlog_file_ctx.buf_used_size += len;
+        dbglog_fwlog_file_ctx.buf_free_size -= len;
+        if ((dbglog_fwlog_file_ctx.buf_used_size >= FWLOG_FILE_BUF_THREHOLD) ||
+            ((dbglog_fwlog_file_ctx.file_size + dbglog_fwlog_file_ctx.buf_used_size) >= dbglog_fwlog_file_ctx.file_max_size)) {
+            adf_os_timer_cancel(&dbglog_fwlog_file_ctx.timer);
+            dbglog_fwlog_file_write_file();
+        }
+        mutex_unlock(&dbglog_fwlog_file_ctx.lock);
+    } else {
+
+        if (vap_id < DBGLOG_MAX_VDEVID) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (DBGLOG_PRINT_PREFIX "[%u] vap-%u %s ( ", timestamp, vap_id, dbglog_get_msg(mod_id, dbg_id)));
+        } else {
+            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (DBGLOG_PRINT_PREFIX "[%u] %s ( ", timestamp, dbglog_get_msg(mod_id, dbg_id)));
+        }
+
+        for (i = 0; i < numargs; i++) {
+#if USE_NUMERIC
+            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, ("%u", args[i]));
+#else
+            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, ("%#x", args[i]));
+#endif
+            if ((i + 1) < numargs) {
+                AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (", "));
+            }
+        }
+        AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (" )\n"));
+    }
+#else
 
     if (vap_id < DBGLOG_MAX_VDEVID) {
         AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (DBGLOG_PRINT_PREFIX "[%u] vap-%u %s ( ", timestamp, vap_id, dbglog_get_msg(mod_id, dbg_id)));
@@ -1518,6 +1834,7 @@ dbglog_default_print_handler(A_UINT32 mod_id, A_UINT16 vap_id, A_UINT32 dbg_id,
         }
     }
     AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (" )\n"));
+#endif
 
     return TRUE;
 }
@@ -4144,6 +4461,12 @@ dbglog_init(wmi_unified_t wmi_handle)
     /* Initialize debugfs */
     dbglog_debugfs_init(wmi_handle);
 #endif /* WLAN_OPEN_SOURCE */
+#ifdef CONFIG_WLAN_FWLOG_FILE
+    res = dbglog_fwlog_file_init();
+    if (res != 0) {
+        return res;
+    }
+#endif
 
     return res;
 }
@@ -4153,6 +4476,9 @@ dbglog_deinit(wmi_unified_t wmi_handle)
 {
     int res = 0;
 
+#ifdef CONFIG_WLAN_FWLOG_FILE
+    dbglog_fwlog_file_deinit();
+#endif
 #ifdef WLAN_OPEN_SOURCE
     /* DeInitialize the fw debug log queue */
     skb_queue_purge(&wmi_handle->dbglog.fwlog_queue);
-- 
1.7.9.5

