diff -Nuar qcacld-new-clean/CORE/CLD_TXRX/HTT/htt.c qcacld-new/CORE/CLD_TXRX/HTT/htt.c
--- qcacld-new-clean/CORE/CLD_TXRX/HTT/htt.c
+++ qcacld-new/CORE/CLD_TXRX/HTT/htt.c
@@ -337,6 +337,12 @@
     return NULL;
 }
 
+void htt_pdev_set_sniffer_channel(htt_pdev_handle pdev, unsigned char channel, int freq)
+{
+	pdev->sniffer_channel = channel;
+	pdev->sniffer_center_freq = freq;
+}
+
 A_STATUS
 htt_attach_target(htt_pdev_handle pdev)
 {
diff -Nuar qcacld-new-clean/CORE/CLD_TXRX/HTT/htt_h2t.c qcacld-new/CORE/CLD_TXRX/HTT/htt_h2t.c
--- qcacld-new-clean/CORE/CLD_TXRX/HTT/htt_h2t.c
+++ qcacld-new/CORE/CLD_TXRX/HTT/htt_h2t.c
@@ -241,6 +241,7 @@
 #ifndef REMOVE_PKT_LOG
  if (ol_cfg_is_packet_log_enabled(pdev->ctrl_pdev))
    {
+	   printk(KERN_ERR"okkwon : pktlog_enabled\n");
        enable_ctrl_data = 1;
        enable_mgmt_data = 1;
        enable_null_data = 1;
@@ -254,6 +255,7 @@
    }
    else
    {
+	   printk(KERN_ERR"okkwon : pktlog_disabled\n");
        adf_os_print("Pkt log is disabled\n");
        enable_ctrl_data = 0;
        enable_mgmt_data = 0;
@@ -262,6 +264,8 @@
        enable_hdr       = 0;
        enable_ppdu_start= 0;
        enable_ppdu_end  = 0;
+	   /* okkwon to do : auto config for this disable_aspm */
+       htt_htc_disable_aspm();
    }
 #else
     enable_ctrl_data = 0;
diff -Nuar qcacld-new-clean/CORE/CLD_TXRX/HTT/htt_internal.h qcacld-new/CORE/CLD_TXRX/HTT/htt_internal.h
--- qcacld-new-clean/CORE/CLD_TXRX/HTT/htt_internal.h
+++ qcacld-new/CORE/CLD_TXRX/HTT/htt_internal.h
@@ -424,5 +424,9 @@
 
 int
 htt_tx_credit_update(struct htt_pdev_t *pdev);
+int htt_set_rx_radiotap_header(
+		htt_pdev_handle pdev,
+		adf_nbuf_t skb,
+		struct htt_host_rx_desc_base *rxd);
 
 #endif /* _HTT_INTERNAL__H_ */
diff -Nuar qcacld-new-clean/CORE/CLD_TXRX/HTT/htt_rx.c qcacld-new/CORE/CLD_TXRX/HTT/htt_rx.c
--- qcacld-new-clean/CORE/CLD_TXRX/HTT/htt_rx.c
+++ qcacld-new/CORE/CLD_TXRX/HTT/htt_rx.c
@@ -39,6 +39,8 @@
  *      rx ring (applies to LL only).
  */
 
+#include <net/ieee80211_radiotap.h>
+
 #include <adf_os_mem.h>   /* adf_os_mem_alloc,free, etc. */
 #include <adf_os_types.h> /* adf_os_print, a_bool_t */
 #include <adf_nbuf.h>     /* adf_nbuf_t, etc. */
@@ -59,6 +61,9 @@
 #include <wma_api.h>
 #endif
 
+#include <linux/ieee80211.h>
+#include <net/cfg80211.h>
+
 #ifdef DEBUG_DMA_DONE
 extern int process_wma_set_command(int sessid, int paramid,
                                    int sval, int vpdev);
@@ -94,8 +99,14 @@
 #define HTT_RX_RING_REFILL_RETRY_TIME_MS    50
 #endif
 
-void
-htt_rx_hash_deinit(struct htt_pdev_t *pdev);
+/* FIXME: This is a HW definition not provded by HW, where does it go ? */
+enum {
+    HW_RX_DECAP_FORMAT_RAW = 0,
+    HW_RX_DECAP_FORMAT_NWIFI,
+    HW_RX_DECAP_FORMAT_8023,
+    HW_RX_DECAP_FORMAT_ETH2,
+};
+void htt_rx_hash_deinit(struct htt_pdev_t *pdev);
 
 static int
 CEIL_PWR2(int value)
@@ -864,6 +875,392 @@
 #define MAX_DONE_BIT_CHECK_ITER 5
 #endif
 
+enum htt_rx_mpdu_encrypt_type {
+	HTT_RX_MPDU_ENCRYPT_WEP40            = 0,
+	HTT_RX_MPDU_ENCRYPT_WEP104           = 1,
+	HTT_RX_MPDU_ENCRYPT_TKIP_WITHOUT_MIC = 2,
+	HTT_RX_MPDU_ENCRYPT_WEP128           = 3,
+	HTT_RX_MPDU_ENCRYPT_TKIP_WPA         = 4,
+	HTT_RX_MPDU_ENCRYPT_WAPI             = 5,
+	HTT_RX_MPDU_ENCRYPT_AES_CCM_WPA2     = 6,
+	HTT_RX_MPDU_ENCRYPT_NONE             = 7,
+};
+
+struct rfc1042_hdr {
+	u8 llc_dsap;
+	u8 llc_ssap;
+	u8 llc_ctrl;
+	u8 snap_oui[3];
+	__be16 snap_type;
+} __packed;
+
+struct amsdu_subframe_hdr {
+	u8 dst[ETH_ALEN];
+	u8 src[ETH_ALEN];
+	__be16 len;
+} __packed;
+
+static int htt_rx_radiotap_space(struct htt_host_rx_desc_base *rxd)
+{
+	int len;
+
+	/* always present fields */
+	len = sizeof(struct ieee80211_radiotap_header) + 8;
+
+	if (rxd->ppdu_start.preamble_type == 0x8 ||
+			rxd->ppdu_start.preamble_type == 0x9)
+	{
+		/* HT */
+		len += 3;
+	}
+
+	if (rxd->ppdu_start.preamble_type == 0xc ||
+			rxd->ppdu_start.preamble_type == 0xd)
+	{
+		/* VHT */
+		len += 12;
+	}
+
+	return len;
+}
+
+static const u8 rx_legacy_rate_idx[] = {
+	3,	/* 0x00  - 11Mbps  */
+	2,	/* 0x01  - 5.5Mbps */
+	1,	/* 0x02  - 2Mbps   */
+	0,	/* 0x03  - 1Mbps   */
+	3,	/* 0x04  - 11Mbps  */
+	2,	/* 0x05  - 5.5Mbps */
+	1,	/* 0x06  - 2Mbps   */
+	0,	/* 0x07  - 1Mbps   */
+	10,	/* 0x08  - 48Mbps  */
+	8,	/* 0x09  - 24Mbps  */
+	6,	/* 0x0A  - 12Mbps  */
+	4,	/* 0x0B  - 6Mbps   */
+	11,	/* 0x0C  - 54Mbps  */
+	9,	/* 0x0D  - 36Mbps  */
+	7,	/* 0x0E  - 18Mbps  */
+	5,	/* 0x0F  - 9Mbps   */
+};
+
+static const u16 rx_legacy_bitrate[] = {
+	10,
+	20,
+	55,
+	110,
+	60,
+	90,
+	120,
+	180,
+	240,
+	360,
+	480,
+	540,
+};
+
+ int htt_set_rx_radiotap_header(
+		htt_pdev_handle pdev,
+		adf_nbuf_t skb,
+		struct htt_host_rx_desc_base *rxd)
+{
+	int rtap_len;
+	struct ieee80211_radiotap_header *rthdr;
+	unsigned char rthdr_buff[30];
+	unsigned char * pos;
+	int mpdulen;
+	__le32 *it_present;
+	u32 it_present_val;
+	int preamble_type;
+	u16 channel_flags = 0;
+	uint8_t * new_head;
+	u32 info0, info1, info2;
+	u8 cck, rate, rate_idx;
+	u16 bitrate;
+
+	rtap_len = htt_rx_radiotap_space(rxd);
+
+	mpdulen = skb->len;
+	mpdulen += 4;	/* FCS len */
+
+	rthdr = (struct ieee80211_radiotap_header *)rthdr_buff;
+	memset(rthdr, 0, rtap_len);
+	it_present = &rthdr->it_present;
+
+	/* radiotap header, set always present flags */
+	rthdr->it_len = cpu_to_le16(rtap_len);
+	it_present_val = BIT(IEEE80211_RADIOTAP_FLAGS) |
+		BIT(IEEE80211_RADIOTAP_CHANNEL);
+
+	put_unaligned_le32(it_present_val, it_present);
+
+	pos = (void *)(it_present + 1);
+
+	if (rxd->attention.fcs_err) {
+		/* FCS error */
+		*pos |= IEEE80211_RADIOTAP_F_BADFCS;
+	}
+
+	*pos |= IEEE80211_RADIOTAP_F_FCS;
+	pos++;
+
+	preamble_type = rxd->ppdu_start.preamble_type;
+	info0 = rxd->ppdu_start.ht_sig_vht_sig_a_1;
+	info1 = rxd->ppdu_start.ht_sig_vht_sig_a_2;
+	info2 = rxd->ppdu_start.vht_sig_b;
+
+	if (preamble_type == 0x4) {
+		/* legacy preamble */
+		rthdr->it_present |= cpu_to_le32(1 << IEEE80211_RADIOTAP_RATE);
+		cck = rxd->ppdu_start.l_sig_rate_select;
+		rate = rxd->ppdu_start.l_sig_rate;
+		rate_idx = 0;
+
+		if (rate >= 0x8 && rate <= 0x0f) {
+			if (pdev->sniffer_channel < 15) {
+				if (cck)
+					rate &= ~BIT(3);
+			}
+			rate_idx = rx_legacy_rate_idx[rate];
+			bitrate = rx_legacy_bitrate[rate_idx];
+			*pos = DIV_ROUND_UP(bitrate, 5);
+		}
+	} else {
+		/* HT || VHT */
+		*pos = 0;
+	}
+	pos ++;
+
+	*pos = pdev->sniffer_center_freq & 0xff;
+	pos++;
+	*pos = (pdev->sniffer_center_freq & 0xff00) >> 8;
+	pos++;
+
+	if(pdev->sniffer_channel > 15) {
+		channel_flags |= IEEE80211_CHAN_OFDM | IEEE80211_CHAN_5GHZ;
+	} else if(preamble_type != 0x4) {
+		channel_flags |= IEEE80211_CHAN_DYN | IEEE80211_CHAN_2GHZ;
+	} else if(!cck) {
+		channel_flags |= IEEE80211_CHAN_OFDM | IEEE80211_CHAN_2GHZ;
+	} else {
+		channel_flags |= IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_CCK;
+	}
+
+	*pos = channel_flags & 0xff;
+	pos++;
+	*pos = (channel_flags & 0xff00) >> 8;
+	pos++;
+
+	*pos = -96 + rxd->ppdu_start.rssi_comb;
+	rthdr->it_present |= 1 << IEEE80211_RADIOTAP_DBM_ANTSIGNAL;
+	pos++;
+
+	/* HT preamble */
+	if (preamble_type == 0x8 || preamble_type == 0x9) {
+		rthdr->it_present |= cpu_to_le32(1 << IEEE80211_RADIOTAP_MCS);
+		*pos++ = IEEE80211_RADIOTAP_MCS_HAVE_MCS |
+			IEEE80211_RADIOTAP_MCS_HAVE_GI |
+			IEEE80211_RADIOTAP_MCS_HAVE_BW |
+			IEEE80211_RADIOTAP_MCS_HAVE_FEC;
+		*pos = 0;
+		if (info1 & (1<<7)) 
+			*pos |= IEEE80211_RADIOTAP_MCS_SGI;
+		if (info0 & (1<<7))
+			*pos |= IEEE80211_RADIOTAP_MCS_BW_40;
+		if (rxd->ppdu_start.is_greenfield)
+			*pos |= IEEE80211_RADIOTAP_MCS_FMT_GF;
+		if (info1 & (1<<8)) 
+			*pos |= IEEE80211_RADIOTAP_MCS_FEC_LDPC;
+		if (info1 & (3<<4))
+			*pos |= (1<<4);	/* stbc */
+		pos++;
+		*pos++ = info1 & 0x1f; /* okkwon todo : set rate index */
+	}
+
+	if(preamble_type == 0xc || preamble_type == 0xd) {
+		while ((pos - (u8*)rthdr)%4)
+			pos ++;
+		rthdr->it_present |= cpu_to_le32(1 << IEEE80211_RADIOTAP_VHT);
+		put_unaligned_le16(IEEE80211_RADIOTAP_VHT_KNOWN_GI |
+				IEEE80211_RADIOTAP_VHT_KNOWN_BANDWIDTH |
+				IEEE80211_RADIOTAP_VHT_KNOWN_STBC |
+				IEEE80211_RADIOTAP_VHT_KNOWN_BEAMFORMED, pos);
+		pos += 2;
+		if (info1 & 0x1)
+			*pos |= IEEE80211_RADIOTAP_VHT_FLAG_SGI;
+		if (info0 & (1<<3))
+			*pos |= IEEE80211_RADIOTAP_VHT_FLAG_STBC;
+		if (info1 & (1<<8))
+			*pos |= IEEE80211_RADIOTAP_VHT_FLAG_BEAMFORMED;
+		pos++;
+		switch ((info0 & 0x3)){
+			case 2:
+				*pos++ = 4;
+				break;
+			case 3:
+				*pos++ = 11;
+				break;
+			case 1:
+				*pos++ = 1;
+				break;
+			case 0:
+				*pos++ = 0;
+				break;
+		}
+		*pos = (((info1&0xf0)>>4) << 4) | (((info0>>10) & 0x07) +1);
+		pos += 4;
+		if (info1 & (1<<2))
+			*pos |= 0x01;
+		pos++;
+		/* group ID */
+		pos++;
+		/* partial AID */
+		pos+=2;
+	}
+	
+	if (adf_nbuf_headroom(skb) < rtap_len &&
+			/* okkwon much overhead -_-? */
+			! adf_nbuf_expand(skb, rtap_len, 0)) {
+		return -1;
+	}
+
+	adf_nbuf_push_head(skb, rtap_len);
+	new_head = adf_nbuf_data(skb);
+	if(new_head) 
+		memcpy(new_head, rthdr_buff, rtap_len);
+
+	return 0;
+}
+
+adf_nbuf_t htt_sniffer_restitch_amsdu (adf_nbuf_t head_msdu) {
+	adf_nbuf_t msdu, prev_buf;
+	unsigned decap_format, wifi_hdr_len, sec_hdr_len, msdu_llc_len,
+			 dir,
+			 is_amsdu, msdu_len;
+	struct htt_host_rx_desc_base *rx_desc;
+	char *hdr_desc;
+	unsigned char *dest;
+	struct ieee80211_frame *wh;
+	struct ieee80211_qoscntl*qos;
+	int is_first_frag;
+
+	rx_desc = htt_rx_desc(head_msdu);
+
+	decap_format = rx_desc->msdu_start.decap_format;
+	hdr_desc = &rx_desc->rx_hdr_status[0];
+
+	/* Base size */
+	wifi_hdr_len = sizeof(struct ieee80211_frame);
+	wh = (struct ieee80211_frame*)hdr_desc;
+
+	dir = wh->i_fc[1] & IEEE80211_FC1_DIR_MASK;
+	if (dir == IEEE80211_FC1_DIR_DSTODS) {
+		wifi_hdr_len += 6;
+	}
+
+	is_amsdu = 0;
+	if (wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_QOS) {
+		qos = (struct ieee80211_qoscntl*)
+			(hdr_desc + wifi_hdr_len);
+		wifi_hdr_len += 2;
+
+		is_amsdu = (qos->i_qos[0] & IEEE80211_QOS_AMSDU);
+	}
+
+	/* TODO: Any security headers associated with MPDU */
+	sec_hdr_len = 0;
+
+	/* MSDU related stuff LLC - AMSDU subframe header etc */
+	msdu_llc_len = is_amsdu ? (14 + 8) : 8;
+
+	if (decap_format == 0) {
+		/* raw format */
+		prev_buf = head_msdu;
+
+		msdu_len = adf_nbuf_len(prev_buf);
+
+		/* Drop the zero-length msdu */
+		if (!msdu_len) {
+			printk(KERN_ERR"okkwon : %s msdu_len 0\n", __func__);
+			goto mpdu_stitch_fail;
+		}
+		msdu = adf_nbuf_next(head_msdu);
+		is_first_frag = 1;
+
+		while (msdu) {
+			msdu_len = adf_nbuf_len(msdu);
+			/* Drop the zero-length msdu */
+			if (!msdu_len) {
+				printk(KERN_ERR"okkwon : %s msdu_len 0 in loop\n", __func__);
+				goto mpdu_stitch_fail;
+			}
+
+			head_msdu = adf_nbuf_expand(head_msdu, 0, msdu_len);
+			if (!head_msdu) {
+				printk(KERN_ERR"okkwon : %s skb expand fail\n", __func__);
+				goto mpdu_stitch_fail;
+			}
+
+			dest = adf_nbuf_put_tail(head_msdu, msdu_len);
+			if (!dest) {
+				printk(KERN_ERR"okkwon : %s skb dest get failure\n", __func__);
+				goto mpdu_stitch_fail;
+			}
+			adf_os_mem_copy(dest, adf_nbuf_data(msdu), msdu_len);
+			printk(KERN_ERR"okkwon msdu_len %d\n", msdu_len);
+			print_hex_dump(KERN_ERR, "head:", 2, 16, 4, adf_nbuf_data(msdu), 16, 0);
+
+#if 0
+			msdu = adf_nbuf_expand(msdu,
+					HTT_RX_STD_DESC_RESERVATION + wifi_hdr_len + sec_hdr_len,
+					0);
+			if (!msdu) {
+				goto mpdu_stitch_fail;
+			}
+
+			dest = adf_nbuf_push_head(msdu, wifi_hdr_len + sec_hdr_len);
+			if (!dest) {
+				goto mpdu_stitch_fail;
+			}
+			adf_os_mem_copy(dest, hdr_desc, wifi_hdr_len + sec_hdr_len);
+			print_hex_dump(KERN_ERR, "hdr:", 2, 16, 4, hdr_desc, 50, 0);
+
+			dest = adf_nbuf_push_head(msdu, HTT_RX_STD_DESC_RESERVATION);
+			if (!msdu) {
+				goto mpdu_stitch_fail;
+			}
+			adf_os_mem_copy(dest, rx_desc, HTT_RX_STD_DESC_RESERVATION);
+			adf_nbuf_pull_head(msdu, HTT_RX_STD_DESC_RESERVATION);
+#endif
+
+			/* Move to the next */
+			prev_buf = msdu;
+			msdu = adf_nbuf_next(msdu);
+			if (is_first_frag) {
+				is_first_frag = 0;
+			} else {
+				adf_nbuf_set_next(prev_buf, NULL);
+				adf_nbuf_free(prev_buf);
+			}
+		}
+#if 0
+		adf_nbuf_trim_tail(prev_buf, 4);
+#endif
+
+		adf_nbuf_set_next(head_msdu, NULL);
+
+		goto mpdu_stitch_done;
+	} else {
+		printk(KERN_ERR"okkwon : decap format error\n");
+		goto mpdu_stitch_fail;
+	}
+
+mpdu_stitch_done:
+	return head_msdu;
+
+mpdu_stitch_fail:
+	return NULL;
+}
+
 int
 htt_rx_amsdu_pop_ll(
     htt_pdev_handle pdev,
@@ -1132,7 +1529,7 @@
 #ifdef CHECKSUM_OFFLOAD
     htt_set_checksum_result_hl(rx_ind_msg, (struct htt_host_rx_desc_base *)(adf_nbuf_data(rx_ind_msg)));
 #endif
-
+	
     adf_nbuf_set_next(*tail_msdu, NULL);
     return 0;
 }
@@ -1354,14 +1751,6 @@
     return buf;
 }
 
-/* FIXME: This is a HW definition not provded by HW, where does it go ? */
-enum {
-    HW_RX_DECAP_FORMAT_RAW = 0,
-    HW_RX_DECAP_FORMAT_NWIFI,
-    HW_RX_DECAP_FORMAT_8023,
-    HW_RX_DECAP_FORMAT_ETH2,
-};
-
 #define HTT_FCS_LEN (4)
 
 static void
@@ -1730,7 +2119,6 @@
     return HTT_RSSI_INVALID;
 }
 
-
 /*
  * htt_rx_amsdu_pop -
  * global function pointer that is programmed during attach to point
diff -Nuar qcacld-new-clean/CORE/CLD_TXRX/HTT/htt_types.h qcacld-new/CORE/CLD_TXRX/HTT/htt_types.h
--- qcacld-new-clean/CORE/CLD_TXRX/HTT/htt_types.h
+++ qcacld-new/CORE/CLD_TXRX/HTT/htt_types.h
@@ -345,6 +345,8 @@
     int cur_seq_num_hl;
     struct htt_tx_mgmt_desc_ctxt tx_mgmt_desc_ctxt;
     struct targetdef_s *targetdef;
+	unsigned char sniffer_channel;
+	int sniffer_center_freq;
 
 #ifdef IPA_UC_OFFLOAD
     struct htt_ipa_uc_tx_resource_t ipa_uc_tx_rsc;
diff -Nuar qcacld-new-clean/CORE/CLD_TXRX/TLSHIM/tl_shim.c qcacld-new/CORE/CLD_TXRX/TLSHIM/tl_shim.c
--- qcacld-new-clean/CORE/CLD_TXRX/TLSHIM/tl_shim.c
+++ qcacld-new/CORE/CLD_TXRX/TLSHIM/tl_shim.c
@@ -46,6 +46,9 @@
 #include "wma_api.h"
 #include "vos_utils.h"
 #include "wdi_out.h"
+#include <htt_internal.h>
+#include <ol_txrx_types.h>
+
 
 #define TLSHIM_PEER_AUTHORIZE_WAIT 10
 
@@ -60,6 +63,15 @@
 #define TLSHIM_LOGP(args...) \
 	VOS_TRACE( VOS_MODULE_ID_TL, VOS_TRACE_LEVEL_FATAL, ## args)
 
+//Send management frame to data path in monitor mode
+#ifdef OSIF_NEED_RX_PEER_ID
+#define OL_RX_MGMT_OSIF_DELIVER(vdev, peer, msdus) \
+       vdev->osif_rx(vdev->osif_dev, peer->local_id, msdus)
+#else
+#define OL_RX_MGMT_OSIF_DELIVER(vdev, peer, msdus) \
+       vdev->osif_rx(vdev->osif_dev, msdus)
+#endif /* OSIF_NEED_RX_PEER_ID */
+
 #if defined(FEATURE_WLAN_ESE) && !defined(FEATURE_WLAN_ESE_UPLOAD)
 
 /************************/
@@ -539,6 +551,143 @@
 	return false;
 }
 #endif
+/*
+* Send management frame to protocl stack by data path.
+* user space application can parse management frame.
+*/
+void
+ol_rx_mgmt_deliver(
+    struct ol_txrx_vdev_t *vdev,
+    struct ol_txrx_peer_t *peer,
+    adf_nbuf_t msdu,
+    struct htt_host_rx_desc_base *rxd)
+{
+	ol_txrx_pdev_handle pdev = vdev->pdev;
+	htt_pdev_handle htt_pdev = pdev->htt_pdev;
+	adf_nbuf_t deliver_list_head = NULL;
+	adf_nbuf_t deliver_list_tail = NULL;
+	
+	if (htt_set_rx_radiotap_header(htt_pdev, msdu, rxd)) {
+		printk(KERN_ERR"okkwon : mem alloc failure for rt - discard all\n");
+		msdu = NULL;
+	}
+	
+	OL_TXRX_LIST_APPEND(deliver_list_head, deliver_list_tail, msdu);
+	/* sanity check - are there any frames left to give to the OS shim? */
+	if (!deliver_list_head) {
+		return;
+	}
+
+	OL_RX_MGMT_OSIF_DELIVER(vdev, peer, deliver_list_head);
+}
+/*
+* Host can fetch raw data of ieee802.11 mangement frame
+* Re-build skb structure by raw data, so ol_rx can proces it.
+*/
+static int tlshim_mon_mgmt_rx_process(void *context, u_int8_t *data,
+				       u_int32_t data_len, struct ol_txrx_vdev_t *vdev)
+{
+	void *vos_ctx = vos_get_global_context(VOS_MODULE_ID_TL, NULL);
+	struct txrx_tl_shim_ctx *tl_shim = vos_get_context(VOS_MODULE_ID_TL,
+							   vos_ctx);
+	WMI_MGMT_RX_EVENTID_param_tlvs *param_tlvs = NULL;
+	wmi_mgmt_rx_hdr *hdr = NULL;
+	adf_nbuf_t wbuf;
+	struct ieee80211_frame *wh;
+	struct ol_txrx_peer_t *peer = NULL;
+	struct mgmt_radio *radiotap_info;
+	struct htt_host_rx_desc_base rxd;
+
+	if (!tl_shim) {
+		TLSHIM_LOGE("%s: Failed to get TLSHIM context", __func__);
+		return 0;
+	}
+
+	peer = TAILQ_FIRST(&vdev->peer_list);
+	if(!peer) {
+		TLSHIM_LOGE("%s: Failed to get peer context", __func__);
+		return 0;
+	}
+
+	param_tlvs = (WMI_MGMT_RX_EVENTID_param_tlvs *) data;
+	if (!param_tlvs) {
+		TLSHIM_LOGE("Get NULL point message from FW");
+		return 0;
+	}
+
+	hdr = param_tlvs->hdr;
+	if (!hdr) {
+		TLSHIM_LOGE("Rx event is NULL");
+		return 0;
+	}
+	/*
+	* Control frame header length is less than management frame,
+	* select control frame as judge stander.
+	* Firmware add radiotap information on the head of ieee80211 frame.
+	*/
+	
+	if (hdr->buf_len < sizeof(struct ieee80211_control_frame) + sizeof(struct mgmt_radio)) {
+		TLSHIM_LOGE("Invalid rx mgmt packet");
+		return 0;
+	}
+	radiotap_info = vos_mem_malloc(sizeof(struct mgmt_radio));
+	if (!radiotap_info) {
+		TLSHIM_LOGE("Failed to allocate radiotap_info");
+		return 0;
+	}
+	vos_mem_zero(radiotap_info, sizeof(*radiotap_info));	
+	adf_os_mem_copy(radiotap_info, param_tlvs->bufp, sizeof(struct mgmt_radio));
+	rxd.ppdu_start.rssi_comb = radiotap_info->rssi_comb;
+	rxd.ppdu_start.l_sig_rate = radiotap_info->l_sig_rate;
+	rxd.ppdu_start.l_sig_rate_select = radiotap_info->l_sig_rate_select;
+	rxd.ppdu_start.preamble_type = radiotap_info->preamble_type;
+	rxd.ppdu_start.ht_sig_vht_sig_a_1 = radiotap_info->ht_sig_vht_sig_a_1;
+	rxd.ppdu_start.ht_sig_vht_sig_a_2 = radiotap_info->ht_sig_vht_sig_a_2;
+	vos_mem_free(radiotap_info);
+
+	hdr->buf_len -= sizeof(struct mgmt_radio);
+	param_tlvs->bufp += sizeof(struct mgmt_radio);
+	/* Why not just use rx_event->hdr.buf_len? */
+	wbuf = adf_nbuf_alloc(NULL,
+				  roundup(hdr->buf_len, 4),
+				  0, 4, FALSE);
+	if (!wbuf) {
+		TLSHIM_LOGE("%s: Failed to allocate wbuf for mgmt rx len(%u)",
+			__func__, hdr->buf_len);
+		return 0;
+	}
+
+	adf_nbuf_put_tail(wbuf, hdr->buf_len);
+	adf_nbuf_set_protocol(wbuf, ETH_P_CONTROL);
+	wh = (struct ieee80211_frame *) adf_nbuf_data(wbuf);
+
+#ifdef BIG_ENDIAN_HOST
+	{
+		/*
+		 * for big endian host, copy engine byte_swap is enabled
+		 * But the rx mgmt frame buffer content is in network byte order
+		 * Need to byte swap the mgmt frame buffer content - so when
+		 * copy engine does byte_swap - host gets buffer content in the
+		 * correct byte order.
+		 */
+		int i;
+		u_int32_t *destp, *srcp;
+		destp = (u_int32_t *) wh;
+		srcp =	(u_int32_t *) param_tlvs->bufp;
+		for (i = 0;
+			 i < (roundup(hdr->buf_len, sizeof(u_int32_t)) / 4);
+			 i++) {
+			*destp = cpu_to_le32(*srcp);
+			destp++; srcp++;
+		}
+	}
+#else
+	adf_os_mem_copy(wh, param_tlvs->bufp, hdr->buf_len);
+#endif
+	ol_rx_mgmt_deliver(vdev,peer,wbuf,&rxd);
+	return 0;
+}
+
 
 static int tlshim_mgmt_rx_process(void *context, u_int8_t *data,
 				       u_int32_t data_len, bool saved_beacon, u_int32_t vdev_id)
@@ -808,7 +957,15 @@
 static int tlshim_mgmt_rx_wmi_handler(void *context, u_int8_t *data,
 				       u_int32_t data_len)
 {
-	return (tlshim_mgmt_rx_process(context, data, data_len, FALSE, 0));
+	ol_txrx_pdev_handle txrx_pdev = NULL;
+	struct ol_txrx_vdev_t *vdev;
+	void *vos_ctx = vos_get_global_context(VOS_MODULE_ID_TL, NULL);
+	txrx_pdev = vos_get_context(VOS_MODULE_ID_TXRX,vos_ctx);
+	vdev = txrx_pdev->sniffer_vdev;
+	if(txrx_pdev && vdev)
+		return (tlshim_mon_mgmt_rx_process(context, data, data_len,vdev));
+	else
+		return (tlshim_mgmt_rx_process(context, data, data_len, FALSE, 0));
 }
 #endif
 /*
@@ -943,6 +1100,8 @@
 	struct tlshim_sta_info *sta_info;
 	adf_nbuf_t buf, next_buf;
 	WLANTL_STARxCBType data_rx = NULL;
+	void *vos_ctx1 = vos_get_global_context(VOS_MODULE_ID_TL, NULL);
+	ol_txrx_pdev_handle txrx_pdev = vos_get_context(VOS_MODULE_ID_TXRX,vos_ctx1);
 
 	if (staid >= WLAN_MAX_STA_COUNT) {
 		TLSHIM_LOGE("Invalid sta id :%d", staid);
@@ -953,10 +1112,21 @@
 	sta_info = &tl_shim->sta_info[staid];
 
 	adf_os_spin_lock_bh(&sta_info->stainfo_lock);
+	/*Increase if receive new packet*/
+	if(txrx_pdev && txrx_pdev->sniffer_vdev){
+		tl_shim->mon_count_packet++;
+	}
 	if (sta_info->registered)
 		data_rx = sta_info->data_rx;
 	adf_os_spin_unlock_bh(&sta_info->stainfo_lock);
 
+	/*Count the packet numbers from firmware for debug*/
+	if(txrx_pdev && txrx_pdev->sniffer_vdev){
+		if (tl_shim->mon_enble_count == 1){			
+			TLSHIM_LOGE("Received packet numbers :%llu", tl_shim->mon_count_packet);
+		}
+	}
+
 	/*
 	 * If there is a data frame from peer before the peer is
 	 * registered for data service, enqueue them on to pending queue
diff -Nuar qcacld-new-clean/CORE/CLD_TXRX/TLSHIM/tl_shim.h qcacld-new/CORE/CLD_TXRX/TLSHIM/tl_shim.h
--- qcacld-new-clean/CORE/CLD_TXRX/TLSHIM/tl_shim.h
+++ qcacld-new/CORE/CLD_TXRX/TLSHIM/tl_shim.h
@@ -105,6 +105,8 @@
 #ifdef IPA_UC_OFFLOAD
 	ipa_uc_fw_op_cb fw_op_cb;;
 #endif /* IPA_UC_OFFLOAD */
+	u_int8_t mon_enble_count;
+	u_int64_t mon_count_packet;
 };
 
 /*
@@ -130,4 +132,12 @@
 {
 }
 #endif
+struct mgmt_radio{
+	u_int8_t rssi_comb;
+	u_int8_t l_sig_rate;
+	u_int8_t l_sig_rate_select;
+	u_int8_t preamble_type;
+	u_int16_t ht_sig_vht_sig_a_1;
+	u_int16_t ht_sig_vht_sig_a_2;
+};
 #endif
diff -Nuar qcacld-new-clean/CORE/CLD_TXRX/TXRX/ol_rx.c qcacld-new/CORE/CLD_TXRX/TXRX/ol_rx.c
--- qcacld-new-clean/CORE/CLD_TXRX/TXRX/ol_rx.c
+++ qcacld-new/CORE/CLD_TXRX/TXRX/ol_rx.c
@@ -58,6 +58,8 @@
 #include <ipv4.h>    /* IPv4 header defs */
 #include <ipv6_defs.h>    /* IPv6 header defs */
 #include <ol_vowext_dbg_defs.h>
+#include <htt_internal.h>
+struct htt_host_rx_desc_base rxd_back;
 
 #ifdef HTT_RX_RESTORE
 #if defined(QCA_WIFI_2_0) && !defined(QCA_WIFI_ISOC) && defined(CONFIG_CNSS)
@@ -210,8 +212,13 @@
     struct ol_txrx_vdev_t *vdev = NULL;
     struct ol_txrx_peer_t *peer;
     htt_pdev_handle htt_pdev;
+	adf_nbuf_t first_msdu = NULL;
+	adf_nbuf_t last_msdu = NULL;
+	struct htt_rx_ind_hdr_t rx_ind_header;
 
-    htt_pdev = pdev->htt_pdev;
+	memcpy(&rx_ind_header,adf_nbuf_data(rx_ind_msg),HTT_RX_IND_HDR_BYTES);
+
+	htt_pdev = pdev->htt_pdev;
     peer = ol_txrx_peer_find_by_id(pdev, peer_id);
     if (peer) {
         vdev = peer->vdev;
@@ -255,6 +262,60 @@
         pdev->htt_pdev->rx_ring.sw_rd_idx.msdu_payld;
 #endif
 
+
+	if (pdev->sniffer_vdev) {
+		peer = TAILQ_FIRST(&pdev->sniffer_vdev->peer_list);
+		for (mpdu_range = 0; mpdu_range < num_mpdu_ranges; mpdu_range++) {
+			int i, num_mpdus;
+			adf_nbuf_t head_msdu, tail_msdu;
+			int msdu_chaining;
+			enum htt_rx_status status;
+
+#ifdef DEBUG_DMA_DONE
+			pdev->htt_pdev->rx_ring.dbg_mpdu_range = mpdu_range;
+#endif
+
+			htt_rx_ind_mpdu_range_info(
+					pdev->htt_pdev, rx_ind_msg, mpdu_range, &status, &num_mpdus);
+
+#if 0
+			if (num_mpdus > 1) 
+				printk(KERN_ERR"okkwon num_mpdus %d\n", num_mpdus);
+#endif
+			for (i = 0; i < num_mpdus; i++) {
+				msdu_chaining = htt_rx_amsdu_pop(htt_pdev, rx_ind_msg,
+						&head_msdu, &tail_msdu);
+				if (!head_msdu) {
+					/* the skb was freed inside the pop function */
+					continue;
+				}
+
+				if (msdu_chaining) {
+					/* discard!! */
+					adf_nbuf_t skb = head_msdu;
+					while (skb) {
+						adf_nbuf_t next = adf_nbuf_next(skb);
+						adf_nbuf_free(skb);
+						skb = next;
+					}
+				} else {
+					if (!first_msdu) {
+						first_msdu = head_msdu;
+						last_msdu = tail_msdu;
+					} else {
+						/* chain to the last */
+						adf_nbuf_set_next(last_msdu, head_msdu);
+						last_msdu = tail_msdu;
+					}
+				}
+			}
+#if 0
+			printk(KERN_ERR"okkwon first_msdu %x, last_msdu %x\n",
+					(unsigned int)first_msdu, (unsigned int)last_msdu);
+#endif
+
+		}
+	} else {
     for (mpdu_range = 0; mpdu_range < num_mpdu_ranges; mpdu_range++) {
         enum htt_rx_status status;
         int i, num_mpdus;
@@ -464,6 +525,7 @@
             }
         }
     }
+	}
     /*
      * Now that a whole batch of MSDUs have been pulled out of HTT
      * and put into the rx reorder array, it is an appropriate time
@@ -475,7 +537,9 @@
      */
     htt_rx_msdu_buff_replenish(htt_pdev);
 
-    if ((A_TRUE == rx_ind_release) && peer && vdev) {
+	if (pdev->sniffer_vdev) {
+		peer->rx_opt_sniffer_proc(pdev->sniffer_vdev, peer, &rx_ind_header, 0, first_msdu);
+	} else if ((A_TRUE == rx_ind_release) && peer && vdev) {
         ol_rx_reorder_release(vdev, peer, tid, seq_num_start, seq_num_end);
     }
     OL_RX_REORDER_TIMEOUT_UPDATE(peer, tid);
@@ -872,7 +936,6 @@
                     htt_rx_msdu_rx_desc_size_hl(htt_pdev,
                         rx_desc));
         }
-
 #ifdef QCA_SUPPORT_SW_TXRX_ENCAP
         info.is_msdu_cmpl_mpdu =
             htt_rx_msdu_desc_completes_mpdu(htt_pdev, rx_desc);
@@ -900,7 +963,8 @@
          * Check the first msdu in the mpdu, if it will be filtered out,
          * then discard the entire mpdu.
          */
-        if (htt_rx_msdu_first_msdu_flag(htt_pdev, rx_desc)) {
+        if (vdev->opmode != wlan_op_mode_monitor &&
+			   htt_rx_msdu_first_msdu_flag(htt_pdev, rx_desc)) {
             filter = ol_rx_filter(vdev, peer, msdu, rx_desc);
         }
 
@@ -950,6 +1014,125 @@
 }
 
 void
+ol_rx_sniffer_deliver(
+    struct ol_txrx_vdev_t *vdev,
+    struct ol_txrx_peer_t *peer,
+    struct htt_rx_ind_hdr_t *rx_ind_header,
+    unsigned tid,
+    adf_nbuf_t msdu_list)
+{
+		ol_txrx_pdev_handle pdev = vdev->pdev;
+		htt_pdev_handle htt_pdev = pdev->htt_pdev;
+		adf_nbuf_t deliver_list_head = NULL;
+		adf_nbuf_t deliver_list_tail = NULL;
+		adf_nbuf_t msdu;
+		a_bool_t filter = A_FALSE;
+		struct htt_host_rx_desc_base *rxd;
+		uint32_t *wptr = (uint32_t *)rx_ind_header;
+
+		msdu = msdu_list;
+		/*
+		 * Check each MSDU to see whether it requires special handling,
+		 * and free each MSDU's rx descriptor
+		 */
+		while (msdu) {
+			void *rx_desc;
+			int discard, inspect, dummy_fwd;
+			adf_nbuf_t next = adf_nbuf_next(msdu);
+	
+			rx_desc = htt_rx_msdu_desc_retrieve(pdev->htt_pdev, msdu);
+			// for HL, point to payload right now
+			if (pdev->cfg.is_high_latency) {
+				adf_nbuf_pull_head(msdu,
+						htt_rx_msdu_rx_desc_size_hl(htt_pdev,
+							rx_desc));
+			}
+			htt_rx_msdu_actions(
+				pdev->htt_pdev, rx_desc, &discard, &dummy_fwd, &inspect);
+			if (inspect) {
+				ol_rx_inspect(vdev, peer, tid, msdu, rx_desc);
+			}
+	
+			/*
+			 * Check the first msdu in the mpdu, if it will be filtered out,
+			 * then discard the entire mpdu.
+			 */
+			if (vdev->opmode != wlan_op_mode_monitor &&
+				   htt_rx_msdu_first_msdu_flag(htt_pdev, rx_desc)) {
+				filter = ol_rx_filter(vdev, peer, msdu, rx_desc);
+			}
+	
+			htt_rx_msdu_desc_free(htt_pdev, msdu);
+			if (discard || (A_TRUE == filter)) {
+				OL_TXRX_FRMS_DUMP(
+					"rx discarding:",
+					pdev, deliver_list_head,
+					ol_txrx_frm_dump_tcp_seq | ol_txrx_frm_dump_contents,
+					0 /* don't print contents */);
+				adf_nbuf_free(msdu);
+				/* If discarding packet is last packet of the delivery list,NULL terminator should be added for delivery list. */
+				if (next == NULL && deliver_list_head){
+					adf_nbuf_set_next(deliver_list_tail, NULL); /* add NULL terminator */
+				}
+			} else {
+				OL_RX_PEER_STATS_UPDATE(peer, msdu);
+				OL_RX_ERR_STATISTICS_1(pdev, vdev, peer, rx_desc, OL_RX_ERR_NONE);
+				TXRX_STATS_MSDU_INCR(vdev->pdev, rx.delivered, msdu);
+				//add radiotap header for each msdu.
+				rxd = (struct htt_host_rx_desc_base *) (adf_nbuf_data(msdu_list)
+				- HTT_RX_STD_DESC_RESERVATION);
+				if (rxd->attention.first_mpdu) {
+					memcpy((void*)&rxd_back, (void*)rxd,sizeof(rxd_back));
+				} else {
+					/* if this is not a first mpdu.
+					* We rely on the rx_indinformation -_-
+					* what am I doing..
+					*/
+					if (*(wptr+2) & (1<<31)) {
+						/* start values are valid */
+						rxd_back.ppdu_start.rssi_comb = (*(wptr+2)) & 0xff;
+						rxd_back.ppdu_start.l_sig_rate = ((*(wptr+2)) >>25)&0xf;
+						rxd_back.ppdu_start.l_sig_rate_select = ((*(wptr+2)) >>29)&0x1;
+						rxd_back.ppdu_start.preamble_type = ((*(wptr+9)) >> 24)&0xff;
+						rxd_back.ppdu_start.ht_sig_vht_sig_a_1 = (*(wptr+9))&0xffff;
+						rxd_back.ppdu_start.ht_sig_vht_sig_a_2 = (*(wptr+10))&0xffff;
+					}
+
+					rxd = &rxd_back;
+				}
+				if (htt_set_rx_radiotap_header(htt_pdev, msdu, rxd)) {
+					/* there is some problem in expanding head of skb */
+					/* skb was already freed, what can we do -_-? */
+					/* okkwon todo : memory leak? */
+					printk(KERN_ERR"okkwon : mem alloc failure for rt - discard all\n");
+					msdu = NULL;
+				}
+				OL_TXRX_LIST_APPEND(deliver_list_head, deliver_list_tail, msdu);
+			}
+			msdu = next;
+		}
+		/* sanity check - are there any frames left to give to the OS shim? */
+		if (!deliver_list_head) {
+			return;
+		}
+	
+#if defined(PERE_IP_HDR_ALIGNMENT_WAR)
+		if (pdev->host_80211_enable) {
+			for (msdu = deliver_list_head; msdu; msdu = adf_nbuf_next(msdu)) {
+				transcap_nwifi_to_8023(msdu);
+			}
+		}
+#endif
+	
+		OL_TXRX_FRMS_DUMP(
+			"rx delivering:",
+			pdev, deliver_list_head,
+			ol_txrx_frm_dump_tcp_seq | ol_txrx_frm_dump_contents,
+			0 /* don't print contents */);
+		OL_RX_OSIF_DELIVER(vdev, peer, deliver_list_head);
+}
+
+void
 ol_rx_discard(
     struct ol_txrx_vdev_t *vdev,
     struct ol_txrx_peer_t *peer,
diff -Nuar qcacld-new-clean/CORE/CLD_TXRX/TXRX/ol_rx.h qcacld-new/CORE/CLD_TXRX/TXRX/ol_rx.h
--- qcacld-new-clean/CORE/CLD_TXRX/TXRX/ol_rx.h
+++ qcacld-new/CORE/CLD_TXRX/TXRX/ol_rx.h
@@ -39,6 +39,14 @@
     adf_nbuf_t head_msdu);
 
 void
+ol_rx_sniffer_deliver(
+    struct ol_txrx_vdev_t *vdev,
+    struct ol_txrx_peer_t *peer,
+    struct htt_rx_ind_hdr_t *rx_ind_header,
+    unsigned tid,
+    adf_nbuf_t head_msdu);
+
+void
 ol_rx_discard(
     struct ol_txrx_vdev_t *vdev,
     struct ol_txrx_peer_t *peer,
diff -Nuar qcacld-new-clean/CORE/CLD_TXRX/TXRX/ol_txrx.c qcacld-new/CORE/CLD_TXRX/TXRX/ol_txrx.c
--- qcacld-new-clean/CORE/CLD_TXRX/TXRX/ol_txrx.c
+++ qcacld-new/CORE/CLD_TXRX/TXRX/ol_txrx.c
@@ -803,6 +803,12 @@
     adf_os_mem_free(pdev);
 }
 
+void ol_txrx_pdev_set_sniffer_channel(ol_txrx_pdev_handle pdev,
+		unsigned char channel, int freq)
+{
+	htt_pdev_set_sniffer_channel(pdev->htt_pdev, channel, freq);
+}
+
 ol_txrx_vdev_handle
 ol_txrx_vdev_attach(
     ol_txrx_pdev_handle pdev,
@@ -886,14 +892,20 @@
     /* Default MAX Q depth for every VDEV */
     vdev->ll_pause.max_q_depth =
         ol_tx_cfg_max_tx_queue_depth_ll(vdev->pdev->ctrl_pdev);
+	if(vdev->opmode == wlan_op_mode_monitor) {
+		pdev->sniffer_vdev = vdev;
+		pdev->rx_opt_sniffer_proc = ol_rx_sniffer_deliver;
+		pdev->frame_format = wlan_frm_fmt_raw;
+	}
     /* add this vdev into the pdev's list */
     TAILQ_INSERT_TAIL(&pdev->vdev_list, vdev, vdev_list_elem);
 
     TXRX_PRINT(TXRX_PRINT_LEVEL_INFO1,
-        "Created vdev %p (%02x:%02x:%02x:%02x:%02x:%02x)\n",
+        "Created vdev %p (%02x:%02x:%02x:%02x:%02x:%02x) type %d\n",
         vdev,
         vdev->mac_addr.raw[0], vdev->mac_addr.raw[1], vdev->mac_addr.raw[2],
-        vdev->mac_addr.raw[3], vdev->mac_addr.raw[4], vdev->mac_addr.raw[5]);
+        vdev->mac_addr.raw[3], vdev->mac_addr.raw[4], vdev->mac_addr.raw[5],
+		vdev->opmode);
 
     /*
      * We've verified that htt_op_mode == wlan_op_mode,
@@ -1096,6 +1108,7 @@
     }
 
     peer->rx_opt_proc = pdev->rx_opt_proc;
+	peer->rx_opt_sniffer_proc = pdev->rx_opt_sniffer_proc;
 
     ol_rx_peer_init(pdev, peer);
 
diff -Nuar qcacld-new-clean/CORE/CLD_TXRX/TXRX/ol_txrx_types.h qcacld-new/CORE/CLD_TXRX/TXRX/ol_txrx_types.h
--- qcacld-new-clean/CORE/CLD_TXRX/TXRX/ol_txrx_types.h
+++ qcacld-new/CORE/CLD_TXRX/TXRX/ol_txrx_types.h
@@ -469,6 +469,13 @@
 			unsigned tid,
 			adf_nbuf_t msdu_list);
 
+	void (*rx_opt_sniffer_proc)(
+			struct ol_txrx_vdev_t *vdev,
+			struct ol_txrx_peer_t *peer,
+			struct htt_rx_ind_hdr_t *rx_ind_header,
+			unsigned tid,
+			adf_nbuf_t msdu_list);
+
     /* tx data delivery notification callback function */
     struct {
         ol_txrx_data_tx_cb func;
@@ -691,6 +698,8 @@
     ipa_uc_op_cb_type ipa_uc_op_cb;
     void *osif_dev;
 #endif /* IPA_UC_OFFLOAD */
+	/* to indicated monitor mode */
+	struct ol_txrx_vdev_t * sniffer_vdev;
 };
 
 struct ol_txrx_vdev_t {
@@ -869,6 +878,11 @@
 			    struct ol_txrx_peer_t *peer,
 			    unsigned tid,
 			    adf_nbuf_t msdu_list);
+	void (*rx_opt_sniffer_proc)(struct ol_txrx_vdev_t *vdev,
+			    struct ol_txrx_peer_t *peer,
+			    struct htt_rx_ind_hdr_t *rx_ind_header,
+			    unsigned tid,
+			    adf_nbuf_t msdu_list);
 
 #if defined(CONFIG_HL_SUPPORT)
 	struct ol_tx_frms_queue_t txqs[OL_TX_NUM_TIDS];
diff -Nuar qcacld-new-clean/CORE/HDD/inc/wlan_hdd_main.h qcacld-new/CORE/HDD/inc/wlan_hdd_main.h
--- qcacld-new-clean/CORE/HDD/inc/wlan_hdd_main.h
+++ qcacld-new/CORE/HDD/inc/wlan_hdd_main.h
@@ -559,7 +559,8 @@
    WLAN_HDD_MONITOR,
    WLAN_HDD_FTM,
    WLAN_HDD_IBSS,
-   WLAN_HDD_P2P_DEVICE
+   WLAN_HDD_P2P_DEVICE,
+   WLAN_HDD_SNIFFER
 }device_mode_t;
 
 typedef enum rem_on_channel_request_type
@@ -1131,6 +1132,7 @@
 #ifdef WLAN_FEATURE_LINK_LAYER_STATS
    v_BOOL_t isLinkLayerStatsSet;
 #endif
+	v_BOOL_t init_mon_flag;
 };
 
 #define WLAN_HDD_GET_STATION_CTX_PTR(pAdapter) (&(pAdapter)->sessionCtx.station)
@@ -1592,6 +1594,7 @@
 void hdd_set_station_ops( struct net_device *pWlanDev );
 tANI_U8* wlan_hdd_get_intf_addr(hdd_context_t* pHddCtx);
 void wlan_hdd_release_intf_addr(hdd_context_t* pHddCtx, tANI_U8* releaseAddr);
+int hdd_sniffer_start(struct net_device *dev);
 v_U8_t hdd_get_operating_channel( hdd_context_t *pHddCtx, device_mode_t mode );
 
 void hdd_set_conparam ( v_UINT_t newParam );
diff -Nuar qcacld-new-clean/CORE/HDD/inc/wlan_hdd_tx_rx.h qcacld-new/CORE/HDD/inc/wlan_hdd_tx_rx.h
--- qcacld-new-clean/CORE/HDD/inc/wlan_hdd_tx_rx.h
+++ qcacld-new/CORE/HDD/inc/wlan_hdd_tx_rx.h
@@ -216,6 +216,8 @@
                                      v_U8_t staId,
                                      WLANTL_RxMetaInfoType* pRxMetaInfo );
 #else
+extern VOS_STATUS hdd_rx_sniffer_cbk(v_VOID_t *vosContext, adf_nbuf_t rxBufChain,
+                                    v_U8_t staId);
 /**============================================================================
   @brief hdd_rx_packet_cbk() - Receive callback registered with TL.
   TL will call this to notify the HDD when a packet was received
diff -Nuar qcacld-new-clean/CORE/HDD/src/wlan_hdd_cfg80211.c qcacld-new/CORE/HDD/src/wlan_hdd_cfg80211.c
--- qcacld-new-clean/CORE/HDD/src/wlan_hdd_cfg80211.c
+++ qcacld-new/CORE/HDD/src/wlan_hdd_cfg80211.c
@@ -441,6 +441,10 @@
             BIT(SIR_MAC_MGMT_DEAUTH) |
             BIT(SIR_MAC_MGMT_ACTION),
     },
+	[NL80211_IFTYPE_MONITOR] = {
+		.tx = 0x0,
+		.rx = 0xffff,
+	},
 };
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0))
@@ -3657,7 +3661,8 @@
                              | BIT(NL80211_IFTYPE_ADHOC)
                              | BIT(NL80211_IFTYPE_P2P_CLIENT)
                              | BIT(NL80211_IFTYPE_P2P_GO)
-                             | BIT(NL80211_IFTYPE_AP);
+                             | BIT(NL80211_IFTYPE_AP)
+							 | BIT(NL80211_IFTYPE_MONITOR);
 
     if( pCfg->advertiseConcurrentOperation )
     {
@@ -13670,6 +13675,72 @@
      return 0;
 }
 
+static int wlan_hdd_cfg80211_set_monitor_channel(struct wiphy *wiphy,
+		                       struct cfg80211_chan_def *chandef)
+{
+	v_U32_t num_ch = 0;
+	int channel = 0;
+	hdd_adapter_t *pAdapter = NULL;
+	int freq = chandef->chan->center_freq;
+	hdd_context_t *pHddCtx = (hdd_context_t*) wiphy_priv(wiphy);
+	tHalHandle hHal = NULL;
+	int status;
+	v_BYTE_t mon_addr[VOS_MAC_ADDR_SIZE] = {0x00, 0x90, 0x3c, 0x00, 0x00, 0x00};
+
+	ENTER();
+
+	status = wlan_hdd_validate_context(pHddCtx);
+	if (0 != status)
+	{
+		VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+				"%s: HDD context is not valid", __func__);
+		return status;
+	}
+
+	pAdapter = hdd_get_adapter(pHddCtx, WLAN_HDD_SNIFFER);
+	if (NULL == pAdapter)
+	{
+		hddLog(VOS_TRACE_LEVEL_FATAL, "%s: Not in station context " ,__func__);
+		return -ENOENT;
+	}
+
+	hHal = WLAN_HDD_GET_HAL_CTX(pAdapter);
+
+	channel = ieee80211_frequency_to_channel(freq);
+
+	/* Check freq range */
+	if ((WNI_CFG_CURRENT_CHANNEL_STAMIN > channel) ||
+			(WNI_CFG_CURRENT_CHANNEL_STAMAX < channel))
+	{
+		hddLog(VOS_TRACE_LEVEL_ERROR,
+				"%s: Channel [%d] is outside valid range from %d to %d",
+				__func__, channel, WNI_CFG_CURRENT_CHANNEL_STAMIN,
+				WNI_CFG_CURRENT_CHANNEL_STAMAX);
+		return -EINVAL;
+	}
+
+	num_ch = WNI_CFG_VALID_CHANNEL_LIST_LEN;
+
+	if(WLAN_HDD_SNIFFER != pAdapter->device_mode) {
+		hddLog(VOS_TRACE_LEVEL_ERROR,
+				"%s: not in sniffer mode", __func__);
+		return -EINVAL;
+	}
+
+	/* okkwon todo : set the channel using WDA */
+	printk(KERN_ERR"okkwon %s : freq %u width %d center1 %u center2 %u\n",
+			__func__, chandef->chan->center_freq, chandef->width, chandef->center_freq1, 
+			chandef->center_freq2);
+
+	if (channel > 15) {
+	   	sme_RoamChannelChangeReq(hHal, mon_addr, channel, eCSR_DOT11_MODE_11ac);
+	} else {
+	   	sme_RoamChannelChangeReq(hHal, mon_addr, channel, eCSR_DOT11_MODE_11n);
+	}
+
+	return 0;
+}
+
 static int wlan_hdd_cfg80211_dump_survey(struct wiphy *wiphy,
                                          struct net_device *dev,
                                          int idx, struct survey_info *survey)
@@ -15133,4 +15204,5 @@
 #ifdef WLAN_FEATURE_ROAM_OFFLOAD
      .key_mgmt_set_pmk = wlan_hdd_cfg80211_key_mgmt_set_pmk,
 #endif
+	 .set_monitor_channel = wlan_hdd_cfg80211_set_monitor_channel,
 };
diff -Nuar qcacld-new-clean/CORE/HDD/src/wlan_hdd_debugfs.c qcacld-new/CORE/HDD/src/wlan_hdd_debugfs.c
--- qcacld-new-clean/CORE/HDD/src/wlan_hdd_debugfs.c
+++ qcacld-new/CORE/HDD/src/wlan_hdd_debugfs.c
@@ -28,11 +28,98 @@
 #ifdef WLAN_OPEN_SOURCE
 #include <wlan_hdd_includes.h>
 #include <wlan_hdd_wowl.h>
+#include "sme_Api.h"
+#include <net/cfg80211.h>
+#include <tl_shim.h>
+
 
 #define MAX_USER_COMMAND_SIZE_WOWL_ENABLE 8
 #define MAX_USER_COMMAND_SIZE_WOWL_PATTERN 512
 #define MAX_USER_COMMAND_SIZE_FRAME 4096
 
+typedef enum eFilterType{
+	MANAGEMENT_PACKET,
+	CONTROL_PACKET,
+	DATA_PACKET,
+	ALL_PACKET,
+} tFilterType;
+
+
+/**
+ * wlan_hdd_enable_monitor_cmd() - set monitor mode to firmware
+ * @data: pointer to apfind configuration data.
+ * @data_len: the length in byte of apfind data.
+ *
+ * This is called when wlan driver needs to send command to firmware to enable monitor mode.
+ *
+ * Return: An error code or 0 on success.
+ */
+static int wlan_hdd_enable_monitor_cmd(v_U8_t *data, int data_len)
+{
+    struct sme_enable_monitor_req  enable_req;
+    VOS_STATUS      status;
+    int ret_val = -EIO;
+
+    enable_req.request_data_len = data_len;
+    enable_req.request_data = data;
+
+    status = sme_enable_monitor_cmd(&enable_req);
+    if (VOS_STATUS_SUCCESS == status) {
+        ret_val = 0;
+    }
+    return ret_val;
+}
+
+/**
+ * wlan_hdd_filter_type_cmd() - set filter packet type configuration to firmware
+ * @data: pointer to filter type configuration data.
+ * @data_len: the length in byte of filter type data.
+ *
+ * This is called when wlan driver needs to set filter packet type to firmware in monitor mode.
+ *
+ * Return: An error code or 0 on success.
+ */
+static int wlan_hdd_filter_type_cmd(v_U8_t *data, int data_len)
+{
+	hdd_context_t *pHddCtx         = NULL;
+	v_CONTEXT_t pVosContext        = NULL;
+	hdd_adapter_t* pAdapter = NULL;
+    struct sme_filter_type_req  filter_type;
+    VOS_STATUS      status;
+    int ret_val = -EIO;
+
+	/* Get the Global VOSS Context */
+	pVosContext = vos_get_global_context(VOS_MODULE_ID_SYS, NULL);
+	if(!pVosContext) {
+		hddLog(VOS_TRACE_LEVEL_FATAL,"%s: Global VOS context is Null", __func__);
+		return ret_val;
+	}
+
+	/* Get the HDD context */
+	pHddCtx = (hdd_context_t *)vos_get_context(VOS_MODULE_ID_HDD, pVosContext );
+	if(!pHddCtx) {
+		hddLog(VOS_TRACE_LEVEL_FATAL,"%s: HDD context is Null",__func__);
+		return ret_val;
+	}
+
+	pAdapter = hdd_get_adapter(pHddCtx, WLAN_HDD_SNIFFER);
+	if(!pAdapter){
+		hddLog(VOS_TRACE_LEVEL_FATAL,"%s: pAdapter is Null",__func__);
+		return ret_val;
+	}
+
+	filter_type.vdev_id = pAdapter->sessionId;
+	hddLog(VOS_TRACE_LEVEL_FATAL,"%s: vdev_id=%u",__func__,filter_type.vdev_id);
+    filter_type.request_data_len = data_len;
+    filter_type.request_data = data;
+
+    status = sme_filter_type_cmd(&filter_type);
+    if (VOS_STATUS_SUCCESS == status) {
+        ret_val = 0;
+    }
+    return ret_val;
+}
+
 static ssize_t wcnss_wowenable_write(struct file *file,
                const char __user *buf, size_t count, loff_t *ppos)
 {
@@ -412,6 +499,180 @@
     return -EINVAL;
 }
 
+static ssize_t wcnss_enable_monitor_write(struct file *file,
+               const char __user *buf, size_t count, loff_t *ppos)
+{
+    hdd_adapter_t *pAdapter = (hdd_adapter_t *)file->private_data;
+
+    char cmd[MAX_USER_COMMAND_SIZE_WOWL_ENABLE + 1];
+    v_U8_t enable_mon = 0;
+
+    if ((NULL == pAdapter) || (WLAN_HDD_ADAPTER_MAGIC != pAdapter->magic))
+    {
+        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
+                  "%s: Invalid adapter or adapter has invalid magic.",
+                  __func__);
+
+        return -EINVAL;
+    }
+
+    if (count > MAX_USER_COMMAND_SIZE_WOWL_ENABLE)
+    {
+        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+                  "%s: Command length is larger than %d bytes.",
+                  __func__, MAX_USER_COMMAND_SIZE_WOWL_ENABLE);
+
+        return -EINVAL;
+    }
+
+    /* Get command from user */
+    if (copy_from_user(cmd, buf, count))
+        return -EFAULT;
+    cmd[count] = '\0';
+    if (kstrtou8(cmd, 0, &enable_mon))
+        return -EINVAL;
+
+    /* enable monitor */
+    if (enable_mon == 1){
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
+                  "%s: enable monitor mode.",__func__);
+	}
+	else if(enable_mon == 0){
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
+                  "%s: disable monitor mode.",__func__);
+	}
+	else{
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+                  "%s: valid command=0x%x.",__func__,enable_mon);
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+                  "%s: usage:",__func__);
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+                  "%s: 	1:enable monitor:",__func__);
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+                  "%s: 	0:disable monitor:",__func__);
+		return -EFAULT;
+	}
+	wlan_hdd_enable_monitor_cmd(&enable_mon,sizeof(v_U8_t));
+
+    return count;
+}
+
+static ssize_t wcnss_filter_packet_write(struct file *file,
+               const char __user *buf, size_t count, loff_t *ppos)
+{
+	hdd_adapter_t *pAdapter = (hdd_adapter_t *)file->private_data;
+
+	char cmd[MAX_USER_COMMAND_SIZE_WOWL_ENABLE + 1];
+	v_U8_t filter_type = 0;
+
+	if ((NULL == pAdapter) || (WLAN_HDD_ADAPTER_MAGIC != pAdapter->magic))
+	{
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
+				  "%s: Invalid adapter or adapter has invalid magic.",
+				  __func__);
+
+		return -EINVAL;
+	}
+
+	if (count > MAX_USER_COMMAND_SIZE_WOWL_ENABLE)
+	{
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+				  "%s: Command length is larger than %d bytes.",
+				  __func__, MAX_USER_COMMAND_SIZE_WOWL_ENABLE);
+
+		return -EINVAL;
+	}
+
+	/* Get command from user */
+	if (copy_from_user(cmd, buf, count))
+		return -EFAULT;
+	cmd[count] = '\0';
+	if (kstrtou8(cmd, 0, &filter_type))
+		return -EINVAL;
+
+	/* filter packetin monitor mode. */
+	if (filter_type < MANAGEMENT_PACKET || filter_type > ALL_PACKET){
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+                  "%s: valid command=0x%x.",__func__,filter_type);
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+                  "%s: usage:",__func__);
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+                  "%s: 	0: filter management packet.",__func__);
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+                  "%s: 	1: filter control packet.",__func__);
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+                  "%s: 	2: filter data packet.",__func__);
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+                  "%s: 	3: All packets.:",__func__);
+			return -EINVAL;
+	}	
+	wlan_hdd_filter_type_cmd(&filter_type,sizeof(v_U8_t));
+
+	return count;
+}
+
+static ssize_t wcnss_count_packet_write(struct file *file,
+               const char __user *buf, size_t count, loff_t *ppos)
+{
+	void *vos_ctx = vos_get_global_context(VOS_MODULE_ID_TL, NULL);
+	struct txrx_tl_shim_ctx *tl_shim = vos_get_context(VOS_MODULE_ID_TL,vos_ctx);
+	hdd_adapter_t *pAdapter = (hdd_adapter_t *)file->private_data;
+
+	char cmd[MAX_USER_COMMAND_SIZE_WOWL_ENABLE + 1];
+	v_U8_t enable_count = 0;
+
+	if ((NULL == pAdapter) || (WLAN_HDD_ADAPTER_MAGIC != pAdapter->magic))
+	{
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
+				  "%s: Invalid adapter or adapter has invalid magic.",
+				  __func__);
+
+		return -EINVAL;
+	}
+
+	if (count > MAX_USER_COMMAND_SIZE_WOWL_ENABLE)
+	{
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+				  "%s: Command length is larger than %d bytes.",
+				  __func__, MAX_USER_COMMAND_SIZE_WOWL_ENABLE);
+
+		return -EINVAL;
+	}
+
+	/* Get command from user */
+	if (copy_from_user(cmd, buf, count))
+		return -EFAULT;
+	cmd[count] = '\0';
+	if (kstrtou8(cmd, 0, &enable_count))
+		return -EINVAL;
+
+	/* enable monitor */
+	if (enable_count == 1){
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
+				  "%s: enable count packet numbers from firmware.",__func__);
+	}
+	else if(enable_count == 0){
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
+				  "%s: disable count packet numbers from firmware.",__func__);
+	}
+	else{
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+				  "%s: valid command=0x%x.",__func__,enable_count);
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+				  "%s: usage:",__func__);
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+				  "%s:	1:enable count packet numbers:",__func__);
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+				  "%s:	0:disable count packet numbers:",__func__);
+		return -EFAULT;
+	}
+
+	tl_shim->mon_enble_count = enable_count;
+
+	return count;
+}
+
+
 static int wcnss_debugfs_open(struct inode *inode, struct file *file)
 {
     if (inode->i_private)
@@ -443,6 +704,28 @@
     .llseek = default_llseek,
 };
 
+static const struct file_operations fops_enable_monitor = {
+    .write = wcnss_enable_monitor_write,
+    .open = wcnss_debugfs_open,
+    .owner = THIS_MODULE,
+    .llseek = default_llseek,
+};
+
+static const struct file_operations fops_filter_packet = {
+    .write = wcnss_filter_packet_write,
+    .open = wcnss_debugfs_open,
+    .owner = THIS_MODULE,
+    .llseek = default_llseek,
+};
+
+static const struct file_operations fops_count_packet = {
+    .write = wcnss_count_packet_write,
+    .open = wcnss_debugfs_open,
+    .owner = THIS_MODULE,
+    .llseek = default_llseek,
+};
+
+
 VOS_STATUS hdd_debugfs_init(hdd_adapter_t *pAdapter)
 {
     hdd_context_t *pHddCtx = WLAN_HDD_GET_CTX(pAdapter);
@@ -462,6 +745,15 @@
     if (NULL == debugfs_create_file("pattern_gen", S_IRUSR | S_IWUSR,
         pHddCtx->debugfs_phy, pAdapter, &fops_patterngen))
         return VOS_STATUS_E_FAILURE;
+	if (NULL == debugfs_create_file("enable_monitor", S_IRUSR | S_IWUSR,
+        pHddCtx->debugfs_phy, pAdapter, &fops_enable_monitor))
+        return VOS_STATUS_E_FAILURE;
+	if (NULL == debugfs_create_file("filter_packet", S_IRUSR | S_IWUSR,
+        pHddCtx->debugfs_phy, pAdapter, &fops_filter_packet))
+        return VOS_STATUS_E_FAILURE;
+	if (NULL == debugfs_create_file("count_packet", S_IRUSR | S_IWUSR,
+        pHddCtx->debugfs_phy, pAdapter, &fops_count_packet))
+        return VOS_STATUS_E_FAILURE;
 
     return VOS_STATUS_SUCCESS;
 }
diff -Nuar qcacld-new-clean/CORE/HDD/src/wlan_hdd_main.c qcacld-new/CORE/HDD/src/wlan_hdd_main.c
--- qcacld-new-clean/CORE/HDD/src/wlan_hdd_main.c
+++ qcacld-new/CORE/HDD/src/wlan_hdd_main.c
@@ -70,6 +70,7 @@
 #include <wlan_hdd_tx_rx.h>
 #include <palTimer.h>
 #include <wniApi.h>
+#include <limApi.h>
 #include <wlan_nlink_srv.h>
 #include <wlan_btc_svc.h>
 #include <wlan_hdd_cfg.h>
@@ -660,7 +661,8 @@
 #endif
    //Make sure that this callback corresponds to our device.
    if ((strncmp(dev->name, "wlan", 4)) &&
-      (strncmp(dev->name, "p2p", 3)))
+      (strncmp(dev->name, "p2p", 3)) &&
+	  (strncmp(dev->name, "mon", 3)))
       return NOTIFY_DONE;
 
    if ((pAdapter->magic != WLAN_HDD_ADAPTER_MAGIC) &&
@@ -7540,6 +7542,28 @@
 
    ENTER();
 
+   if (NULL == pAdapter)
+   {
+      VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
+                "%s: pAdapter context is Null", __func__);
+      return -ENODEV;
+   }
+   pHddCtx = (hdd_context_t*)pAdapter->pHddCtx;
+   if(pAdapter->device_mode == WLAN_HDD_SNIFFER)
+   {
+   	tHalHandle hHal = WLAN_HDD_GET_HAL_CTX(pAdapter);
+   	tpAniSirGlobal pMac = (tpAniSirGlobal) hHal;
+	tpPESession psessionEntry;
+	tANI_U8 sessionId;
+	hdd_station_ctx_t* pHddStaCtx = WLAN_HDD_GET_STATION_CTX_PTR(pAdapter);
+	psessionEntry = peFindSessionByBssid(pMac, pAdapter->macAddressCurrent.bytes, &sessionId);
+	if(psessionEntry)
+	{
+		WLANTL_ClearSTAClient(pHddCtx->pvosContext, pHddStaCtx->conn_info.staId[0]);
+		printk("hangtian: delete pe session\n");
+		peDeleteSession(pMac, psessionEntry);
+	}
+   }
    MTRACE(vos_trace(VOS_MODULE_ID_HDD, TRACE_CODE_HDD_OPEN_REQUEST,
                     pAdapter->sessionId, pAdapter->device_mode));
 
@@ -7881,7 +7905,132 @@
    return;
 }
 
-static struct net_device_ops wlan_drv_ops = {
+int hdd_sniffer_start(struct net_device *dev)
+{
+	hdd_adapter_t *pAdapter = WLAN_HDD_GET_PRIV_PTR(dev);
+	tHalHandle hHal = WLAN_HDD_GET_HAL_CTX(pAdapter);
+	hdd_context_t *pHddCtx = WLAN_HDD_GET_CTX(pAdapter);
+	WLAN_STADescType staDesc = {0};
+	hdd_station_ctx_t *pHddStaCtx = WLAN_HDD_GET_STATION_CTX_PTR(pAdapter);
+	VOS_STATUS vosStatus = VOS_STATUS_E_FAILURE;
+	int status;
+	v_BYTE_t mon_addr[VOS_MAC_ADDR_SIZE] = {0x00, 0x90, 0x3c, 0x00, 0x00, 0x00};
+	
+	staDesc.ucSTAId = pHddStaCtx->conn_info.staId[0];
+		staDesc.wSTAType = WLAN_STA_SNIFFER;
+		vos_copy_macaddr( &staDesc.vSelfMACAddress, &pAdapter->macAddressCurrent );
+		staDesc.ucQosEnabled = 0;
+		staDesc.ucProtectedFrame = 0;
+#ifdef FEATURE_WLAN_ESE
+		staDesc.ucIsEseSta = 0;
+#endif
+		staDesc.ucIsReplayCheckValid = VOS_FALSE;
+		staDesc.ucSwFrameTXXlation = 1;
+		staDesc.ucSwFrameRXXlation = 1;
+		staDesc.ucAddRmvLLC = 1;
+
+		/* okkwon todo : what values -_-? */
+		staDesc.ucUcastSig = 0;
+		staDesc.ucBcastSig = 0;
+		staDesc.ucInitState = WLANTL_STA_AUTHENTICATED;
+
+		/* -_-;;; */
+		pHddCtx->sta_to_adapter[staDesc.ucSTAId] = pAdapter;	
+	vosStatus = WLANTL_RegisterSTAClient( pHddCtx->pvosContext,
+						hdd_rx_sniffer_cbk,
+						hdd_tx_complete_cbk,
+						hdd_tx_fetch_packet_cbk, &staDesc,
+						0 );
+	sme_StartSniffer(hHal, pAdapter->sessionId);
+
+
+	if(pAdapter == NULL) {
+		VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
+				"%s: HDD adapter context is Null", __func__);
+		return -EINVAL;
+	}
+
+	hdd_prevent_suspend();
+
+	/* vdev start */
+	/* okkwon todo : why pAdapter->sessionId does not work -_-? */
+	sme_RoamChannelChangeReq(hHal, mon_addr, 1, eCSR_DOT11_MODE_11n);
+
+	/* carrier on */
+	INIT_COMPLETION(pAdapter->linkup_event_var);
+	netif_carrier_on(dev);
+	status = wait_for_completion_interruptible_timeout(&pAdapter->linkup_event_var,
+			msecs_to_jiffies(ASSOC_LINKUP_TIMEOUT));
+	netif_tx_start_all_queues(dev);
+	if(!status)
+	{
+		hddLog(VOS_TRACE_LEVEL_WARN, "%s: Warning:ASSOC_LINKUP_TIMEOUT", __func__);
+	}
+
+	return 0;
+}
+
+
+
+int hdd_sniffer_stop(struct net_device *dev)
+{
+	/* carrier off */
+	netif_tx_disable(dev);
+	netif_carrier_off(dev);
+
+	/* okkwon todo : vdev down / stop*/
+
+	hdd_allow_suspend();
+
+	return 0;
+}
+
+VOS_STATUS null_rx_mgmt_cbk ( v_PVOID_t pvosGCtx, v_PVOID_t vosBuff)
+{
+	vos_pkt_t *pVosPkt;
+
+	pVosPkt = (vos_pkt_t *)vosBuff;
+
+	vos_pkt_return_packet(pVosPkt);
+	pVosPkt = NULL;
+
+	return VOS_STATUS_SUCCESS;
+}
+
+int hdd_sniffer_open (struct net_device *dev)
+{
+	hdd_adapter_t *pAdapter = WLAN_HDD_GET_PRIV_PTR(dev);
+		hdd_context_t *pHddCtx = WLAN_HDD_GET_CTX(pAdapter);
+	//VOS_STATUS vosStatus = VOS_STATUS_E_FAILURE;
+	WLAN_STADescType staDesc = {0};
+	hdd_station_ctx_t *pHddStaCtx = WLAN_HDD_GET_STATION_CTX_PTR(pAdapter);
+
+	if (VOS_STATUS_SUCCESS != wlan_hdd_exit_lowpower(pHddCtx, pAdapter))
+	{
+		hddLog(VOS_TRACE_LEVEL_ERROR, "%s: Failed to bring "
+				"wlan out of power save", __func__);
+		return -EINVAL;
+	}
+	staDesc.ucSTAId = pHddStaCtx->conn_info.staId[0];
+	
+	pHddCtx->sta_to_adapter[staDesc.ucSTAId] = pAdapter;
+
+	/*vosStatus = WLANTL_DeRegisterMgmtFrmClient(pHddCtx->pvosContext);
+	vosStatus = WLANTL_RegisterMgmtFrmClient(pHddCtx->pvosContext,
+			null_rx_mgmt_cbk);*/
+
+	set_bit(DEVICE_IFACE_OPENED, &pAdapter->event_flags);
+
+	netif_start_queue(dev);
+	//hdd_sniffer_start(dev);
+
+	return 0;
+}
+
+
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,29))
+  static struct net_device_ops wlan_drv_ops = {
       .ndo_open = hdd_open,
       .ndo_stop = hdd_stop,
       .ndo_uninit = hdd_uninit,
@@ -7908,14 +8057,41 @@
       .ndo_get_stats = hdd_stats,
       .ndo_do_ioctl = hdd_ioctl,
       .ndo_set_mac_address = hdd_set_mac_address,
+ };
+static struct net_device_ops wlan_sniffer_drv_ops = {
+	.ndo_open = hdd_sniffer_open,
+	.ndo_stop = hdd_stop,
+	.ndo_uninit = hdd_uninit,
+	.ndo_start_xmit = hdd_hard_start_xmit,
+	.ndo_tx_timeout = hdd_tx_timeout,
+	.ndo_get_stats = hdd_stats,
+	.ndo_do_ioctl = hdd_ioctl,
+	.ndo_set_mac_address = hdd_set_mac_address,
+	.ndo_select_queue    = hdd_select_queue,
 };
-
+#endif
 
 void hdd_set_station_ops( struct net_device *pWlanDev )
 {
       pWlanDev->netdev_ops = &wlan_drv_ops;
 }
 
+void hdd_set_sniffer_ops( struct net_device *pWlanDev )
+{
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,29))
+      pWlanDev->netdev_ops = &wlan_sniffer_drv_ops;
+#else
+      pWlanDev->open = hdd_sniffer_open;
+      pWlanDev->stop = hdd_stop;
+      pWlanDev->uninit = hdd_uninit;
+      pWlanDev->hard_start_xmit = hdd_hard_start_xmit;
+      pWlanDev->tx_timeout = hdd_tx_timeout;
+      pWlanDev->get_stats = hdd_stats;
+      pWlanDev->do_ioctl = hdd_ioctl;
+      pWlanDev->set_mac_address = hdd_set_mac_address;
+#endif
+}
+
 static hdd_adapter_t* hdd_alloc_station_adapter( hdd_context_t *pHddCtx, tSirMacAddr macAddr, const char* name )
 {
    struct net_device *pWlanDev = NULL;
@@ -8514,6 +8690,10 @@
 
    switch(session_type)
    {
+	   case WLAN_HDD_SNIFFER:
+		   sme_DisablePowerSave (pHddCtx->hHal, ePMC_IDLE_MODE_POWER_SAVE);
+		   sme_DisablePowerSave(pHddCtx->hHal, ePMC_BEACON_MODE_POWER_SAVE);
+		   break;
        case WLAN_HDD_INFRA_STATION:
        case WLAN_HDD_SOFTAP:
        case WLAN_HDD_P2P_CLIENT:
@@ -8834,6 +9014,32 @@
          netif_carrier_off(pAdapter->dev);
       }
          break;
+	  case WLAN_HDD_SNIFFER:
+		 {
+			 pAdapter = hdd_alloc_station_adapter(pHddCtx, macAddr, iface_name);
+
+			 if( NULL == pAdapter )
+				 return NULL;
+
+			 hdd_set_sniffer_ops(pAdapter->dev);
+
+			 pAdapter->wdev.iftype = NL80211_IFTYPE_MONITOR;
+			 pAdapter->device_mode = session_type;
+			 /* okkwon todo : add radiotap info */
+			 pAdapter->dev->type = ARPHRD_IEEE80211_RADIOTAP;
+
+            hddLog(VOS_TRACE_LEVEL_ERROR,"%s:jiuzhoong 0",__func__);
+			 status = hdd_init_station_mode(pAdapter);
+			 if( VOS_STATUS_SUCCESS != status )
+				 goto err_free_netdev;
+
+			 status = hdd_register_interface( pAdapter, rtnl_held );
+
+			 //stop the interface TX queue
+			 netif_tx_disable(pAdapter->dev);
+			 netif_carrier_off(pAdapter->dev);
+		 }
+		 break;
       default:
       {
          hddLog(VOS_TRACE_LEVEL_FATAL,"%s Invalid session type %d",
@@ -8958,7 +9164,8 @@
 #undef HDD_SMPS_PARAM_VALUE_S
    }
 
-  if (VOS_FTM_MODE != vos_get_conparam())
+  if (VOS_FTM_MODE != vos_get_conparam() &&
+		  VOS_SNIFFER_MODE != vos_get_conparam())
   {
        ret = process_wma_set_command((int)pAdapter->sessionId,
                          (int)WMI_PDEV_PARAM_HYST_EN,
@@ -11404,8 +11611,9 @@
 #ifdef WLAN_OPEN_P2P_INTERFACE
    hdd_adapter_t *pP2pAdapter = NULL;
 #endif
-   hdd_context_t *pHddCtx = NULL;
-   v_CONTEXT_t pVosContext= NULL;
+	   hdd_adapter_t *pSnifferAdapter = NULL;
+	   hdd_context_t *pHddCtx = NULL;
+	   v_CONTEXT_t pVosContext= NULL;
 #ifdef WLAN_BTAMP_FEATURE
    VOS_STATUS vStatus = VOS_STATUS_SUCCESS;
    WLANBAP_ConfigType btAmpConfig;
@@ -11899,61 +12107,84 @@
 #else
    rtnl_lock_enable = FALSE;
 #endif
-
-   pAdapter = hdd_open_adapter( pHddCtx, WLAN_HDD_INFRA_STATION, "wlan%d",
-       wlan_hdd_get_intf_addr(pHddCtx), rtnl_lock_enable );
-
+	if (VOS_SNIFFER_MODE == hdd_get_conparam())
+	{
+       v_BYTE_t mon_addr[VOS_MAC_ADDR_SIZE] = {0x00, 0x90, 0x3c, 0x00, 0x00, 0x00};
+	   pSnifferAdapter = hdd_open_adapter(pHddCtx, WLAN_HDD_SNIFFER, "mon%d",
+			   mon_addr, rtnl_lock_enable);
+	   if ( NULL == pSnifferAdapter )
+	   {
+		   hddLog(VOS_TRACE_LEVEL_FATAL,
+				   "%s: Failed to do hdd_open_adapter for Sniffer Interface",
+				   __func__);
+		   goto err_close_adapter;
+	   }
+		else
+		{	pAdapter = pSnifferAdapter;
+			hddLog(VOS_TRACE_LEVEL_FATAL,"%s: Monitor mode.",__func__);
+			if(pSnifferAdapter->dev->netdev_ops->ndo_open(pSnifferAdapter->dev) == 0)
+			{
+				//rtnl_lock();
+				dev_change_flags(pSnifferAdapter->dev, IFF_UP | IFF_RUNNING);
+				//rtnl_unlock();
+			}
+		}  
+	}
+	else{
+		pAdapter = hdd_open_adapter( pHddCtx, WLAN_HDD_INFRA_STATION, "wlan%d",
+			   wlan_hdd_get_intf_addr(pHddCtx), rtnl_lock_enable );
+		
 #ifdef WLAN_OPEN_P2P_INTERFACE
-   /* Open P2P device interface */
-   if (pAdapter != NULL)
-   {
-      if (pHddCtx->cfg_ini->isP2pDeviceAddrAdministrated)
-      {
-         vos_mem_copy( pHddCtx->p2pDeviceAddress.bytes,
-                     pHddCtx->cfg_ini->intfMacAddr[0].bytes,
-                     sizeof(tSirMacAddr));
-
-         /* Generate the P2P Device Address.  This consists of the device's
-          * primary MAC address with the locally administered bit set.
-          */
-         pHddCtx->p2pDeviceAddress.bytes[0] |= 0x02;
-      }
-      else
-      {
-         tANI_U8* p2p_dev_addr = wlan_hdd_get_intf_addr(pHddCtx);
-         if (p2p_dev_addr != NULL)
-         {
-            vos_mem_copy(&pHddCtx->p2pDeviceAddress.bytes[0],
-                         p2p_dev_addr, VOS_MAC_ADDR_SIZE);
-         }
-         else
-         {
-            hddLog(VOS_TRACE_LEVEL_FATAL,
-                   "%s: Failed to allocate mac_address for p2p_device",
-                   __func__);
-            goto err_close_adapter;
-         }
-      }
-
-      pP2pAdapter = hdd_open_adapter( pHddCtx, WLAN_HDD_P2P_DEVICE, "p2p%d",
-                        &pHddCtx->p2pDeviceAddress.bytes[0], rtnl_lock_enable );
-
-      if ( NULL == pP2pAdapter )
-      {
-         hddLog(VOS_TRACE_LEVEL_FATAL,
-                "%s: Failed to do hdd_open_adapter for P2P Device Interface",
-                __func__);
-         goto err_close_adapter;
-      }
-   }
+	   /* Open P2P device interface */
+	   if (pAdapter != NULL)
+	   {
+	      if (pHddCtx->cfg_ini->isP2pDeviceAddrAdministrated)
+	      {
+	         vos_mem_copy( pHddCtx->p2pDeviceAddress.bytes,
+	                     pHddCtx->cfg_ini->intfMacAddr[0].bytes,
+	                     sizeof(tSirMacAddr));
+
+	         /* Generate the P2P Device Address.  This consists of the device's
+	          * primary MAC address with the locally administered bit set.
+	          */
+	         pHddCtx->p2pDeviceAddress.bytes[0] |= 0x02;
+	      }
+	      else
+	      {
+	         tANI_U8* p2p_dev_addr = wlan_hdd_get_intf_addr(pHddCtx);
+	         if (p2p_dev_addr != NULL)
+	         {
+	            vos_mem_copy(&pHddCtx->p2pDeviceAddress.bytes[0],
+	                         p2p_dev_addr, VOS_MAC_ADDR_SIZE);
+	         }
+	         else
+	         {
+	            hddLog(VOS_TRACE_LEVEL_FATAL,
+	                   "%s: Failed to allocate mac_address for p2p_device",
+	                   __func__);
+	            goto err_close_adapter;
+	         }
+	      }
+
+	      pP2pAdapter = hdd_open_adapter( pHddCtx, WLAN_HDD_P2P_DEVICE, "p2p%d",
+	                        &pHddCtx->p2pDeviceAddress.bytes[0], rtnl_lock_enable );
+
+	      if ( NULL == pP2pAdapter )
+	      {
+	         hddLog(VOS_TRACE_LEVEL_FATAL,
+	                "%s: Failed to do hdd_open_adapter for P2P Device Interface",
+	                __func__);
+	         goto err_close_adapter;
+	      }
+	   }
 #endif
-
+	}
    if( pAdapter == NULL )
    {
-      hddLog(VOS_TRACE_LEVEL_ERROR, "%s: hdd_open_adapter failed", __func__);
-      goto err_close_adapter;
+	  hddLog(VOS_TRACE_LEVEL_ERROR, "%s: hdd_open_adapter failed", __func__);
+	  goto err_close_adapter;
    }
-
+	
 #ifdef QCA_WIFI_2_0
 
    /* target hw version/revision would only be retrieved after firmware donwload */
diff -Nuar qcacld-new-clean/CORE/HDD/src/wlan_hdd_tx_rx.c qcacld-new/CORE/HDD/src/wlan_hdd_tx_rx.c
--- qcacld-new-clean/CORE/HDD/src/wlan_hdd_tx_rx.c
+++ qcacld-new/CORE/HDD/src/wlan_hdd_tx_rx.c
@@ -641,6 +641,11 @@
    hdd_station_ctx_t *pHddStaCtx = &pAdapter->sessionCtx.station;
    v_BOOL_t txSuspended = VOS_FALSE;
 
+   if (hdd_get_conparam() == VOS_SNIFFER_MODE) {
+	   kfree_skb(skb);
+	   return NETDEV_TX_OK;
+   }
+
    ++pAdapter->hdd_stats.hddTxRxStats.txXmitCalled;
 
    if (unlikely(netif_subqueue_stopped(dev, skb))) {
@@ -2144,7 +2149,82 @@
     return;
 }
 #else
+VOS_STATUS hdd_rx_sniffer_cbk(v_VOID_t *vosContext,
+		adf_nbuf_t rxBuf, v_U8_t staId)
+{
+	hdd_adapter_t *pAdapter = NULL;
+	hdd_context_t *pHddCtx = NULL;
+	int rxstat;
+	struct sk_buff *skb = NULL;
+	hdd_station_ctx_t *pHddStaCtx = NULL;
+
+	if ((NULL == vosContext) || (NULL == rxBuf))
+	{
+		VOS_TRACE( VOS_MODULE_ID_HDD_DATA, VOS_TRACE_LEVEL_ERROR,"%s: Null params being passed", __func__);
+		return VOS_STATUS_E_FAILURE;
+	}
+
+	pHddCtx = (hdd_context_t *)vos_get_context( VOS_MODULE_ID_HDD, vosContext );
+	if ( NULL == pHddCtx )
+	{
+		VOS_TRACE( VOS_MODULE_ID_HDD_DATA, VOS_TRACE_LEVEL_ERROR,"%s: HDD adapter context is Null", __func__);
+		return VOS_STATUS_E_FAILURE;
+	}
+
+	pAdapter = pHddCtx->sta_to_adapter[staId];
+	if( NULL == pAdapter )
+	{
+		return VOS_STATUS_E_FAILURE;
+	}
+	++pAdapter->hdd_stats.hddTxRxStats.rxChains;
+
+	skb = (struct sk_buff *) rxBuf;
+	if (WLAN_HDD_ADAPTER_MAGIC != pAdapter->magic)
+	{
+		VOS_TRACE(VOS_MODULE_ID_HDD_DATA, VOS_TRACE_LEVEL_FATAL,
+				"Magic cookie(%x) for adapter sanity verification is invalid", pAdapter->magic);
+		return eHAL_STATUS_FAILURE;
+	}
+
+	pHddStaCtx = WLAN_HDD_GET_STATION_CTX_PTR(pAdapter);
+	if ((pHddStaCtx->conn_info.proxyARPService) &&
+			cfg80211_is_gratuitous_arp_unsolicited_na(skb))
+	{
+		++pAdapter->hdd_stats.hddTxRxStats.rxDropped;
+		VOS_TRACE(VOS_MODULE_ID_HDD_DATA, VOS_TRACE_LEVEL_INFO,
+				"%s: Dropping HS 2.0 Gratuitous ARP or Unsolicited NA", __func__);
+		kfree_skb(skb);
+		return VOS_STATUS_SUCCESS;
+	}
+
+	skb->dev = pAdapter->dev;
+	skb_reset_mac_header(skb);
+	skb->ip_summed = CHECKSUM_UNNECESSARY;
+	skb->pkt_type = PACKET_OTHERHOST;
+	skb->protocol = htons(ETH_P_802_2);
+	++pAdapter->hdd_stats.hddTxRxStats.rxPackets;
+	++pAdapter->stats.rx_packets;
+	pAdapter->stats.rx_bytes += skb->len;
+#ifdef WLAN_FEATURE_HOLD_RX_WAKELOCK
+	vos_wake_lock_timeout_acquire(&pHddCtx->rx_wake_lock,
+			HDD_WAKE_LOCK_DURATION);
+#endif
+	rxstat = netif_rx_ni(skb);
+	//rxstat = netif_receive_skb(skb);
+	if (NET_RX_SUCCESS == rxstat)
+	{
+		++pAdapter->hdd_stats.hddTxRxStats.rxDelivered;
+	}
+	else
+	{
+		++pAdapter->hdd_stats.hddTxRxStats.rxRefused;
+	}
+
+	pAdapter->dev->last_rx = jiffies;
 
+	return VOS_STATUS_SUCCESS;
+
+}
 /**============================================================================
   @brief hdd_rx_packet_cbk() - Receive callback registered with TL.
   TL will call this to notify the HDD when one or more packets were
diff -Nuar qcacld-new-clean/CORE/MAC/inc/sirApi.h qcacld-new/CORE/MAC/inc/sirApi.h
--- qcacld-new-clean/CORE/MAC/inc/sirApi.h
+++ qcacld-new/CORE/MAC/inc/sirApi.h
@@ -1105,6 +1105,18 @@
     tSirSupChnl         supportedChannels;
 } tJoinReassocInfo, *tpJoinReassocInfo;
 
+typedef struct sSirSmeSnifferReq
+{
+	tANI_U16            messageType;            // eWNI_SME_REQ
+	tANI_U16            length;
+	tANI_U8             sessionId;
+	tANI_U16            transactionId;
+	tSirMacAddr         selfMacAddr;
+	tANI_U8             dot11mode;
+	tVOS_CON_MODE       staPersona;
+	ePhyChanBondState   cbMode;
+} tSirSmeSnifferReq, *tpSirSmeSnifferReq;
+
 /// Definition for join request
 /// ---> MAC
 /// WARNING! If you add a field in JOIN REQ.
@@ -1201,6 +1213,15 @@
 
 } tSirSmeJoinReq, *tpSirSmeJoinReq;
 
+typedef struct sSirSmeSnifferRsp
+{
+	tANI_U16                messageType;
+	tANI_U16                length;
+	tANI_U8                 sessionId;
+	tANI_U16                transactionId;
+	tSirResultCodes    statusCode;
+} tSirSmeSnifferRsp, *tpSirSmeSnifferRsp;
+
 /// Definition for reponse message to previously issued join request
 /// MAC --->
 typedef struct sSirSmeJoinRsp
diff -Nuar qcacld-new-clean/CORE/MAC/inc/wniApi.h qcacld-new/CORE/MAC/inc/wniApi.h
--- qcacld-new-clean/CORE/MAC/inc/wniApi.h
+++ qcacld-new/CORE/MAC/inc/wniApi.h
@@ -413,6 +413,8 @@
 #ifdef WLAN_FEATURE_EXTWOW_SUPPORT
     eWNI_SME_READY_TO_EXTWOW_IND,
 #endif
+    eWNI_SME_SNIFFER_REQ,
+	eWNI_SME_SNIFFER_RSP,
     eWNI_SME_MSG_TYPES_END
 };
 
diff -Nuar qcacld-new-clean/CORE/MAC/src/include/sirParams.h qcacld-new/CORE/MAC/src/include/sirParams.h
--- qcacld-new-clean/CORE/MAC/src/include/sirParams.h
+++ qcacld-new/CORE/MAC/src/include/sirParams.h
@@ -752,6 +752,8 @@
 #ifdef WLAN_FEATURE_APFIND
 #define SIR_HAL_APFIND_SET_CMD             (SIR_HAL_ITC_MSG_TYPES_BEGIN + 306)
 #endif /* WLAN_FEATURE_APFIND */
+#define SIR_HAL_ENABLE_MONITOR_CMD             (SIR_HAL_ITC_MSG_TYPES_BEGIN + 307)
+#define SIR_HAL_FILTER_TYPE_CMD             (SIR_HAL_ITC_MSG_TYPES_BEGIN + 308)
 
 #define SIR_HAL_MSG_TYPES_END              (SIR_HAL_MSG_TYPES_BEGIN + 0x1FF)
 
diff -Nuar qcacld-new-clean/CORE/MAC/src/pe/lim/limProcessMessageQueue.c qcacld-new/CORE/MAC/src/pe/lim/limProcessMessageQueue.c
--- qcacld-new-clean/CORE/MAC/src/pe/lim/limProcessMessageQueue.c
+++ qcacld-new/CORE/MAC/src/pe/lim/limProcessMessageQueue.c
@@ -2177,6 +2177,12 @@
         limMsg->bodyptr = NULL;
         break;
 
+	case eWNI_SME_SNIFFER_REQ:
+		limProcessSmeReqMessages(pMac, limMsg);
+		vos_mem_free((v_VOID_t*)limMsg->bodyptr);
+		limMsg->bodyptr = NULL;
+		break;
+
     case eWNI_SME_START_BEACON_REQ:
         limProcessSmeReqMessages(pMac, limMsg);
         vos_mem_free((v_VOID_t*)limMsg->bodyptr);
diff -Nuar qcacld-new-clean/CORE/MAC/src/pe/lim/limProcessMlmReqMessages.c qcacld-new/CORE/MAC/src/pe/lim/limProcessMlmReqMessages.c
--- qcacld-new-clean/CORE/MAC/src/pe/lim/limProcessMlmReqMessages.c
+++ qcacld-new/CORE/MAC/src/pe/lim/limProcessMlmReqMessages.c
@@ -4907,7 +4907,19 @@
 #ifdef WLAN_FEATURE_11AC
     if ( peSession->vhtCapability )
     {
-        limSendSwitchChnlParams( pMac, channel, limGet11ACPhyCBState( pMac,channel,secChannelOffset,peSession->apCenterChan, peSession), maxTxPower, peSessionId);
+		if (peSession->operMode != BSS_OPERATIONAL_MODE_SNIFFER) {
+			/* non sniffer mode */
+			printk(KERN_ERR"okkwon : AP mode? apCenterChan %d\n", peSession->apCenterChan);
+		   	limSendSwitchChnlParams( pMac, channel, limGet11ACPhyCBState( pMac,channel,secChannelOffset,peSession->apCenterChan, peSession), maxTxPower, peSessionId);
+		} else {
+			printk(KERN_ERR"okkwon : non AP mode?\n");
+			/* okkwon todo : not a good way to distinguish channel width -_-;;*/
+			if (channel < 15) {
+			   	limSendSwitchChnlParams( pMac, channel, 0, maxTxPower, peSessionId);
+			} else {
+			   	limSendSwitchChnlParams( pMac, channel, secChannelOffset, maxTxPower, peSessionId);
+			}
+		}
     }
     else
 #endif
diff -Nuar qcacld-new-clean/CORE/MAC/src/pe/lim/limProcessSmeReqMessages.c qcacld-new/CORE/MAC/src/pe/lim/limProcessSmeReqMessages.c
--- qcacld-new-clean/CORE/MAC/src/pe/lim/limProcessSmeReqMessages.c
+++ qcacld-new/CORE/MAC/src/pe/lim/limProcessSmeReqMessages.c
@@ -90,6 +90,7 @@
 static tANI_BOOLEAN __limProcessSmeStartBssReq(tpAniSirGlobal, tpSirMsgQ pMsg);
 static void __limProcessSmeScanReq(tpAniSirGlobal, tANI_U32 *);
 static void __limProcessSmeJoinReq(tpAniSirGlobal, tANI_U32 *);
+static void __limProcessSmeSnifferReq(tpAniSirGlobal, tANI_U32 *);
 static void __limProcessSmeReassocReq(tpAniSirGlobal, tANI_U32 *);
 static void __limProcessSmeDisassocReq(tpAniSirGlobal, tANI_U32 *);
 static void __limProcessSmeDisassocCnf(tpAniSirGlobal, tANI_U32 *);
@@ -228,6 +229,17 @@
         return true;
 } /*** end __limIsSmeAssocCnfValid() ***/
 
+static tANI_U16 __limGetSmeSnifferReqSizeForAlloc(tANI_U8 *pBuf)
+{
+	tANI_U16 len = 0;
+
+	if (!pBuf)
+		return len;
+
+	pBuf += sizeof(tANI_U16);
+	len = limGetU16( pBuf );
+	return (len + sizeof( tANI_U16 ));
+}
 
 /**
  * __limGetSmeJoinReqSizeForAlloc()
@@ -1680,6 +1692,107 @@
                   sizeof(tSirDFSChannelList), 0);
 }
 
+static void __limProcessSmeSnifferReq(tpAniSirGlobal pMac, tANI_U32 *pMsgBuf)
+{
+	tpSirSmeSnifferReq pSmeSnifferReq = NULL;
+	tpPESession psessionEntry = NULL;
+	tANI_U8 sessionId;
+	tANI_U16 nSize;
+	tSirResultCodes     retCode = eSIR_SME_SUCCESS;
+	tANI_U16            smetransactionId;
+	tANI_U8             smesessionId;
+	
+	printk(KERN_ERR"okkwon : %s\n", __func__);
+
+	nSize = __limGetSmeSnifferReqSizeForAlloc((tANI_U8*) pMsgBuf);
+
+	pSmeSnifferReq = vos_mem_malloc(nSize);
+	if ( NULL == pSmeSnifferReq )
+	{
+		limLog(pMac, LOGP, FL("call to AllocateMemory failed for "
+					"pSmeJoinReq"));
+		retCode = eSIR_SME_RESOURCES_UNAVAILABLE;
+		goto end;
+	}
+	(void) vos_mem_set((void *) pSmeSnifferReq, nSize, 0);
+
+	if (limSnifferReqSerDes(pMac, pSmeSnifferReq, (tANI_U8 *)pMsgBuf) == eSIR_FAILURE)
+	{
+		limLog(pMac, LOGW, FL("received SME_SNIFFER_REQ with invalid data"));
+		retCode = eSIR_SME_INVALID_PARAMETERS;
+		goto end;
+	}
+
+	if((psessionEntry = peFindSessionByBssid(pMac, pSmeSnifferReq->selfMacAddr, &sessionId)) != NULL)
+	{
+		limLog(pMac, LOGE, FL("Session(%d) Already exists for selfmac: "
+					MAC_ADDRESS_STR),sessionId,
+				MAC_ADDR_ARRAY(pSmeSnifferReq->selfMacAddr));
+		retCode = eSIR_SME_REFUSED;
+		psessionEntry = NULL;
+		goto end;
+	} else {
+		/* Try to Create a new session */
+		if((psessionEntry = peCreateSession(pMac,pSmeSnifferReq->selfMacAddr,&sessionId, pMac->lim.maxStation,
+			eSIR_INFRASTRUCTURE_MODE)) == NULL)
+		{
+			limLog(pMac, LOGE, FL("Session Can not be created "));
+			retCode = eSIR_SME_RESOURCES_UNAVAILABLE;
+			goto end;
+		}
+	}
+
+	handleHTCapabilityandHTInfo(pMac, psessionEntry);
+	psessionEntry->isAmsduSupportInAMPDU = TRUE;
+	psessionEntry->peSessionId = sessionId;
+	psessionEntry->smeSessionId = pSmeSnifferReq->sessionId;
+	psessionEntry->transactionId = pSmeSnifferReq->transactionId;
+	psessionEntry->beaconParams.beaconInterval = 0;
+	sirCopyMacAddr(psessionEntry->selfMacAddr,pSmeSnifferReq->selfMacAddr);
+	psessionEntry->statypeForBss = STA_ENTRY_SELF;
+	psessionEntry->dot11mode  = pSmeSnifferReq->dot11mode;
+	psessionEntry->pePersona = pSmeSnifferReq->staPersona;
+	psessionEntry->vhtCapability = TRUE;
+	psessionEntry->txBFIniFeatureEnabled = TRUE;
+	psessionEntry->txMuBformee = FALSE;
+	psessionEntry->currentOperChannel = 1;
+	psessionEntry->htSupportedChannelWidthSet = (pSmeSnifferReq->cbMode)?1:0;
+	psessionEntry->htSecondaryChannelOffset = pSmeSnifferReq->cbMode;
+	psessionEntry->limRmfEnabled = 0;
+	psessionEntry->isFastTransitionEnabled = FALSE;
+	psessionEntry->isFastRoamIniFeatureEnabled = FALSE;
+	psessionEntry->txLdpcIniFeatureEnabled = TRUE;
+	psessionEntry->lim11hEnable = FALSE;
+	psessionEntry->operMode = BSS_OPERATIONAL_MODE_SNIFFER;	/* sniffer mode ?*/
+
+end:
+	limGetSessionInfo(pMac,(tANI_U8*)pMsgBuf,&smesessionId,&smetransactionId);
+
+	printk(KERN_ERR"okkwon smesessionId %u, transactionId %u\n", smesessionId, smetransactionId);
+	printk(KERN_ERR"okkwon sessionid %u\n", sessionId);
+
+	if(pSmeSnifferReq)
+	{
+		vos_mem_free(pSmeSnifferReq);
+		pSmeSnifferReq = NULL;
+		if (NULL != psessionEntry)
+		{
+			psessionEntry->pLimJoinReq = NULL;
+		}
+	}
+
+	if(retCode != eSIR_SME_SUCCESS)
+	{
+		if(NULL != psessionEntry)
+		{
+			peDeleteSession(pMac,psessionEntry);
+			psessionEntry = NULL;
+		}
+	}
+	limLog(pMac, LOG1, FL("Sending failure status limSendSmeJoinReassocRsp"
+				"on sessionid: %d with retCode = %d"),smesessionId, retCode);
+	limSendSmeSnifferRsp(pMac, eWNI_SME_SNIFFER_RSP, retCode, psessionEntry,smesessionId,smetransactionId);
+} /*** end __limProcessSmeJoinReq() ***/
 /**
  * __limProcessSmeJoinReq()
  *
@@ -5959,6 +6072,10 @@
             __limProcessSmeJoinReq(pMac, pMsgBuf);
             break;
 
+		case eWNI_SME_SNIFFER_REQ:
+			__limProcessSmeSnifferReq(pMac, pMsgBuf);
+			break;
+
         case eWNI_SME_AUTH_REQ:
            // __limProcessSmeAuthReq(pMac, pMsgBuf);
 
@@ -6282,16 +6399,25 @@
     tANI_U32 centerChan;
     tANI_U32 chanWidth;
 #endif
+	//int i;
     if( pMsg == NULL )
     {
         limLog(pMac, LOGE,FL("pMsg is NULL"));
         return;
     }
     pChannelChangeReq = (tpSirChanChangeRequest)pMsg;
-
+	/*
+	limLog(pMac, LOGE, FL("%s():bssid=%x:%x:%x:%x:%x:%x\n"),__func__,pChannelChangeReq->bssid[0],pChannelChangeReq->bssid[1],
+		pChannelChangeReq->bssid[2],pChannelChangeReq->bssid[3],pChannelChangeReq->bssid[4],pChannelChangeReq->bssid[5]);
+	 for(i =0; i < pMac->lim.maxBssId; i++)
+    {
+        limLog(pMac, LOGE, FL("%s():gpSession[%d].bssId=%x:%x:%x:%x:%x:%x\n"),__func__,i,pMac->lim.gpSession[i].bssId[0],
+				pMac->lim.gpSession[i].bssId[1],pMac->lim.gpSession[i].bssId[2],pMac->lim.gpSession[i].bssId[3],
+				pMac->lim.gpSession[i].bssId[4],pMac->lim.gpSession[i].bssId[5]);
+    }
+	*/
     if((psessionEntry =
-              peFindSessionByBssid(pMac, pChannelChangeReq->bssid, &sessionId))
-                  == NULL)
+              peFindSessionByBssid(pMac, pChannelChangeReq->bssid, &sessionId)) == NULL)
     {
         limPrintMacAddr(pMac,  pChannelChangeReq->bssid, LOGE);
         PELOGE(limLog(pMac, LOGE,
@@ -6315,7 +6441,8 @@
 
         /* Store the New Channel Params in psessionEntry */
         if (psessionEntry->currentOperChannel !=
-                              pChannelChangeReq->targetChannel)
+                              pChannelChangeReq->targetChannel ||
+							  psessionEntry->pePersona == VOS_SNIFFER_MODE)
         {
             limLog(pMac, LOGW,FL("switch old chnl %d --> new chnl %d "),
                                  psessionEntry->currentOperChannel,
diff -Nuar qcacld-new-clean/CORE/MAC/src/pe/lim/limSendMessages.c qcacld-new/CORE/MAC/src/pe/lim/limSendMessages.c
--- qcacld-new-clean/CORE/MAC/src/pe/lim/limSendMessages.c
+++ qcacld-new/CORE/MAC/src/pe/lim/limSendMessages.c
@@ -248,6 +248,7 @@
     }
     vos_mem_set((tANI_U8 *) pChnlParams, sizeof(tSwitchChannelParams), 0);
     pChnlParams->secondaryChannelOffset = secondaryChnlOffset;
+	printk(KERN_ERR"okkwon %s : seconchan %d\n", __func__, secondaryChnlOffset);
     pChnlParams->channelNumber= chnlNumber;
     vos_mem_copy( pChnlParams->selfStaMacAddr, pSessionEntry->selfMacAddr, sizeof(tSirMacAddr) );
 #if defined WLAN_FEATURE_VOWIFI
diff -Nuar qcacld-new-clean/CORE/MAC/src/pe/lim/limSendSmeRspMessages.c qcacld-new/CORE/MAC/src/pe/lim/limSendSmeRspMessages.c
--- qcacld-new-clean/CORE/MAC/src/pe/lim/limSendSmeRspMessages.c
+++ qcacld-new/CORE/MAC/src/pe/lim/limSendSmeRspMessages.c
@@ -233,6 +233,48 @@
     limSysProcessMmhMsgApi(pMac, &mmhMsg,  ePROT);
 } /*** end limSendSmeRsp() ***/
 
+static void limSendSmeSnifferRspInternal( tpAniSirGlobal pMac,
+		eHalStatus status, tANI_U32 *ctx)
+{
+	tSirMsgQ         mmhMsg;
+	tpSirSmeSnifferRsp  pSirSmeSnifferRsp = (tpSirSmeSnifferRsp) ctx;
+
+	mmhMsg.type = pSirSmeSnifferRsp->messageType;
+	mmhMsg.bodyptr = pSirSmeSnifferRsp;
+	mmhMsg.bodyval = 0;
+	MTRACE(macTraceMsgTx(pMac, NO_SESSION, mmhMsg.type));
+	limSysProcessMmhMsgApi(pMac, &mmhMsg,  ePROT);
+}
+
+void
+limSendSmeSnifferRsp(tpAniSirGlobal pMac, tANI_U16 msgType,
+		tSirResultCodes resultCode,
+		tpPESession psessionEntry,tANI_U8 smesessionId,tANI_U16 smetransactionId)
+{
+	tpSirSmeSnifferRsp  pSirSmeSnifferRsp;
+	tANI_U32 rspLen;
+
+	rspLen = sizeof(tSirSmeSnifferRsp);
+
+	pSirSmeSnifferRsp = vos_mem_malloc(rspLen);
+	if ( NULL == pSirSmeSnifferRsp )
+	{
+		/// Buffer not available. Log error
+		limLog(pMac, LOGP, FL("call to AllocateMemory failed for JOIN/REASSOC_RSP"));
+		return;
+	}
+	vos_mem_set((tANI_U8*)pSirSmeSnifferRsp, rspLen, 0);
+
+	if(psessionEntry) {
+		pSirSmeSnifferRsp->messageType = msgType;
+		pSirSmeSnifferRsp->length = (tANI_U16) rspLen;
+		pSirSmeSnifferRsp->statusCode = resultCode;
+		pSirSmeSnifferRsp->sessionId = smesessionId;
+		pSirSmeSnifferRsp->transactionId = smetransactionId;
+	}
+
+	limSendSmeSnifferRspInternal(pMac, eHAL_STATUS_SUCCESS, (tANI_U32*) pSirSmeSnifferRsp );
+}
 
 /**
  * limSendSmeJoinReassocRspAfterResume()
diff -Nuar qcacld-new-clean/CORE/MAC/src/pe/lim/limSendSmeRspMessages.h qcacld-new/CORE/MAC/src/pe/lim/limSendSmeRspMessages.h
--- qcacld-new-clean/CORE/MAC/src/pe/lim/limSendSmeRspMessages.h
+++ qcacld-new/CORE/MAC/src/pe/lim/limSendSmeRspMessages.h
@@ -56,6 +56,7 @@
                        tSirMacAddr, tAniAuthType, tANI_U16,tpPESession,tANI_U8,tANI_U16);
 
 void limSendSmeJoinReassocRsp(tpAniSirGlobal, tANI_U16, tSirResultCodes, tANI_U16,tpPESession,tANI_U8,tANI_U16);
+void limSendSmeSnifferRsp(tpAniSirGlobal, tANI_U16, tSirResultCodes, tpPESession,tANI_U8,tANI_U16);
 void limSendSmeDisassocNtf(tpAniSirGlobal, tSirMacAddr, tSirResultCodes, tANI_U16, tANI_U16,tANI_U8,tANI_U16,tpPESession);
 void limSendSmeDeauthNtf(tpAniSirGlobal, tSirMacAddr, tSirResultCodes, tANI_U16, tANI_U16, tANI_U8, tANI_U16);
 void limSendSmeDisassocInd(tpAniSirGlobal, tpDphHashNode,tpPESession);
diff -Nuar qcacld-new-clean/CORE/MAC/src/pe/lim/limSerDesUtils.c qcacld-new/CORE/MAC/src/pe/lim/limSerDesUtils.c
--- qcacld-new-clean/CORE/MAC/src/pe/lim/limSerDesUtils.c
+++ qcacld-new/CORE/MAC/src/pe/lim/limSerDesUtils.c
@@ -852,7 +852,88 @@
 
 } /*** end limStopBssReqSerDes() ***/
 
+tSirRetStatus
+limSnifferReqSerDes(tpAniSirGlobal pMac, tpSirSmeSnifferReq pSnifferReq, tANI_U8 *pBuf)
+{
+	tANI_S16 len = 0;
 
+	if (!pSnifferReq || !pBuf)
+	{
+		PELOGE(limLog(pMac, LOGE, FL("pSnifferReq or pBuf is NULL"));)
+			return eSIR_FAILURE;
+	}
+
+	pSnifferReq->messageType = limGetU16(pBuf);
+	pBuf += sizeof(tANI_U16);
+
+	len = pSnifferReq->length = limGetU16(pBuf);
+	pBuf += sizeof(tANI_U16);
+
+	len -= sizeof(tANI_U32);
+	if (limCheckRemainingLength(pMac, len) == eSIR_FAILURE)
+	{
+		limLog(pMac, LOGE, FL("remaining len %d is too short"), len);
+		return eSIR_FAILURE;
+	}
+
+	/* extrace sessionId */
+	pSnifferReq->sessionId = *pBuf++;
+	len--;
+	if (limCheckRemainingLength(pMac, len) == eSIR_FAILURE)
+	{
+		limLog(pMac, LOGE, FL("remaining len %d is too short"), len);
+		return eSIR_FAILURE;
+	}
+
+	/* extract transactionId */
+	pSnifferReq->transactionId = limGetU16(pBuf);
+	pBuf += sizeof(tANI_U16);
+	len  -= sizeof(tANI_U16);
+	if (limCheckRemainingLength(pMac, len) == eSIR_FAILURE)
+	{
+		limLog(pMac, LOGE, FL("remaining len %d is too short"), len);
+		return eSIR_FAILURE;
+	}
+	
+	/* extract selfMacAddr */
+	vos_mem_copy( pSnifferReq->selfMacAddr, pBuf, sizeof(tSirMacAddr));
+	pBuf += sizeof(tSirMacAddr);
+	len -= sizeof(tSirMacAddr);
+	if (limCheckRemainingLength(pMac, len) == eSIR_FAILURE)
+	{
+		limLog(pMac, LOGE, FL("remaining len %d is too short"), len);
+		return eSIR_FAILURE;
+	}
+
+	/* extract dot11mode */
+	pSnifferReq->dot11mode= *pBuf++;
+	len--;
+	if (limCheckRemainingLength(pMac, len) == eSIR_FAILURE)
+	{
+		limLog(pMac, LOGE, FL("remaining len %d is too short"), len);
+		return eSIR_FAILURE;
+	}
+
+	/* bsspersona */
+	pSnifferReq->staPersona = *pBuf++;
+	len--;
+	if (limCheckRemainingLength(pMac, len) == eSIR_FAILURE)
+	{
+		limLog(pMac, LOGE, FL("remaining len %d is too short"), len);
+		return eSIR_FAILURE;
+	}
+
+	/* cbmode */
+	pSnifferReq->cbMode = *pBuf++;
+	len--;
+	if (limCheckRemainingLength(pMac, len) == eSIR_FAILURE)
+	{
+		limLog(pMac, LOGE, FL("remaining len %d is too short"), len);
+		return eSIR_FAILURE;
+	}
+
+	return eSIR_SUCCESS;
+}
 
 /**
  * limJoinReqSerDes()
diff -Nuar qcacld-new-clean/CORE/MAC/src/pe/lim/limSerDesUtils.h qcacld-new/CORE/MAC/src/pe/lim/limSerDesUtils.h
--- qcacld-new-clean/CORE/MAC/src/pe/lim/limSerDesUtils.h
+++ qcacld-new/CORE/MAC/src/pe/lim/limSerDesUtils.h
@@ -49,6 +49,7 @@
 tSirRetStatus   limStartBssReqSerDes(tpAniSirGlobal, tpSirSmeStartBssReq, tANI_U8 *);
 tSirRetStatus   limStopBssReqSerDes(tpAniSirGlobal, tpSirSmeStopBssReq, tANI_U8 *);
 tSirRetStatus   limJoinReqSerDes(tpAniSirGlobal, tpSirSmeJoinReq, tANI_U8 *);
+tSirRetStatus   limSnifferReqSerDes(tpAniSirGlobal, tpSirSmeSnifferReq, tANI_U8 *);
 void            limAssocIndSerDes(tpAniSirGlobal, tpLimMlmAssocInd, tANI_U8 *, tpPESession);
 void            limReassocIndSerDes(tpAniSirGlobal, tpLimMlmReassocInd, tANI_U8 *, tpPESession psessionEntry);
 tSirRetStatus   limAssocCnfSerDes(tpAniSirGlobal, tpSirSmeAssocCnf, tANI_U8 *);
diff -Nuar qcacld-new-clean/CORE/MAC/src/pe/lim/limSession.c qcacld-new/CORE/MAC/src/pe/lim/limSession.c
--- qcacld-new-clean/CORE/MAC/src/pe/lim/limSession.c
+++ qcacld-new/CORE/MAC/src/pe/lim/limSession.c
@@ -436,14 +436,14 @@
     for(i =0; i < pMac->lim.maxBssId; i++)
     {
         /* If BSSID matches return corresponding tables address*/
-        if( (pMac->lim.gpSession[i].valid) && (sirCompareMacAddr(pMac->lim.gpSession[i].bssId, bssid)))
+		if( (pMac->lim.gpSession[i].valid) && (sirCompareMacAddr(pMac->lim.gpSession[i].bssId, bssid)))
         {
             *sessionId = i;
+			//limLog(pMac, LOGE, FL("%s():SessionId=%d\n"),__func__,i);
             return(&pMac->lim.gpSession[i]);
         }
     }
-
-    limLog(pMac, LOG4, FL("Session lookup fails for BSSID: \n "));
+	limLog(pMac, LOG4, FL("Session lookup fails for BSSID: \n "));
     limPrintMacAddr(pMac, bssid, LOG4);
     return(NULL);
 
diff -Nuar qcacld-new-clean/CORE/SERVICES/COMMON/_ieee80211_common.h qcacld-new/CORE/SERVICES/COMMON/_ieee80211_common.h
--- qcacld-new-clean/CORE/SERVICES/COMMON/_ieee80211_common.h
+++ qcacld-new/CORE/SERVICES/COMMON/_ieee80211_common.h
@@ -184,6 +184,8 @@
 
 #define IEEE80211_2GCSA_TBTTCOUNT        3
 
+/* okkwon add for test */
+#ifndef IEEE80211_CHAN_TURBO
 /* bits 0-3 are for private use by drivers */
 /* channel attributes */
 #define IEEE80211_CHAN_TURBO            0x00000010 /* Turbo channel */
@@ -198,6 +200,9 @@
 #define IEEE80211_CHAN_STURBO           0x00002000 /* 11a static turbo channel only */
 #define IEEE80211_CHAN_HALF             0x00004000 /* Half rate channel */
 #define IEEE80211_CHAN_QUARTER          0x00008000 /* Quarter rate channel */
+#endif
+/* okkwon add for test */
+
 #define IEEE80211_CHAN_HT20             0x00010000 /* HT 20 channel */
 #define IEEE80211_CHAN_HT40PLUS         0x00020000 /* HT 40 with extension channel above */
 #define IEEE80211_CHAN_HT40MINUS        0x00040000 /* HT 40 with extension channel below */
diff -Nuar qcacld-new-clean/CORE/SERVICES/COMMON/ieee80211_common.h qcacld-new/CORE/SERVICES/COMMON/ieee80211_common.h
--- qcacld-new-clean/CORE/SERVICES/COMMON/ieee80211_common.h
+++ qcacld-new/CORE/SERVICES/COMMON/ieee80211_common.h
@@ -70,6 +70,17 @@
 #define IEEE80211_PLCP_SERVICE  0x00
 
 /*
+ * generic definitions for IEEE 802.11 control frames
+ */
+struct ieee80211_control_frame {
+    u_int8_t    i_fc[2];
+    u_int8_t    i_dur[2];
+	u_int8_t    i_addr1[IEEE80211_ADDR_LEN];
+    u_int8_t    i_seq[2];
+} __packed;
+
+
+/*
  * generic definitions for IEEE 802.11 frames
  */
 struct ieee80211_frame {
diff -Nuar qcacld-new-clean/CORE/SERVICES/COMMON/ol_htt_api.h qcacld-new/CORE/SERVICES/COMMON/ol_htt_api.h
--- qcacld-new-clean/CORE/SERVICES/COMMON/ol_htt_api.h
+++ qcacld-new/CORE/SERVICES/COMMON/ol_htt_api.h
@@ -107,6 +107,9 @@
    htt_op_mode_monitor,
 };
 
+void htt_pdev_set_sniffer_channel(htt_pdev_handle htt_pdev,
+		unsigned char channel, int freq);
+
 #ifdef QCA_WIFI_ISOC
 /**
  * @brief Notify HTT of a new virtual device, and specify the operating mode
diff -Nuar qcacld-new-clean/CORE/SERVICES/COMMON/ol_htt_rx_api.h qcacld-new/CORE/SERVICES/COMMON/ol_htt_rx_api.h
--- qcacld-new-clean/CORE/SERVICES/COMMON/ol_htt_rx_api.h
+++ qcacld-new/CORE/SERVICES/COMMON/ol_htt_rx_api.h
@@ -553,6 +553,13 @@
     void *mpdu_desc,
     u_int8_t *key_id);
 
+extern int
+(*htt_rx_sniffer_amsdu_pop)(
+    htt_pdev_handle pdev,
+    adf_nbuf_t rx_ind_msg,
+    adf_nbuf_t *head_msdu,
+    adf_nbuf_t *tail_msdu);
+
 /*====================== rx MSDU + descriptor delivery ======================*/
 
 /**
diff -Nuar qcacld-new-clean/CORE/SERVICES/COMMON/ol_txrx_ctrl_api.h qcacld-new/CORE/SERVICES/COMMON/ol_txrx_ctrl_api.h
--- qcacld-new-clean/CORE/SERVICES/COMMON/ol_txrx_ctrl_api.h
+++ qcacld-new/CORE/SERVICES/COMMON/ol_txrx_ctrl_api.h
@@ -104,6 +104,8 @@
 A_STATUS
 ol_txrx_pdev_attach_target(ol_txrx_pdev_handle data_pdev);
 
+void ol_txrx_pdev_set_sniffer_channel(ol_txrx_pdev_handle data_pdev,
+		unsigned char channel, int freq);
 
 /**
  * @brief Allocate and initialize the data object for a new virtual device.
diff -Nuar qcacld-new-clean/CORE/SERVICES/COMMON/osdep_adf.h qcacld-new/CORE/SERVICES/COMMON/osdep_adf.h
--- qcacld-new-clean/CORE/SERVICES/COMMON/osdep_adf.h
+++ qcacld-new/CORE/SERVICES/COMMON/osdep_adf.h
@@ -198,7 +198,7 @@
 #define IPV6_PRIORITY_MASK          0x0FF00000
 #endif
 #ifndef IPV6_FLOWLABEL_MASK
-#define IPV6_FLOWLABEL_MASK         0x000FFFFF
+//#define IPV6_FLOWLABEL_MASK         0x000FFFFF
 #endif
 #ifndef IPV6_VERSION_SHIFT
 #define IPV6_VERSION_SHIFT          28
diff -Nuar qcacld-new-clean/CORE/SERVICES/COMMON/wmi_tlv_defs.h qcacld-new/CORE/SERVICES/COMMON/wmi_tlv_defs.h
--- qcacld-new-clean/CORE/SERVICES/COMMON/wmi_tlv_defs.h
+++ qcacld-new/CORE/SERVICES/COMMON/wmi_tlv_defs.h
@@ -527,6 +527,7 @@
     WMITLV_TAG_STRUC_wmi_sap_ofl_del_sta_event_fixed_param,
     WMITLV_TAG_STRUC_wmi_apfind_cmd_param,
     WMITLV_TAG_STRUC_wmi_apfind_event_hdr,
+    WMITLV_TAG_STRUC_wmi_filter_type_cmd_param = 560
 } WMITLV_TAG_ID;
 
 /*
@@ -726,7 +727,8 @@
     OP(WMI_MDNS_GET_STATS_CMDID) \
     OP(WMI_SET_ANTENNA_DIVERSITY_CMDID) \
     OP(WMI_SAP_OFL_ENABLE_CMDID) \
-    OP(WMI_APFIND_CMDID)
+    OP(WMI_APFIND_CMDID) \
+    OP(WMI_FILTER_TYPE_CMDID)
 
 
 
@@ -2025,6 +2027,12 @@
     WMITLV_ELEM(id,op,buf,len, WMITLV_TAG_ARRAY_BYTE, A_UINT8, data, WMITLV_SIZE_VAR)
 WMITLV_CREATE_PARAM_STRUC(WMI_APFIND_CMDID);
 
+/* Set filter type parameter Cmd */
+#define WMITLV_TABLE_WMI_FILTER_TYPE_CMDID(id,op,buf,len) \
+    WMITLV_ELEM(id,op,buf,len, WMITLV_TAG_STRUC_wmi_filter_type_cmd_param, wmi_filter_type_cmd_param, fixed_param, WMITLV_SIZE_FIX)
+WMITLV_CREATE_PARAM_STRUC(WMI_FILTER_TYPE_CMDID);
+
+
 /************************** TLV definitions of WMI events *******************************/
 
 /* Service Ready event */
diff -Nuar qcacld-new-clean/CORE/SERVICES/COMMON/wmi_unified.h qcacld-new/CORE/SERVICES/COMMON/wmi_unified.h
--- qcacld-new-clean/CORE/SERVICES/COMMON/wmi_unified.h
+++ qcacld-new/CORE/SERVICES/COMMON/wmi_unified.h
@@ -179,6 +179,7 @@
     WMI_GRP_IPA,
     WMI_GRP_MDNS_OFL,
     WMI_GRP_SAP_OFL,
+    WMI_GRP_PROTOTYPE = 0X38,
 } WMI_GRP_ID;
 
 #define WMI_CMD_GRP_START_ID(grp_id) (((grp_id) << 12) | 0x1)
@@ -707,6 +708,7 @@
 
     /* enable/disable AP Authentication offload */
     WMI_SAP_OFL_ENABLE_CMDID = WMI_CMD_GRP_START_ID(WMI_GRP_SAP_OFL),
+    WMI_FILTER_TYPE_CMDID = WMI_CMD_GRP_START_ID(WMI_GRP_PROTOTYPE) + 0X04,
 
 } WMI_CMD_ID;
 
@@ -9217,6 +9219,26 @@
      */
 } wmi_apfind_event_hdr;
 
+typedef struct {
+    A_UINT32 tlv_header; /** TLV tag and len; tag equals WMITLV_TAG_STRUC_wmi_apfind_cmd_param */
+    A_UINT32 data_len; /** length in byte of data[]. */
+    /** This structure is used to send REQ binary blobs
+     * from application/service to firmware where Host drv is pass through .
+     * Following this structure is the TLV:
+     *     A_UINT8 data[];    // length in byte given by field data_len.
+     */
+     A_UINT8 data[]; 
+} wmi_enable_monitor_cmd_param;
+
+typedef struct {
+    A_UINT32 tlv_header;
+    A_UINT32 vdev_id;
+    A_UINT32 clear_or_set;
+    A_UINT32 configure_type;
+    A_UINT8  reserved[6];
+} wmi_filter_type_cmd_param;
+
+
 #ifdef __cplusplus
 }
 #endif
diff -Nuar qcacld-new-clean/CORE/SERVICES/HIF/USB/if_usb.c qcacld-new/CORE/SERVICES/HIF/USB/if_usb.c
--- qcacld-new-clean/CORE/SERVICES/HIF/USB/if_usb.c
+++ qcacld-new/CORE/SERVICES/HIF/USB/if_usb.c
@@ -358,6 +358,11 @@
 
 	printk("Enter:%s,Line:%d\n", __func__,__LINE__);
 
+	if (hdd_get_conparam() == VOS_SNIFFER_MODE) {
+		printk(KERN_ERR"okkwon : prevent suspend\n");
+		return (-1);
+	}
+
 	temp_module = vos_get_context(VOS_MODULE_ID_WDA, vos);
 	if (!temp_module) {
 		printk("%s: WDA module is NULL\n", __func__);
diff -Nuar qcacld-new-clean/CORE/SERVICES/WMA/wma.c qcacld-new/CORE/SERVICES/WMA/wma.c
--- qcacld-new-clean/CORE/SERVICES/WMA/wma.c
+++ qcacld-new/CORE/SERVICES/WMA/wma.c
@@ -668,7 +668,20 @@
 				wma->interfaces[resp_event->vdev_id].vdev_up =
 									TRUE;
 			}
-                }
+		}
+		else if (iface->type == WMI_VDEV_TYPE_MONITOR) {
+			if (wmi_unified_vdev_up_send(wma->wmi_handle,
+						resp_event->vdev_id, 0,
+						iface->addr)) {
+				WMA_LOGE("%s:vdev_up failed vdev_id %d",
+						__func__, resp_event->vdev_id);
+				wma->interfaces[resp_event->vdev_id].vdev_up =
+					FALSE;
+			} else {
+				wma->interfaces[resp_event->vdev_id].vdev_up =
+					TRUE;
+			}
+		}
 
 		wma_send_msg(wma, WDA_SWITCH_CHANNEL_RSP, (void *)params, 0);
 	} else if (req_msg->msg_type == WDA_ADD_BSS_REQ) {
@@ -4997,6 +5010,8 @@
                         break;
 #endif
 		case WMI_VDEV_TYPE_MONITOR:
+        	vdev_type = wlan_op_mode_monitor;
+            break;
 		default:
 			WMA_LOGE("Invalid vdev type %u", type);
 			vdev_type = wlan_op_mode_unknown;
@@ -5033,10 +5048,10 @@
 	cmd->vdev_type = type;
 	cmd->vdev_subtype = subtype;
 	WMI_CHAR_ARRAY_TO_MAC_ADDR(macaddr, &cmd->vdev_macaddr);
-	WMA_LOGE("%s: ID = %d VAP Addr = %02x:%02x:%02x:%02x:%02x:%02x",
+	WMA_LOGE("%s: ID = %d VAP Addr = %02x:%02x:%02x:%02x:%02x:%02x type = %d",
 		 __func__, if_id,
 		 macaddr[0], macaddr[1], macaddr[2],
-		 macaddr[3], macaddr[4], macaddr[5]);
+		 macaddr[3], macaddr[4], macaddr[5], type);
 	ret = wmi_unified_cmd_send(wmi_handle, buf, len, WMI_VDEV_CREATE_CMDID);
 	if (ret != EOK) {
 		WMA_LOGE("Failed to send WMI_VDEV_CREATE_CMDID");
@@ -5135,8 +5150,9 @@
 	struct wma_txrx_node *iface = &wma_handle->interfaces[vdev_id];
 	struct wma_target_req *msg;
 
-	if ((iface->type == WMI_VDEV_TYPE_AP) &&
-	    (iface->sub_type == WMI_UNIFIED_VDEV_SUBTYPE_P2P_DEVICE)) {
+	if (((iface->type == WMI_VDEV_TYPE_AP) &&
+	    (iface->sub_type == WMI_UNIFIED_VDEV_SUBTYPE_P2P_DEVICE)) ||
+			(iface->type == WMI_VDEV_TYPE_MONITOR)) {
 
 		WMA_LOGA("P2P Device: removing self peer %pM",
 				pdel_sta_self_req_param->selfMacAddr);
@@ -5264,6 +5280,9 @@
 {
 	ol_txrx_peer_handle peer;
 
+	printk(KERN_ERR"okkwon peer mac : "MAC_ADDRESS_STR"\n",
+			MAC_ADDR_ARRAY(peer_addr));
+
 	if (++wma->peer_count > wma->wlan_resource_config.num_peers) {
 		WMA_LOGP("%s, the peer count exceeds the limit %d",
 			 __func__, wma->peer_count - 1);
@@ -5835,10 +5854,10 @@
 	adf_os_atomic_init(&wma_handle->interfaces
 			   [self_sta_req->sessionId].bss_status);
 
-	if ((self_sta_req->type == WMI_VDEV_TYPE_AP) &&
+	if (((self_sta_req->type == WMI_VDEV_TYPE_AP) &&
 			(self_sta_req->subType ==
-			 WMI_UNIFIED_VDEV_SUBTYPE_P2P_DEVICE)) {
-		WMA_LOGA("P2P Device: creating self peer %pM, vdev_id %hu",
+			 WMI_UNIFIED_VDEV_SUBTYPE_P2P_DEVICE))) {
+		WMA_LOGA("P2P or sniffer Device: creating self peer %pM, vdev_id %hu",
 				self_sta_req->selfMacAddr,
 				self_sta_req->sessionId);
 		status = wma_create_peer(wma_handle, txrx_pdev,
@@ -5853,6 +5872,12 @@
 		}
 	}
 
+	/* add dummy peer for sniffer -_-;; */
+	if (self_sta_req->type == WMI_VDEV_TYPE_MONITOR) {
+		ol_txrx_peer_attach(txrx_pdev, txrx_vdev_handle,
+				self_sta_req->selfMacAddr);
+	}
+
 	if (wlan_cfgGetInt(mac, WNI_CFG_RTS_THRESHOLD,
 			&cfg_val) == eSIR_SUCCESS) {
 		ret = wmi_unified_vdev_set_param_send(wma_handle->wmi_handle,
@@ -8775,6 +8800,8 @@
 	WLAN_PHY_MODE chanmode;
 	u_int8_t *buf_ptr;
 	struct wma_txrx_node *intr = wma->interfaces;
+	ol_txrx_pdev_handle txrx_pdev = vos_get_context(VOS_MODULE_ID_TXRX,
+						wma->vos_context);
 
 	WMA_LOGD("%s: Enter isRestart=%d vdev=%d", __func__, isRestart,req->vdev_id);
 	len = sizeof(*cmd) + sizeof(wmi_channel) +
@@ -8817,6 +8844,9 @@
 	WMI_SET_CHANNEL_MODE(chan, chanmode);
 	chan->band_center_freq1 = chan->mhz;
 
+	/* set monitor channel */
+	ol_txrx_pdev_set_sniffer_channel(txrx_pdev, req->chan, chan->band_center_freq1);
+
 	if (chanmode == MODE_11AC_VHT80)
 		chan->band_center_freq1 = vos_chan_to_freq(wma_getCenterChannel
 			(req->chan, req->chan_offset));
@@ -9475,6 +9505,8 @@
 	req.chan = params->channelNumber;
 	req.chan_offset = params->secondaryChannelOffset;
 	req.vht_capable = params->vhtCapable;
+	printk(KERN_ERR"okkwon : chan %u, offset %u, mode %u\n",
+			req.chan, req.chan_offset, req.oper_mode);
 #ifdef WLAN_FEATURE_VOWIFI
 	req.max_txpow = params->maxTxPower;
 #else
@@ -9488,8 +9520,9 @@
 	 * issuse VDEV RESTART, so we making is_channel_switch as
 	 * TRUE
 	 */
-	if((wma->interfaces[req.vdev_id].type == WMI_VDEV_TYPE_AP ) &&
-			(wma->interfaces[req.vdev_id].sub_type == 0))
+	if(((wma->interfaces[req.vdev_id].type == WMI_VDEV_TYPE_AP ) &&
+			(wma->interfaces[req.vdev_id].sub_type == 0)) ||
+			wma->interfaces[req.vdev_id].type == WMI_VDEV_TYPE_MONITOR)
 		wma->interfaces[req.vdev_id].is_channel_switch = VOS_TRUE;
 
 	status = wma_vdev_start(wma, &req,
@@ -17397,6 +17430,116 @@
 }
 #endif /* WLAN_FEATURE_APFIND */
 
+/**
+ * wma_enable_monitor_cmd() - enable monitor mode to firmware
+ * @wda_handle: pointer to wma handle.
+ * @enable_monitor_req: pointer to enable/disable monitor mode request.
+ *
+ * This is called to enable monitor mode to firmware via WMI command.
+ *
+ * Return: VOS_STATUS.
+ */
+	VOS_STATUS wma_enable_monitor_cmd(tp_wma_handle wma_handle,
+					struct hal_enable_monitor_request *enable_monitor_req)
+	{
+		wmi_enable_monitor_cmd_param *cmd;
+		//int status = 0;
+		wmi_buf_t buf;
+		u_int8_t *buf_ptr;
+		int32_t len = sizeof(wmi_enable_monitor_cmd_param);
+
+		if (!wma_handle || !wma_handle->wmi_handle) {
+			WMA_LOGE(FL("WMA is closed, can not issue cmd"));
+			return VOS_STATUS_E_INVAL;
+		}
+
+		buf = wmi_buf_alloc(wma_handle->wmi_handle, len);
+		if (!buf) {
+			WMA_LOGP(FL("wmi_buf_alloc failed"));
+			return -ENOMEM;
+		}
+		buf_ptr = (u_int8_t *) wmi_buf_data(buf);
+		cmd = (wmi_enable_monitor_cmd_param *) buf_ptr;
+		cmd->data_len = enable_monitor_req->request_data_len;
+		WMA_LOGD("%s: The data len value is %u",__func__, enable_monitor_req->request_data_len);
+		if (cmd->data_len) {
+			vos_mem_copy(cmd->data,
+                enable_monitor_req->request_data, cmd->data_len);
+		}
+
+		WMA_LOGE("%s:wda process enable/disable=0x%x monitor request.",__func__,cmd->data[0]);
+		if (cmd->data[0] == 0){
+			WMA_LOGE("%s:prepare to suspend monitor mode.",__func__);
+			if (wma_suspend_target(wma_handle, 0)){
+				WMA_LOGE("%s:fail to suspend monitor mode.",__func__);
+				return VOS_STATUS_E_FAILURE;
+			}
+		}
+		else{
+			WMA_LOGE("%s:prepare to resume monitor mode.",__func__);
+			if(wma_resume_target( wma_handle)){
+				WMA_LOGE("%s:fail to resume monitor mode.",__func__);
+				return VOS_STATUS_E_FAILURE;
+			}
+		}
+		return VOS_STATUS_SUCCESS;
+	}
+
+/**
+ * wma_filter_type_cmd() - set filter packet type to firmware in monitor mode.
+ * @wda_handle: pointer to wma handle.
+ * @enable_monitor_req: pointer to filter type request.
+ *
+ * This is called to filter type to firmware via WMI command.
+ *
+ * Return: VOS_STATUS.
+ */
+	VOS_STATUS wma_filter_type_cmd(tp_wma_handle wma_handle,
+					struct hal_filter_type_request *filter_type_req)
+	{
+		wmi_filter_type_cmd_param *cmd;
+		int status = 0;
+		wmi_buf_t buf;
+		u_int8_t *buf_ptr;
+		int32_t len = sizeof(wmi_filter_type_cmd_param);
+	
+		if (!wma_handle || !wma_handle->wmi_handle) {
+			WMA_LOGE(FL("WMA is closed, can not issue cmd"));
+			return VOS_STATUS_E_INVAL;
+		}
+
+		buf = wmi_buf_alloc(wma_handle->wmi_handle, len);
+		if (!buf) {
+			WMA_LOGP(FL("wmi_buf_alloc failed"));
+			return -ENOMEM;
+		}
+		buf_ptr = (u_int8_t *) wmi_buf_data(buf);
+		cmd = (wmi_filter_type_cmd_param *) buf_ptr;
+		WMITLV_SET_HDR(&cmd->tlv_header,
+				WMITLV_TAG_STRUC_wmi_filter_type_cmd_param,
+				WMITLV_GET_STRUCT_TLVLEN(
+				wmi_filter_type_cmd_param));
+		cmd->vdev_id = filter_type_req->vdev_id;
+		WMA_LOGD("%s: The vdev_id %u",__func__, filter_type_req->vdev_id);
+		WMA_LOGD("%s: The data len value is %u",__func__, filter_type_req->request_data_len);
+		if (filter_type_req->request_data_len) {
+			vos_mem_copy(&(cmd->configure_type),
+                filter_type_req->request_data, filter_type_req->request_data_len);
+		}
+		WMA_LOGE("%s: The filter type=0x%x request.",__func__,cmd->configure_type);
+		WMA_LOGE("%s: WMITLV_TAG_STRUC_wmi_filter_type_cmd_param=%d .",__func__,WMITLV_TAG_STRUC_wmi_filter_type_cmd_param);
+		WMA_LOGE("%s: WMI_FILTER_TYPE_CMDID=%d .",__func__,WMI_FILTER_TYPE_CMDID);
+		status = wmi_unified_cmd_send(wma_handle->wmi_handle, buf, len,
+						WMI_FILTER_TYPE_CMDID);
+		if (status != EOK) {
+			WMA_LOGE("%s: wmi_unified_cmd_send WMI_FILTER_TYPE_CMDID"
+				" returned Error %d",
+				__func__, status);
+			return VOS_STATUS_E_FAILURE;
+		}
+		return VOS_STATUS_SUCCESS;
+	}
+
 tAniGetPEStatsRsp * wma_get_stats_rsp_buf(tAniGetPEStatsReq *get_stats_param)
 {
 	tAniGetPEStatsRsp *stats_rsp_params;
@@ -21733,6 +21876,16 @@
 			vos_mem_free(msg->bodyptr);
 			break;
 #endif /* WLAN_FEATURE_APFIND */
+		case WDA_ENABLE_MONITOR_CMD:
+			wma_enable_monitor_cmd(wma_handle,
+				(struct hal_enable_monitor_request*)msg->bodyptr);
+			vos_mem_free(msg->bodyptr);
+			break;
+		case WDA_FILTER_TYPE_CMD:
+			wma_filter_type_cmd(wma_handle,
+				(struct hal_filter_type_request*)msg->bodyptr);
+			vos_mem_free(msg->bodyptr);
+			break;
 		default:
 			WMA_LOGD("unknow msg type %x", msg->type);
 			/* Do Nothing? MSG Body should be freed at here */
diff -Nuar qcacld-new-clean/CORE/SERVICES/WMI/wmi_tlv_helper.c qcacld-new/CORE/SERVICES/WMI/wmi_tlv_helper.c
--- qcacld-new-clean/CORE/SERVICES/WMI/wmi_tlv_helper.c
+++ qcacld-new/CORE/SERVICES/WMI/wmi_tlv_helper.c
@@ -649,8 +649,10 @@
             /* Warning: some parameter truncation */
             if (tlv_size_diff > 0)
             {
+				/*
                 wmi_tlv_print_error("%s: WARN: TLV truncated. tlv_size_diff=%d, curr_tlv_len=%d\n",
                        __func__, tlv_size_diff, curr_tlv_len);
+				*/
             }
             /* TODO: this next line needs more comments and explanation */
             cmd_param_tlvs_ptr[tlv_index].tlv_ptr = (attr_struct_ptr.tag_varied_size && !curr_tlv_len)?NULL:(void *)buf_ptr;
diff -Nuar qcacld-new-clean/CORE/SERVICES/WMI/wmi_unified.c qcacld-new/CORE/SERVICES/WMI/wmi_unified.c
--- qcacld-new-clean/CORE/SERVICES/WMI/wmi_unified.c
+++ qcacld-new/CORE/SERVICES/WMI/wmi_unified.c
@@ -583,6 +583,7 @@
 		CASE_RETURN_STRING(WMI_SET_ANTENNA_DIVERSITY_CMDID);
 		CASE_RETURN_STRING(WMI_SAP_OFL_ENABLE_CMDID);
 		CASE_RETURN_STRING(WMI_APFIND_CMDID);
+		CASE_RETURN_STRING(WMI_FILTER_TYPE_CMDID);
 	}
 	return "Invalid WMI cmd";
 }
diff -Nuar qcacld-new-clean/CORE/SME/inc/sme_Api.h qcacld-new/CORE/SME/inc/sme_Api.h
--- qcacld-new-clean/CORE/SME/inc/sme_Api.h
+++ qcacld-new/CORE/SME/inc/sme_Api.h
@@ -229,6 +229,17 @@
 };
 #endif /* WLAN_FEATURE_APFIND */
 
+struct sme_enable_monitor_req{
+    u_int16_t request_data_len;
+    u_int8_t* request_data;
+};
+
+struct sme_filter_type_req{
+	u_int32_t vdev_id;
+    u_int16_t request_data_len;
+    u_int8_t* request_data;
+};
+
 /*-------------------------------------------------------------------------
   Function declarations and documenation
   ------------------------------------------------------------------------*/
@@ -362,6 +373,11 @@
                            tANI_U8 *pbSessionId, tANI_U32 type,
                            tANI_U32 subType);
 
+eHalStatus sme_OpenSnifferSession(tHalHandle hHal, csrRoamCompleteCallback callback,
+                           void *pContext, tANI_U8 *pSelfMacAddr,
+                           tANI_U8 *pbSessionId, tANI_U32 type,
+                           tANI_U32 subType);
+
 /*--------------------------------------------------------------------------
 
   \brief sme_SetCurrDeviceMode() - Sets the current operating device mode.
@@ -564,6 +580,8 @@
 
 v_VOID_t sme_FreeMsg( tHalHandle hHal, vos_msg_t* pMsg );
 
+eHalStatus sme_StartSniffer(tHalHandle hHal, tANI_U8 sessionId);
+
 /* ---------------------------------------------------------------------------
     \fn sme_ScanRequest
     \brief a wrapper function to Request a 11d or full scan from CSR.
@@ -693,7 +711,7 @@
 eHalStatus sme_RoamRegisterLinkQualityIndCallback(tHalHandle hHal, tANI_U8 sessionId,
                                                   csrRoamLinkQualityIndCallback   callback,
                                                   void                           *pContext);
-
+eHalStatus sme_RoamIssueSniffer(tHalHandle hHal, tANI_U8 sessionId);
 
 /* ---------------------------------------------------------------------------
     \fn sme_RoamConnect
@@ -4042,5 +4060,6 @@
 #ifdef WLAN_FEATURE_APFIND
 VOS_STATUS sme_apfind_set_cmd(struct sme_ap_find_request_req *input);
 #endif /* WLAN_FEATURE_APFIND */
-
+VOS_STATUS sme_enable_monitor_cmd(struct sme_enable_monitor_req *input);
+VOS_STATUS sme_filter_type_cmd(struct sme_filter_type_req *input);
 #endif //#if !defined( __SME_API_H )
diff -Nuar qcacld-new-clean/CORE/SME/inc/smeInside.h qcacld-new/CORE/SME/inc/smeInside.h
--- qcacld-new-clean/CORE/SME/inc/smeInside.h
+++ qcacld-new/CORE/SME/inc/smeInside.h
@@ -236,6 +236,7 @@
 tANI_BOOLEAN smeCommandPending(tpAniSirGlobal pMac);
 tANI_BOOLEAN pmcProcessCommand( tpAniSirGlobal pMac, tSmeCmd *pCommand );
 tANI_BOOLEAN pmcOffloadProcessCommand(tpAniSirGlobal pMac,tSmeCmd *pCommand);
+tANI_BOOLEAN pmcOffloadIsStaInPowerSave(tpAniSirGlobal pMac, tANI_U32 sessionId);
 
 //this function is used to abort a command where the normal processing of the command
 //is terminated without going through the normal path. it is here to take care of callbacks for
@@ -246,6 +247,7 @@
 
 tANI_BOOLEAN qosProcessCommand( tpAniSirGlobal pMac, tSmeCmd *pCommand );
 
+eHalStatus csrProcessSnifferCommand( tpAniSirGlobal pMac, tSmeCmd *pCommand );
 eHalStatus csrProcessScanCommand( tpAniSirGlobal pMac, tSmeCmd *pCommand );
 eHalStatus csrRoamProcessCommand( tpAniSirGlobal pMac, tSmeCmd *pCommand );
 void csrRoamProcessWmStatusChangeCommand( tpAniSirGlobal pMac, tSmeCmd *pCommand );
diff -Nuar qcacld-new-clean/CORE/SME/inc/smeInternal.h qcacld-new/CORE/SME/inc/smeInternal.h
--- qcacld-new-clean/CORE/SME/inc/smeInternal.h
+++ qcacld-new/CORE/SME/inc/smeInternal.h
@@ -105,6 +105,7 @@
 #endif
     eSmeCommandRemainOnChannel,
     eSmeCommandNoAUpdate,
+	eSmeCommandSniffer,
 } eSmeCommandType;
 
 
diff -Nuar qcacld-new-clean/CORE/SME/src/csr/csrApiRoam.c qcacld-new/CORE/SME/src/csr/csrApiRoam.c
--- qcacld-new-clean/CORE/SME/src/csr/csrApiRoam.c
+++ qcacld-new/CORE/SME/src/csr/csrApiRoam.c
@@ -7696,6 +7696,20 @@
     } /*else: ( eSIR_SME_SUCCESS == pSmeJoinRsp->statusCode ) */
 }
 
+eHalStatus csrRoamIssueSniffer( tpAniSirGlobal pMac, tANI_U32 sessionId)
+{
+	return csrSendSnifferReqMsg(pMac, sessionId, eWNI_SME_SNIFFER_REQ);
+}
+
+eHalStatus csrProcessSnifferCommand( tpAniSirGlobal pMac, tSmeCmd *pCommand )
+{
+	eHalStatus status = eHAL_STATUS_SUCCESS;
+
+	status = csrRoamIssueSniffer(pMac, pCommand->sessionId);
+
+	return status;
+}
+
 eHalStatus csrRoamIssueJoin( tpAniSirGlobal pMac, tANI_U32 sessionId, tSirBssDescription *pSirBssDesc,
                              tDot11fBeaconIEs *pIes,
                              tCsrRoamProfile *pProfile, tANI_U32 roamId )
@@ -12992,6 +13006,63 @@
     pBuf += pBssDescription->length + sizeof( pBssDescription->length );   // update to new location
 }
 
+eHalStatus csrSendSnifferReqMsg(tpAniSirGlobal pMac, tANI_U32 sessionId, tANI_U16 messageType)
+{
+	eHalStatus status = eHAL_STATUS_SUCCESS;
+	tSirSmeSnifferReq *pMsg;
+	tANI_U8 *pBuf;
+	tANI_U16 msgLen;
+	tCsrRoamSession *pSession = CSR_GET_SESSION( pMac, sessionId );
+	tANI_U32 ucDot11Mode = 0;
+
+	if(!pSession)
+	{
+		smsLog(pMac, LOGE, FL("  session %d not found "), sessionId);
+		return eHAL_STATUS_FAILURE;
+	}
+
+	pSession->joinFailStatusCode.statusCode = eSIR_SME_SUCCESS;
+   	pSession->joinFailStatusCode.reasonCode = 0;
+
+	msgLen = sizeof(tSirSmeSnifferReq);
+	pMsg = vos_mem_malloc(msgLen);
+	if (NULL == pMsg)
+		status = eHAL_STATUS_FAILURE;
+	else
+		status = eHAL_STATUS_SUCCESS;
+	if ( !HAL_STATUS_SUCCESS(status) ) return eHAL_STATUS_FAILURE;
+	vos_mem_set(pMsg, msgLen , 0);
+	pMsg->messageType = pal_cpu_to_be16((tANI_U16)messageType);
+	pMsg->length = pal_cpu_to_be16(msgLen);
+	pBuf = &pMsg->sessionId;
+
+	/*sessionid*/
+	*pBuf = (tANI_U8)sessionId;
+	pBuf++;
+	/*transacitonid*/
+	*pBuf = 0;
+	*( pBuf + 1 ) = 0;
+	pBuf += sizeof(tANI_U16);
+	// selfMacAddr
+	vos_mem_copy((tSirMacAddr *)pBuf, &pSession->selfMacAddr,
+			sizeof(tSirMacAddr));
+	pBuf += sizeof(tSirMacAddr);
+	/*dot11mode*/
+	ucDot11Mode = csrTranslateToWNICfgDot11Mode( pMac, pSession->bssParams.uCfgDot11Mode );
+	*pBuf = (tANI_U8)ucDot11Mode;
+	pBuf++;
+	/*persona*/
+	*pBuf = VOS_SNIFFER_MODE;
+	pBuf++;
+	/*cbmode*/
+	*pBuf = (tANI_U8)pSession->bssParams.cbMode;
+	pBuf++;
+
+	status = palSendMBMessage(pMac->hHdd, pMsg);
+
+	return status;
+}
+
 /*
   * The communication between HDD and LIM is thru mailbox (MB).
   * Both sides will access the data structure "tSirSmeJoinReq".
@@ -18175,8 +18246,8 @@
     pMsg->messageLen = sizeof(tSirChanChangeRequest);
     pMsg->targetChannel = targetChannel;
     pMsg->cbMode = cbMode;
+	
     vos_mem_copy(pMsg->bssid, bssid, VOS_MAC_ADDR_SIZE);
-
     status = palSendMBMessage(pMac->hHdd, pMsg);
 
     return ( status );
diff -Nuar qcacld-new-clean/CORE/SME/src/csr/csrApiScan.c qcacld-new/CORE/SME/src/csr/csrApiScan.c
--- qcacld-new-clean/CORE/SME/src/csr/csrApiScan.c
+++ qcacld-new/CORE/SME/src/csr/csrApiScan.c
@@ -6665,7 +6665,6 @@
 eHalStatus csrScanStartResultCfgAgingTimer(tpAniSirGlobal pMac)
 {
     eHalStatus status = eHAL_STATUS_FAILURE;
-
     if(pMac->scan.fScanEnable)
     {
         status = vos_timer_start(&pMac->scan.hTimerResultCfgAging, CSR_SCAN_RESULT_CFG_AGING_INTERVAL/PAL_TIMER_TO_MS_UNIT);
diff -Nuar qcacld-new-clean/CORE/SME/src/csr/csrInsideApi.h qcacld-new/CORE/SME/src/csr/csrInsideApi.h
--- qcacld-new-clean/CORE/SME/src/csr/csrInsideApi.h
+++ qcacld-new/CORE/SME/src/csr/csrInsideApi.h
@@ -306,6 +306,7 @@
 
 eHalStatus csrRoamCallCallback(tpAniSirGlobal pMac, tANI_U32 sessionId, tCsrRoamInfo *pRoamInfo,
                                tANI_U32 roamId, eRoamCmdStatus u1, eCsrRoamResult u2);
+eHalStatus csrRoamIssueSniffer(tpAniSirGlobal pMac, tANI_U32 sessionId);
 eHalStatus csrRoamIssueConnect(tpAniSirGlobal pMac, tANI_U32 sessionId, tCsrRoamProfile *pProfile,
                                tScanResultHandle hBSSList,
                                eCsrRoamReason reason, tANI_U32 roamId,
@@ -341,6 +342,7 @@
 //pCommand may be NULL
 void csrRoamRemoveDuplicateCommand(tpAniSirGlobal pMac, tANI_U32 sessionId, tSmeCmd *pCommand, eCsrRoamReason eRoamReason);
 
+eHalStatus csrSendSnifferReqMsg( tpAniSirGlobal pMac, tANI_U32 sessionId, tANI_U16 messageType);
 eHalStatus csrSendJoinReqMsg( tpAniSirGlobal pMac, tANI_U32 sessionId, tSirBssDescription *pBssDescription,
                               tCsrRoamProfile *pProfile, tDot11fBeaconIEs *pIes, tANI_U16 messageType );
 eHalStatus csrSendMBDisassocReqMsg( tpAniSirGlobal pMac, tANI_U32 sessionId, tSirMacAddr bssId, tANI_U16 reasonCode );
diff -Nuar qcacld-new-clean/CORE/SME/src/sme_common/sme_Api.c qcacld-new/CORE/SME/src/sme_common/sme_Api.c
--- qcacld-new-clean/CORE/SME/src/sme_common/sme_Api.c
+++ qcacld-new/CORE/SME/src/sme_common/sme_Api.c
@@ -894,6 +894,10 @@
                        TRACE_CODE_SME_COMMAND, pCommand->sessionId, pCommand->command));
                     switch ( pCommand->command )
                     {
+						case eSmeCommandSniffer:
+							 csrLLUnlock( &pMac->sme.smeCmdActiveList );
+							 status = csrProcessSnifferCommand( pMac, pCommand );
+							 break;
 
                         case eSmeCommandScan:
                             csrLLUnlock( &pMac->sme.smeCmdActiveList );
@@ -3434,6 +3438,33 @@
     return smeConfig.csrConfig.channelBondingMode5GHz;
 }
 
+eHalStatus sme_StartSniffer(tHalHandle hHal, tANI_U8 sessionId)
+{
+	eHalStatus status = eHAL_STATUS_FAILURE;
+	tpAniSirGlobal pMac = PMAC_STRUCT( hHal );
+
+	if (!pMac)
+	{
+		return eHAL_STATUS_FAILURE;
+	}
+
+	printk(KERN_ERR"okkwon : %s\n", __func__);
+	smsLog(pMac, LOG2, FL("enter"));
+	status = sme_AcquireGlobalLock( &pMac->sme );
+	if ( HAL_STATUS_SUCCESS( status ) )
+	{
+		status = csrRoamIssueSniffer( pMac, sessionId );
+		sme_ReleaseGlobalLock( &pMac->sme );
+	}
+	else
+	{
+		smsLog(pMac, LOGE, FL("sme_AcquireGlobalLock failed"));
+	}
+	printk(KERN_ERR"okkwon : %s exit\n", __func__);
+
+	return (status);
+}
+
 /* ---------------------------------------------------------------------------
     \fn sme_GetChannelBondingMode24G
     \brief get the channel bonding mode for 2.4G band
@@ -12698,6 +12729,8 @@
 
         status = csrRoamChannelChangeReq( pMac, bssid, targetChannel,
                        pMac->roam.configParam.channelBondingMode5GHz );
+		printk(KERN_ERR"okkwon : phymode %d bondingmode %d\n",
+				phyMode,  pMac->roam.configParam.channelBondingMode5GHz);
 
         sme_ReleaseGlobalLock( &pMac->sme );
     }
@@ -14335,3 +14368,87 @@
 }
 #endif /* WLAN_FEATURE_APFIND */
 
+/**
+ * sme_enable_monitor_cmd() - set monitor mode to firmware
+ * @input: pointer to enable monitor request data.
+ *
+ * Return: VOS_STATUS.
+ */
+VOS_STATUS sme_enable_monitor_cmd(struct sme_enable_monitor_req *input)
+{
+     vos_msg_t msg;
+     struct hal_enable_monitor_request *data;
+     size_t data_len;
+
+     data_len = sizeof(struct hal_enable_monitor_request) + input->request_data_len;
+     data = vos_mem_malloc(data_len);
+
+     if (data == NULL) {
+         VOS_TRACE(VOS_MODULE_ID_SME, VOS_TRACE_LEVEL_ERROR,
+                FL("Memory allocation failure"));
+         return VOS_STATUS_E_FAULT;
+     }
+
+     vos_mem_zero(data, data_len);
+     data->request_data_len = input->request_data_len;
+     if (input->request_data_len) {
+         vos_mem_copy(data->request_data,
+                input->request_data, input->request_data_len);
+     }
+     msg.type = WDA_ENABLE_MONITOR_CMD;
+     msg.reserved = 0;
+     msg.bodyptr = data;
+
+    if (VOS_STATUS_SUCCESS != vos_mq_post_message(VOS_MODULE_ID_WDA, &msg)) {
+        VOS_TRACE(VOS_MODULE_ID_SME, VOS_TRACE_LEVEL_ERROR,
+            FL("Not able to post WDA_ENABLE_MONITOR_CMD message to WDA"));
+        vos_mem_free(data);
+        return VOS_STATUS_SUCCESS;
+    }
+
+     return VOS_STATUS_SUCCESS;
+}
+
+
+/**
+ * sme_filter_type_cmd() - set filter packet type to firmware
+ * @input: pointer to filter type request data.
+ *
+ * Return: VOS_STATUS.
+ */
+VOS_STATUS sme_filter_type_cmd(struct sme_filter_type_req *input)
+{
+     vos_msg_t msg;
+     struct hal_filter_type_request *data;
+     size_t data_len;
+
+     data_len = sizeof(struct hal_filter_type_request) + input->request_data_len;
+     data = vos_mem_malloc(data_len);
+
+     if (data == NULL) {
+         VOS_TRACE(VOS_MODULE_ID_SME, VOS_TRACE_LEVEL_ERROR,
+                FL("Memory allocation failure"));
+         return VOS_STATUS_E_FAULT;
+     }
+
+     vos_mem_zero(data, data_len);
+     data->request_data_len = input->request_data_len;
+	 data->vdev_id = input->vdev_id;
+     if (input->request_data_len) {
+         vos_mem_copy(data->request_data,
+                input->request_data, input->request_data_len);
+     }
+
+     msg.type = WDA_FILTER_TYPE_CMD;
+     msg.reserved = 0;
+     msg.bodyptr = data;
+
+    if (VOS_STATUS_SUCCESS != vos_mq_post_message(VOS_MODULE_ID_WDA, &msg)) {
+        VOS_TRACE(VOS_MODULE_ID_SME, VOS_TRACE_LEVEL_ERROR,
+            FL("Not able to post WDA_FILTER_TYPE_CMD message to WDA"));
+        vos_mem_free(data);
+        return VOS_STATUS_SUCCESS;
+    }
+
+     return VOS_STATUS_SUCCESS;
+}
diff -Nuar qcacld-new-clean/CORE/TL/inc/wlan_qct_tl.h qcacld-new/CORE/TL/inc/wlan_qct_tl.h
--- qcacld-new-clean/CORE/TL/inc/wlan_qct_tl.h
+++ qcacld-new/CORE/TL/inc/wlan_qct_tl.h
@@ -175,6 +175,8 @@
   WLAN_STA_TDLS,    /* 4 */
 #endif
 
+  WLAN_STA_SNIFFER,
+
 
   /* Invalid link*/
   WLAN_STA_MAX
diff -Nuar qcacld-new-clean/CORE/VOSS/inc/vos_types.h qcacld-new/CORE/VOSS/inc/vos_types.h
--- qcacld-new-clean/CORE/VOSS/inc/vos_types.h
+++ qcacld-new/CORE/VOSS/inc/vos_types.h
@@ -148,6 +148,7 @@
     VOS_FTM_MODE = 5,
     VOS_IBSS_MODE,
     VOS_P2P_DEVICE_MODE,
+	VOS_SNIFFER_MODE = 8,
     VOS_MAX_NO_OF_MODE
 } tVOS_CON_MODE;
 
diff -Nuar qcacld-new-clean/CORE/VOSS/src/vos_api.c qcacld-new/CORE/VOSS/src/vos_api.c
--- qcacld-new-clean/CORE/VOSS/src/vos_api.c
+++ qcacld-new/CORE/VOSS/src/vos_api.c
@@ -1492,12 +1492,14 @@
     }
     gpVosContext->isLoadUnloadInProgress = value;
 
+#if 0
 #ifdef CONFIG_CNSS
     if (value)
         cnss_set_driver_status(CNSS_LOAD_UNLOAD);
     else
         cnss_set_driver_status(CNSS_INITIALIZED);
 #endif
+#endif
 }
 
 v_U8_t vos_is_reinit_in_progress(VOS_MODULE_ID moduleId, v_VOID_t *moduleContext)
@@ -2606,6 +2608,12 @@
             *type = WMI_VDEV_TYPE_AP;
             *sub_type = WMI_UNIFIED_VDEV_SUBTYPE_P2P_GO;
             break;
+        case VOS_MONITOR_MODE:
+            *type = WMI_VDEV_TYPE_MONITOR;
+            break;
+		case VOS_SNIFFER_MODE:
+			*type = WMI_VDEV_TYPE_MONITOR;
+			break;
         default:
             hddLog(VOS_TRACE_LEVEL_ERROR, "Invalid device mode %d", mode);
             status = VOS_STATUS_E_INVAL;
diff -Nuar qcacld-new-clean/CORE/VOSS/src/vos_sched.c qcacld-new/CORE/VOSS/src/vos_sched.c
--- qcacld-new-clean/CORE/VOSS/src/vos_sched.c
+++ qcacld-new/CORE/VOSS/src/vos_sched.c
@@ -482,6 +482,7 @@
   v_BOOL_t shutdown              = VOS_FALSE;
   hdd_context_t *pHddCtx         = NULL;
   v_CONTEXT_t pVosContext        = NULL;
+  hdd_adapter_t* pAdapter = NULL;
 
   if (Arg == NULL)
   {
@@ -550,6 +551,13 @@
         }
         break;
       }
+
+		pAdapter = hdd_get_adapter(pHddCtx, WLAN_HDD_SNIFFER);
+		if((pAdapter) && (!pAdapter->init_mon_flag))
+		{
+			pAdapter->init_mon_flag = true;
+			hdd_sniffer_start(pAdapter->dev);
+		}
       /*
       ** Check the WDI queue
       ** Service it till the entire queue is empty
diff -Nuar qcacld-new-clean/CORE/WDA/inc/legacy/halMsgApi.h qcacld-new/CORE/WDA/inc/legacy/halMsgApi.h
--- qcacld-new-clean/CORE/WDA/inc/legacy/halMsgApi.h
+++ qcacld-new/CORE/WDA/inc/legacy/halMsgApi.h
@@ -38,6 +38,7 @@
 #define BSS_OPERATIONAL_MODE_AP     0
 #define BSS_OPERATIONAL_MODE_STA    1
 #define BSS_OPERATIONAL_MODE_IBSS   2
+#define BSS_OPERATIONAL_MODE_SNIFFER   3
 
 /* STA entry type in add sta message */
 #define STA_ENTRY_SELF              0
@@ -1593,4 +1594,18 @@
 };
 #endif
 
+struct hal_enable_monitor_request
+{
+    u_int16_t request_data_len;
+    u_int8_t  request_data[];
+};
+
+struct hal_filter_type_request
+{
+	u_int32_t vdev_id;
+    u_int16_t request_data_len;
+    u_int8_t  request_data[];
+};
+
+
 #endif /* _HALMSGAPI_H_ */
diff -Nuar qcacld-new-clean/CORE/WDA/inc/wlan_qct_wda.h qcacld-new/CORE/WDA/inc/wlan_qct_wda.h
--- qcacld-new-clean/CORE/WDA/inc/wlan_qct_wda.h
+++ qcacld-new/CORE/WDA/inc/wlan_qct_wda.h
@@ -1408,6 +1408,8 @@
 #ifdef WLAN_FEATURE_APFIND
 #define WDA_APFIND_SET_CMD                    SIR_HAL_APFIND_SET_CMD
 #endif /* WLAN_FEATURE_APFIND */
+#define WDA_ENABLE_MONITOR_CMD                    SIR_HAL_ENABLE_MONITOR_CMD
+#define WDA_FILTER_TYPE_CMD                    SIR_HAL_FILTER_TYPE_CMD
 
 #ifdef WLAN_FEATURE_EXTWOW_SUPPORT
 #define WDA_WLAN_EXT_WOW                      SIR_HAL_CONFIG_EXT_WOW
diff -Nuar qcacld-new-clean/Kbuild qcacld-new/Kbuild
--- qcacld-new-clean/Kbuild
+++ qcacld-new/Kbuild
@@ -18,6 +18,7 @@
 	#use pci as default interface
 	CONFIG_ROME_IF = pci
 endif
+CONFIG_ROME_IF = usb
 
 ifeq ($(KERNEL_BUILD),1)
 	# These are provided in external module based builds
